<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>YuanyaDocs</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Root</a></li><li class="chapter-item expanded "><a href="模板.html"><strong aria-hidden="true">1.</strong> 模板</a></li><li class="chapter-item expanded "><a href="番.html"><strong aria-hidden="true">2.</strong> 番</a></li><li class="chapter-item expanded affix "><li class="part-title">计</li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> 操作系统</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="计/操作系统/Linux.html"><strong aria-hidden="true">3.1.</strong> Linux</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="计/操作系统/Linux.eBPF.html"><strong aria-hidden="true">3.1.1.</strong> Linux.eBPF</a></li></ol></li><li class="chapter-item expanded "><a href="计/操作系统/WSL.html"><strong aria-hidden="true">3.2.</strong> WSL</a></li><li class="chapter-item expanded "><a href="计/操作系统/Windows.html"><strong aria-hidden="true">3.3.</strong> Windows</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 虚拟化</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="计/虚拟化/OVS.html"><strong aria-hidden="true">4.1.</strong> OVS</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> OVN</div></li><li class="chapter-item expanded "><a href="计/虚拟化/虚拟网络.html"><strong aria-hidden="true">4.3.</strong> 虚拟网络技术</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 云原生</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="计/云原生/容器.Docker.html"><strong aria-hidden="true">5.1.</strong> Docker</a></li><li class="chapter-item expanded "><a href="计/云原生/Kubernetes.html"><strong aria-hidden="true">5.2.</strong> Kuberntes</a></li><li class="chapter-item expanded "><a href="计/云原生/Prometheus.html"><strong aria-hidden="true">5.3.</strong> Prometheus</a></li><li class="chapter-item expanded "><a href="计/云原生/Sealos.html"><strong aria-hidden="true">5.4.</strong> Sealos</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Kube-OVN</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> AI</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> 机器学习</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="计/AI/机器学习.概念.html"><strong aria-hidden="true">6.1.1.</strong> 概念</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> 语言</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="计/语言/Go.html"><strong aria-hidden="true">7.1.</strong> Go</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> 工具</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="计/工具/Git.html"><strong aria-hidden="true">8.1.</strong> Git</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">YuanyaDocs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h3 id="hi-there-"><a class="header" href="#hi-there-">Hi there 👋</a></h3>
<!--
**YuanyaTianchi/yuanyatianchi** is a ✨ _special_ ✨ repository because its `README.md` (this file) appears on your GitHub profile.

Here are some ideas to get you started:

- 🔭 I’m currently working on ...
- 🌱 I’m currently learning ...
- 👯 I’m looking to collaborate on ...
- 🤔 I’m looking for help with ...
- 💬 Ask me about ...
- 📫 How to reach me: ...
- 😄 Pronouns: ...
- ⚡ Fun fact: ...
-->
<p><img src="./img/%E6%A0%88.svg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>+++</p>
<p>title = &quot;Title.sub_title&quot;
description = &quot;Title sub_title quick_start&quot;
tags = [&quot;techn&quot;, &quot;computer&quot;, &quot;tagx&quot;, &quot;Title&quot;, &quot;_sub_title&quot;, &quot;__quick_start(content)&quot;]</p>
<p>+++</p>
<h1 id="titlesub_title"><a class="header" href="#titlesub_title">Title.sub_title</a></h1>
<blockquote>
<p><a href="">官网</a>；</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="番"><a class="header" href="#番">番</a></h1>
<h2 id="2023"><a class="header" href="#2023">2023</a></h2>
<p>【202301】【日】<a href="https://www.agemys.net/detail/20220199">地狱乐</a>-周六3</p>
<p>【202301】【日】<a href="https://www.agemys.net/detail/20220203">鬼灭之刃3锻刀村篇</a>-周日1</p>
<p>【202301】【日】<a href="https://www.agemys.net/detail/20220244">进击的巨人 最终季 Part.3</a>-周五1</p>
<p>【202301】【日】<a href="https://www.agemys.net/detail/20220441">魔法使的新娘2</a>-周四2</p>
<p>【202301】【日】<a href="https://www.agemys.net/detail/20230072">天国大魔境</a>-周六3</p>
<p>【202301】【日】<a href="https://www.agemys.net/detail/20230003">为美好的世界献上爆炎！</a>-周五2</p>
<p>【202301】【日】<a href="https://www.agemys.net/detail/20230077">我推的孩子</a>-周三1</p>
<p>【202301】【日】fate/strangeFake-0</p>
<p>【202301】【日】阿尔斯的巨兽-0</p>
<p>【202301】【日】<a href="https://www.yhdmp.cc/showp/22350.html"><strong>别当欧尼酱了</strong></a></p>
<p>【202301】【日】<a href="https://www.agemys.net/detail/20210270">冰海战记2</a>-0</p>
<p>【202301】【日】<a href="https://www.agemys.net/detail/20230092">辉夜大小姐想让我告白 初吻不会结束</a></p>
<p>【202301】【日】尼尔：机械纪元-0</p>
<p>【202301】【日】七大罪 怨嗟的爱丁堡 前篇-0</p>
<p>【202301】【日】<a href="https://www.yhdmp.cc/showp/23092.html">文豪野犬4</a>-周三0</p>
<p>【202301】【日】<a href="https://www.bilibili.com/bangumi/media/md28412512">虚构推理2</a>-周日1</p>
<p>【202301】【日】伊藤润二2-0</p>
<p>【202301】【日】<a href="https://www.bilibili.com/bangumi/media/md28412511/">因为太怕痛就全点防御力了</a>-周三6</p>
<h2 id="2022"><a class="header" href="#2022">2022</a></h2>
<p>【202211】【日】<a href="https://www.yhdmp.cc/showp/22099.html">JOJO的奇妙冒险6石之海Part3</a></p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/22465.html"><strong>4个人各自有着自己的秘密</strong></a></p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/22508.html">飙速宅男5</a>-周一10</p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/21333.html">电锯人</a></p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/22203.html">孤独摇滚</a></p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/22322.html">黄金神威4</a>-周一0</p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/22266.html">机动战士高达 水星的魔女</a>-周日0</p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/22518.html">间谍过家家 Part2</a></p>
<p>【202210】【日】<a href="https://www.bilibili.com/bangumi/media/md28339709">灵能百分百3</a></p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/22473.html">名侦探柯南 犯人犯泽先生</a>-周二0</p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/22438.html"><strong>秋叶原女仆战争</strong></a></p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/22209.html">死神 千年血战篇</a>-周二0</p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/22536.html">银河英雄传说 Die Neue These 策谋</a>-周五0</p>
<p>【202209】【日】<a href="https://www.yhdmp.cc/showp/22524.html"><strong>赛博朋克：边缘行者</strong></a></p>
<p>【202207】【日】<a href="https://www.yhdmp.cc/showp/22099.html">JOJO的奇妙冒险6石之海Part2</a></p>
<p>【202207】【日】<a href="https://www.yhdmp.cc/showp/22224.html">Lycoris Recoil</a></p>
<p>【202207】【日】<a href="https://www.yhdmp.cc/showp/21285.html">Overlord4</a></p>
<p>【202207】【日】<a href="https://www.yhdmp.cc/showp/22332.html">RWBY-冰雪帝国</a>-周日4</p>
<p>【202207】【日】<a href="https://www.yhdmp.cc/showp/22294.html">欢迎来到实力至上主义教室2</a></p>
<p>【202207】【日】<a href="https://www.yhdmp.cc/showp/22170.html">狂赌之渊双</a></p>
<p>【202207】【日】<a href="https://www.yhdmp.cc/showp/20181.html"><strong>来自深渊2 烈日的黄金乡</strong></a></p>
<p>【202207】【日】<a href="https://www.agemys.net/play/20220134"><strong>异世界舅舅</strong></a></p>
<p>【202207】【日】<a href="https://www.yhdmp.cc/showp/22084.html">租界女友2</a>-周六18</p>
<p>【202204】【日】<a href="https://www.yhdmp.cc/showp/21157.html">处刑少女的生存之道</a></p>
<p>【202204】【日】<a href="https://www.yhdmp.cc/showp/21104.html"><strong>辉夜大小姐想让我告白3</strong></a></p>
<p>【202204】【日】<a href="https://www.yhdmp.cc/showp/22164.html"><strong>间谍过家家</strong></a></p>
<p>【202204】【日】<a href="https://www.bilibili.com/bangumi/play/ss39725/">理科生坠入情网，故尝试证明2</a>-周六4</p>
<p>【202204】【日】<a href="https://www.bilibili.com/bangumi/play/ss41418/"><strong>恋爱要在征服世界后</strong></a></p>
<p>【202204】【日】<a href="https://www.bilibili.com/bangumi/play/ep478912">恋爱游戏世界对路人角色很不友好</a></p>
<p>【202204】【日】<a href="https://www.yhdmp.cc/showp/22172.html">派对浪客诸葛孔明</a></p>
<p>【202204】【日】<a href="https://www.yhdmp.cc/showp/22165.html">朋友游戏1</a></p>
<p>【202204】【日】<a href="https://www.yhdmp.cc/showp/22162.html"><strong>青之芦苇</strong></a></p>
<p>【202204】【日】<a href="https://www.yhdmp.cc/showp/22174.html">夏日重现</a></p>
<p>【202201】【日】鬼灭之刃3游郭篇</p>
<p>【202201】【日】<strong>进击的巨人最终季part2</strong></p>
<p>【202201】【日】天才王子的赤字国家振兴术</p>
<p>【202201】【日】<strong>与变成了异世界美少女的好友一起冒险</strong></p>
<h2 id="2021"><a class="header" href="#2021">2021</a></h2>
<p>【202110】【日】jojo的奇妙冒险.石之海</p>
<p>【202110】【日】铂金终局</p>
<p>【202110】【日】范马刃牙</p>
<p>【202110】【日】国王排名</p>
<p>【202101】【日】<a href="https://www.agemys.cc/detail/20210314">境界触发者3</a>-0</p>
<p>【202110】【日】<a href="https://www.yhpdm.net/showp/21224.html">魔法使的新娘 西之少年与青岚的骑士</a></p>
<p>【202110】【日】七原罪剧场版 被光诅咒的众人</p>
<p>【202110】【日】<strong>无职转生1part2</strong></p>
<p>【202110】【日】<strong>英雄联盟：双城之战</strong></p>
<p>【202107】【日】超龙珠英雄BM-17</p>
<p>【202107】【日】歌剧少女-0</p>
<p>【202107】【日】<strong>关于我转生变成史莱姆这件事3</strong></p>
<p>【202107】【日】寒蝉鸣泣之时 卒-0</p>
<p>【202107】【日】见面5秒开始战斗</p>
<p>【202107】【日】精灵幻想记</p>
<p>【202107】【日】<strong>平稳世代的韦驮天们</strong></p>
<p>【202107】【日】奇巧计程车</p>
<p>【202107】【日】小林家的龙女仆S</p>
<p>【202107】【日】异世界迷宫黑心企业</p>
<p>【202104】【日】MARS RED-1</p>
<p>【202104】【日】MegaloBOX2</p>
<p>【202104】【日】极道主夫-5</p>
<p>【202104】【日】如果究极进化的完全沉浸RPG比现实更垃圾的话1</p>
<p>【202104】【日】入间同学入魔了2-0</p>
<p>【202104】【日】战斗员派遣中</p>
<p>【202104】【日】转生史莱姆日记-2</p>
<p>【202101】【国】<strong>刺客伍六七之玄武国篇</strong></p>
<p>【202101】【日】BackArrow</p>
<p>【202101】【日】从零开始的异世界生活2.2</p>
<p>【202101】【日】动物狂想曲2</p>
<p>【202101】【日】工作细胞2</p>
<p>【202101】【日】工作细胞Black</p>
<p>【202101】【日】好比是最终迷宫前的少年到新手村生活一般的故事</p>
<p>【202101】【日】<strong>关于我转生变成史莱姆这件事2</strong></p>
<p>【202101】【日】回复术士的重启人生</p>
<p>【202101】【日】记录的地平线3</p>
<p>【202101】【日】<strong>进击的巨人最终季part1</strong></p>
<p>【202101】【日】境界触发者2</p>
<p>【202101】【日】堀与宫村</p>
<p>【202101】【日】<a href="https://www.bilibili.com/bangumi/media/md28232005">七大罪4</a>-14</p>
<p>【202101】【日】弱势角色友崎君</p>
<p>【202101】【日】赛马娘-5</p>
<p>【202101】【日】天空侵犯1</p>
<p>【202101】【日】<strong>无职转生1part1</strong></p>
<p>【202101】【日】摇曳露营2-2</p>
<p>【202101】【日】约定的梦幻岛2</p>
<p>【202101】【日】<strong>转生成蜘蛛又怎样</strong></p>
<h2 id="2020"><a class="header" href="#2020">2020</a></h2>
<p>【202010】【日】成神之日</p>
<p>【202010】【日】鬼灭之刃剧场版 无限列车篇</p>
<p>【202010】【日】魔女之旅1</p>
<p>【202010】【日】全员恶玉</p>
<p>【202010】【日】*在魔王城说晚安</p>
<p>【202010】【日】*咒术回战1</p>
<p>【202007】【国】雾山五行1</p>
<p>【202007】【日】从零开始的异世界生活2.1</p>
<p>【202007】【日】大欺诈师</p>
<p>【202007】【日】刀剑神域3 Alicization3-12</p>
<p>【202007】【日】高校之神-6</p>
<p>【202007】【日】没落要塞/DECA-DENCE</p>
<p>【202007】【日】刃牙2</p>
<p>【202007】【日】天晴烂漫</p>
<p>【202007】【日】我的青春恋爱物语果然有问题3-7</p>
<p>【202007】【日】炎炎消防队2</p>
<p>【202007】【日】租界女友1</p>
<p>【202004】【日】食戟之灵5豪之皿-0</p>
<p>【202004】【日】隐瞒之事</p>
<p>【202004】【日】格莱普尼尔1</p>
<p>【202004】【日】辉夜大小姐想让我告白2</p>
<p>【202004】【日】转生成为了只有乙女游戏破灭Flag的邪恶大小姐</p>
<p>【202004】【日】神之塔1</p>
<p>【202004】【日】动物新世代/BNA</p>
<p>【202001】【日】因为太怕痛就全点防御力了</p>
<p>【202001】【日】异种族风俗娘评鉴指南</p>
<p>【202001】【日】异度入侵ID:INVADED</p>
<p>【202001】【日】虚构推理</p>
<p>【202001】【日】齐木楠雄的灾难 始动篇</p>
<p>【202001】【日】某科学的超电磁炮T-15</p>
<p>【202001】【日】猎龙飞船</p>
<p>【202001】【日】理科生坠入情网，故尝试证明</p>
<p>【202001】【日】达尔文游戏</p>
<p>【202001】【日】<a href="https://www.agemys.cc/detail/20200054"><strong>来自深渊 深沉灵魂的黎明</strong></a></p>
<h2 id="2019"><a class="header" href="#2019">2019</a></h2>
<p>【201910】【日】这个勇者明明超强却过分慎重</p>
<p>【201910】【日】心理测量者3</p>
<p>【201910】【日】我不是说了能力要平均值么</p>
<p>【201910】【日】食戟之灵4神之皿-0</p>
<p>【201910】【日】入间同学入魔了</p>
<p>【201910】【日】七大罪3</p>
<p>【201910】【日】动物狂想曲BEASTARS1</p>
<p>【201910】【日】刀剑神域3 Alicization2</p>
<p>【201910】【国】伍六七之最强发型师</p>
<p>【201908】【日】为美好的世界献上祝福！红传说</p>
<p>【201907】【日】炎炎消防队1</p>
<p>【201907】【日】女高中生的虚度日常</p>
<p>【201907】【日】流汗吧！健身少女</p>
<p>【201907】【日】fate 君主·埃尔梅罗二世事件簿 魔眼收集列车 Grace note</p>
<p>【201907】【日】冰寒战记</p>
<p>【201907】【日】在地下城寻求邂逅是否搞错了什么2-8</p>
<p>【201905】【日】*普罗米亚</p>
<p>【201904】【日】异世界四重奏2</p>
<p>【201904】【日】一拳超人2</p>
<p>【201904】【日】一个人的OO小日子</p>
<p>【201904】【日】贤者之孙</p>
<p>【201904】【日】文豪野犬3</p>
<p>【201904】【日】进击的巨人3</p>
<p>【201904】【日】鬼灭之刃</p>
<p>【201904】【日】CAROLE &amp; TUESDAY</p>
<p>【201901】【日】约定的梦幻岛</p>
<p>【201901】【日】灵能百分百2</p>
<p>【201901】【日】狂赌之渊2</p>
<p>【201901】【日】辉夜大小姐想让我告白</p>
<p>【201901】【日】多罗罗</p>
<p>【201901】【日】盾之勇者成名录</p>
<p>【201901】【日】不吉波普不笑</p>
<h2 id="2018"><a class="header" href="#2018">2018</a></h2>
<p>【201810】【日】佐贺偶像是传奇</p>
<p>【201810】【日】终将成为你</p>
<p>【201810】【日】青春猪头少年不会梦到兔女郎学姐</p>
<p>【201810】【日】强风吹拂</p>
<p>【201810】【日】关于我转生变成史莱姆这件事</p>
<p>【201810】【日】哥布林杀手</p>
<p>【201810】【日】刀剑神域3 Alicization1</p>
<p>【201810】【日】JOJO的奇妙冒险5黄金之风</p>
<p>【201807】【日】游戏3人娘</p>
<p>【201807】【日】异世界魔王与召唤少女的奴隶魔术</p>
<p>【201807】【日】杀戮天使</p>
<p>【201807】【日】刃牙</p>
<p>【201807】【日】轻羽飞扬</p>
<p>【201807】【日】进击的巨人3</p>
<p>【201807】【日】工作细胞</p>
<p>【201807】【日】碧蓝之海</p>
<p>【201807】【日】Overlord2</p>
<p>【201804】【日】宅男腐女恋爱真难</p>
<p>【201804】【日】我的英雄学院3</p>
<p>【201804】【日】食戟之灵ova</p>
<p>【201804】【日】赛马娘</p>
<p>【201804】【日】奴隶区</p>
<p>【201804】【日】魔性之线</p>
<p>【201804】【日】魔法少女网站</p>
<p>【201804】【日】魔法少女俺</p>
<p>【201804】【日】黑社会的超能力女儿</p>
<p>【201804】【日】苍天之拳1</p>
<p>【201804】【日】MegaloBOX1</p>
<p>【201801】【日】紫罗兰永恒花园</p>
<p>【201801】【日】游戏人生剧场版</p>
<p>【201801】【日】摇曳露营</p>
<p>【201801】【日】牙斗兽娘</p>
<p>【201801】【日】齐木楠雄的灾难2</p>
<p>【201801】【日】七大罪2</p>
<p>【201801】【日】龙王的工作</p>
<p>【201801】【日】刻刻-时间暂停</p>
<p>【201801】【日】博多豚骨拉面</p>
<p>【201801】【日】比宇宙更遥远的地方</p>
<p>【201801】【日】OVERLORD</p>
<p>【201801】【日】darling</p>
<p>【201801】【日】Citrus～柑橘味香气～</p>
<p>【201801】【日】B：彼之初</p>
<p>【201801】【日】A.I.C.O. Incarnation</p>
<h2 id="2017"><a class="header" href="#2017">2017</a></h2>
<p>【201710】【日】悠久持有者! 魔法老师2</p>
<p>【201710】【日】血界战线2</p>
<p>【201710】【日】食戟之灵3餐之皿</p>
<p>【201710】【日】少女终末旅行</p>
<p>【201710】【日】奇诺之旅2</p>
<p>【201710】【日】魔法使的新娘</p>
<p>【201710】【日】国王游戏</p>
<p>【201710】【日】关于我女友是一个正经的碧池这件事</p>
<p>【201710】【日】干物妹小埋2</p>
<p>【201710】【日】调教咖啡厅</p>
<p>【201710】【日】*宝石之国</p>
<p>【201710】【日】fate stay night heaven's feel 剧场版</p>
<p>【201707】【日】NewGame2</p>
<p>【201707】【日】笨女孩</p>
<p>【201707】【日】带着智慧型手机闯荡异世界</p>
<p>【201707】【日】欢迎来到实力至上主义教室1</p>
<p>【201707】【日】狂赌之渊1</p>
<p>【201707】【日】<a href="https://www.agemys.cc/detail/20170051"><strong>来自深渊1</strong></a></p>
<p>【201707】【日】恋爱禁止的世界</p>
<p>【201707】【日】骑士与魔法</p>
<p>【201704】【日】樱花任务</p>
<p>【201704】【日】武装少女</p>
<p>【201704】【日】我的英雄学院2</p>
<p>【201704】【日】我的妹妹是黄漫老师</p>
<p>【201704】【日】末日时在做什么？有没有空？可以来拯救吗？</p>
<p>【201704】【日】路人女主的养成方式2</p>
<p>【201704】【日】零之魔法书</p>
<p>【201704】【日】进击的巨人2</p>
<p>【201704】【日】Re:Creators</p>
<p>【201701】【日】ACCA13区监察课</p>
<p>【201701】【日】Hand Shakers</p>
<p>【201701】【日】热诚传说2</p>
<p>【201701】【日】飙速宅男3</p>
<p>【201701】【日】珈百璃的堕落</p>
<p>【201701】【日】兽娘动物园</p>
<p>【201701】【日】兽娘动物园</p>
<p>【201701】【日】为美好的世界献上祝福2</p>
<p>【201701】【日】小林家的龙女仆</p>
<p>【201701】【日】<strong>小魔女学园</strong></p>
<p>【201701】【日】亚人酱有话要说</p>
<p>【201701】【日】<strong>幼女战记</strong></p>
<p>【201701】【日】政宗君的复仇</p>
<h2 id="2016"><a class="header" href="#2016">2016</a></h2>
<p>【201610】【日】我太受欢迎了该怎么办</p>
<p>【201610】【日】我的老婆是学生会长2</p>
<p>【201610】【日】文豪野犬2</p>
<p>【201610】【日】少女编号</p>
<p>【201610】【日】漂流武士</p>
<p>【201610】【日】魔法少女育成计划</p>
<p>【201610】【日】超自然9人组</p>
<p>【201610】【日】冰上的尤里</p>
<p>【201610】【国】亚人2</p>
<p>【201610】【国】凸变英雄</p>
<p>【201607】【日】这个美术社大有问题！</p>
<p>【201607】【日】食戟之灵2贰之皿</p>
<p>【201607】【日】热诚传说1</p>
<p>【201607】【日】齐木楠雄的灾难1</p>
<p>【201607】【日】灵能百分百1</p>
<p>【201607】【日】弹丸论破3</p>
<p>【201607】【日】NEW GAME1</p>
<p>【201607】【国】一人之下</p>
<p>【201604】【日】在下坂本，有何贵干？</p>
<p>【201604】【日】线上游戏的老婆不可能是女生？</p>
<p>【201604】【日】我的英雄学院1</p>
<p>【201604】【日】文豪野犬1</p>
<p>【201604】【日】甲铁城的卡巴内瑞</p>
<p>【201604】【日】Re：从零开始的异界生活</p>
<p>【201604】【日】jojo的奇妙冒险4 不灭钻石</p>
<p>【201601】【日】只有我不在的街道</p>
<p>【201601】【日】无头骑士异闻录 x2 结</p>
<p>【201601】【日】为美好的世界献上祝福1</p>
<p>【201601】【日】灰与幻想的格林姆迦尔</p>
<p>【201601】【国】亚人1</p>
<h2 id="2015"><a class="header" href="#2015">2015</a></h2>
<p>【201510】【日】樱子小姐的脚下埋着尸体</p>
<p>【201510】【日】野良神 ARAGOTO</p>
<p>【201510】【日】我被绑架到贵族女校当庶民样本</p>
<p>【201507】【日】学园孤岛</p>
<p>【201507】【日】无头骑士异闻录 x2 转</p>
<p>【201507】【日】我老婆是学生会长</p>
<p>【201507】【日】噬神者</p>
<p>【201507】【日】绅士学园</p>
<p>【201507】【日】黑街GANGSTA</p>
<p>【201507】【日】干物妹！小埋</p>
<p>【201507】【日】OVERLORD1</p>
<p>【201504】【日】血界战线1</p>
<p>【201504】【日】食戟之灵1</p>
<p>【201504】【日】吹响吧！上低音号</p>
<h2 id="2014"><a class="header" href="#2014">2014</a></h2>
<p>【201310】【日】寄生兽</p>
<p>【201310】【日】记录的地平线2</p>
<p>【201410】【日】境界触发者1</p>
<p>【201404】【日】进击的巨人1</p>
<p>【201401】【日】野良神1</p>
<h2 id="2013"><a class="header" href="#2013">2013</a></h2>
<p>【201310】【日】记录的地平线1</p>
<p>【201310】【日】斩服少女</p>
<p>【201307】【日】恋爱研究所</p>
<p>【201304】【日】某科学的超电磁炮S</p>
<h2 id="2012"><a class="header" href="#2012">2012</a></h2>
<p>【201209】【日】来自新世界</p>
<p>【201201】【日】Another</p>
<h2 id="2011"><a class="header" href="#2011">2011</a></h2>
<h2 id="2010"><a class="header" href="#2010">2010</a></h2>
<p>【201010】【日】魔法禁书目录2</p>
<h2 id="2009"><a class="header" href="#2009">2009</a></h2>
<p>【200910】【日】某科学的超电磁炮</p>
<h2 id="2008"><a class="header" href="#2008">2008</a></h2>
<p>【200810】【日】魔法禁书目录1</p>
<h2 id="2007"><a class="header" href="#2007">2007</a></h2>
<p>【200704】【日】大剑</p>
<h2 id="2006"><a class="header" href="#2006">2006</a></h2>
<p>【200610】【日】死亡笔记</p>
<h2 id="1995"><a class="header" href="#1995">1995</a></h2>
<p>【199510】【日】新世纪福音战士</p>
<div style="break-before: page; page-break-before: always;"></div><p>+++</p>
<p>title = &quot;Linux&quot;
description = &quot;Linux quick start&quot;
tags = [&quot;techn&quot;, &quot;computer&quot;, &quot;os&quot;, &quot;Linux&quot;, &quot;__quick_start&quot;]</p>
<p>+++</p>
<h1 id="linux"><a class="header" href="#linux">Linux</a></h1>
<blockquote>
<p><a href="https://www.kernel.org/">官网</a>；</p>
<p><a href="https://git.kernel.org/">仓库</a>；</p>
<p><a href="https://en.wikipedia.org/wiki/Linus_Torvalds">Linus Torvalds</a>；</p>
</blockquote>
<h1 id="快开"><a class="header" href="#快开">快开</a></h1>
<h2 id="virtualbox"><a class="header" href="#virtualbox">VirtualBox</a></h2>
<blockquote>
<p><a href="https://www.virtualbox.org/wiki/Downloads">Download VirtualBox</a>；</p>
</blockquote>
<p>VirtualBox7.0 默认兼容 hyper-v，可以与 wsl 共存；</p>
<p>安装 platform packages 即可，Extension Pack 根据需要考虑</p>
<h3 id="安装-vm"><a class="header" href="#安装-vm">安装 VM</a></h3>
<ol>
<li>
<p>新建</p>
</li>
<li>
<p>名称：demovm → 文件夹：D:\it\vm\vms → 类型：Linux → 版本：Ubuntu/Red Hat...</p>
</li>
<li>
<p>内存大小：2048mb</p>
</li>
<li>
<p>现在创建虚拟硬盘 → VDI (VirtualBox 磁盘映像) → 动态分配 → 硬盘大小：32G</p>
</li>
<li>
<p>设置 → 存储 → 控制器: IDE → 右侧光盘图标选择虚拟盘 → OK</p>
</li>
<li>
<p>设置 → 网络 → 选择桥接网卡</p>
</li>
<li>
<p>启动：这里根据发行商版本有所不同</p>
<ol>
<li>
<p>Install xxx → English</p>
</li>
<li>
<p>DATE &amp; TIME → Asia Shanghai</p>
</li>
<li>
<p>SOFTWARE SELECTION → Minimal Install （按需选择）</p>
</li>
<li>
<p>INSTALL ATION DESTINATION → 直接点done即可</p>
</li>
<li>
<p>NETWORK &amp; HOST NAME → Ethernet (enp0s3)：ON</p>
</li>
<li>
<p>开始安装 → 设置 ROOT PASSWORD → 安装成功后 reboot</p>
</li>
</ol>
</li>
</ol>
<h3 id="启用虚拟机与宿主机共享-粘贴板卷"><a class="header" href="#启用虚拟机与宿主机共享-粘贴板卷">启用虚拟机与宿主机共享 粘贴板/卷</a></h3>
<p>进入 VM 设置</p>
<ol>
<li>
<p>设置 - 常规 - 高级 - 共享粘贴板 双向 &amp; 拖放 双向</p>
</li>
<li>
<p>设置 - 存储 - 控制器：SATA - √ 使用主机输入输出（I/O）缓存</p>
</li>
<li>
<p>设置 - 存储 - 控制器：SATA - .vdi - √ 固态驱动器(s)</p>
</li>
<li>
<p>ubuntu：只需要安装gcc make perl</p>
<pre><code class="language-shell">apt install -y gcc make perl
</code></pre>
</li>
<li>
<p>centos：</p>
<p>kernel-devel</p>
<pre><code class="language-sh"># 安装 kernel-devel 和 gcc
yum install -y kernel-devel gcc
# 更新 kernel 和 kernel-devel 到最新版本
yum upgrade kernel kernel-devel -y
# 重启
reboot
</code></pre>
<p>虚拟机窗口上方菜单栏 - 设备 - 安装增强功能，会挂载一个盘，如果程序没有自动执行则到挂载的盘中运行<code>aoturun.sh</code>（重新安装要先弹出iso，否则报&quot;未能加载虚拟光盘&quot;）</p>
<pre><code class="language-shell"># 必要依赖。安装时提示 please install the gcc make perl packages from your modules；安装过后日志里又提示 please install libelf-dev, libelf-devel or elfutils-libelf-devel 
yum install gcc make perl elfutils-libelf-devel -y
# 如果提示 ValueError: File context for /opt/VBoxGuestAdditions-6.1.4/other/mount.vboxsf already defined
semanage fcontext -d /opt/VBoxGuestAdditions-6.1.4/other/mount.vboxsf
restorecon /opt/VBoxGuestAdditions-6.1.4/other/mount.vboxsf
# 若是以上相关软件或内核更新后，增强功能还无法正常使用，使用一次性更新所有软件（这次可以了）
yum update
# 重启
reboot
</code></pre>
<p>stalstalstal</p>
</li>
</ol>
<h2 id="ubuntu"><a class="header" href="#ubuntu">Ubuntu</a></h2>
<blockquote>
<p><a href="https://mirrors.aliyun.com/ubuntu-releases/">ubuntu 阿里云镜像</a>；</p>
</blockquote>
<h3 id="root-密码设置"><a class="header" href="#root-密码设置">root 密码设置</a></h3>
<pre><code class="language-shell">sudo passwd

# 登录root
su root
</code></pre>
<h3 id="vi"><a class="header" href="#vi">vi</a></h3>
<pre><code class="language-shell"># vi 默认情况下上下左右、backspace等按键非正常作用，须配置`/etc/vim/vimrc.tiny`
cat &gt;&gt; /etc/vim/vimrc.tiny &lt;&lt; EOF

set nocompatible
set backspace=2
EOF
</code></pre>
<h3 id="快速关机"><a class="header" href="#快速关机">快速关机</a></h3>
<pre><code class="language-shell"># 快速关机
sed -i '/#DefaultTimeoutStartSec=90s/aDefaultTimeoutStartSec=5s' /etc/systemd/system.conf
sed -i '/#DefaultTimeoutStopSec=90s/aDefaultTimeoutStopSec=5s' /etc/systemd/system.conf
</code></pre>
<h3 id="网卡配置"><a class="header" href="#网卡配置">网卡配置</a></h3>
<pre><code class="language-shell"># 系统会读取 `/etc/netplan/*.yaml`
cat &gt;&gt; /etc/netplan/02.yaml &lt;&lt; EOF
network:
  version: 2
  renderer: NetworkManager
  ethernets:
    enp0s0:
      dhcp4: false
      # gateway4: 192.168.1.1
      routes:
      - to: default # default 必需
        via: 192.168.1.1  # gateway, same as gateway4
      addresses:
      - 192.168.1.10/24
      nameservers:
        addresses: [192.168.1.1,8.8.8.8] # DNS
        search: []
    enp0s3:
      dhcp4: false
      # gateway4: 192.168.31.1
      routes:
      - to: 192.168.31.0/24
        via: 192.168.31.1  # gateway, same as gateway4
      addresses:
      - 192.168.31.10/24
      nameservers:
        addresses: [192.168.31.1,8.8.8.8] # DNS
        search: []
EOF

# 应用配置
netplan apply
</code></pre>
<h3 id="apt-源"><a class="header" href="#apt-源">apt 源</a></h3>
<pre><code class="language-shell">$ mv /etc/apt/sources.list /etc/apt/sources.list.bk
$ cat &gt; /etc/apt/sources.list &lt;&lt; EOF
deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse
EOF
# 更新源
$ apt update &amp;&amp; apt upgrade -y
</code></pre>
<h3 id="ssh-服务启用"><a class="header" href="#ssh-服务启用">ssh 服务启用</a></h3>
<pre><code class="language-shell"># 安装
apt install -y openssh-server
# 默认禁止远程登录，需 /etc/ssh/sshd_config 中 PermitRootLogin 字段
sed -i '/#PermitRootLogin prohibit-password/aPermitRootLogin yes' /etc/ssh/sshd_config
# 重启
systemctl restart sshd
</code></pre>
<h3 id="http-代理"><a class="header" href="#http-代理">http 代理</a></h3>
<h3 id="https-访问"><a class="header" href="#https-访问">https 访问</a></h3>
<pre><code class="language-shell">apt install -y ca-certificates curl gnupg
</code></pre>
<h3 id="root-图形界面登录"><a class="header" href="#root-图形界面登录">root 图形界面登录</a></h3>
<p>Ubuntu 桌面版不允许图形界面登录 root 用户，须注释 <code>/etc/pam.d/gdm-password</code> &amp; <code>/etc/pam.d/gdm-autologin</code> 文件中 <code>auth required pam_succeed_if.so user != root quiet_success</code> 所在行</p>
<pre><code class="language-shell">sed -i 's/auth.*required.*pam_succeed_if.so user != root quiet_success/# auth\trequired\tpam_succeed_if.so user != root quiet_success/g' /etc/pam.d/gdm-password
sed -i 's/auth.*required.*pam_succeed_if.so user != root quiet_success/# auth\trequired\tpam_succeed_if.so user != root quiet_success/g' /etc/pam.d/gdm-autologin
</code></pre>
<h3 id="用户文件夹"><a class="header" href="#用户文件夹">用户文件夹</a></h3>
<p>指定Desktop、Downloads等</p>
<pre><code class="language-shell">sed -i 's/XDG_DESKTOP_DIR=.*/XDG_DESKTOP_DIR=&quot;$HOME\/dirs\/Desktop&quot;/g' ~/.config/user-dirs.dirs
sed -i 's/XDG_DOWNLOAD_DIR=.*/XDG_DOWNLOAD_DIR=&quot;$HOME\/dirs\/Downloads&quot;/g' ~/.config/user-dirs.dirs
sed -i 's/XDG_TEMPLATES_DIR=.*/XDG_TEMPLATES_DIR=&quot;$HOME\/dirs\/Templates&quot;/g' ~/.config/user-dirs.dirs
sed -i 's/XDG_PUBLICSHARE_DIR=.*/XDG_PUBLICSHARE_DIR=&quot;$HOME\/dirs\/Public&quot;/g' ~/.config/user-dirs.dirs
sed -i 's/XDG_DOCUMENTS_DIR=.*/XDG_DOCUMENTS_DIR=&quot;$HOME\/dirs\/Documents&quot;/g' ~/.config/user-dirs.dirs
sed -i 's/XDG_MUSIC_DIR=.*/XDG_MUSIC_DIR=&quot;$HOME\/dirs\/Music&quot;/g' ~/.config/user-dirs.dirs
sed -i 's/XDG_PICTURES_DIR=.*/XDG_PICTURES_DIR=&quot;$HOME\/dirs\/Pictures&quot;/g' ~/.config/user-dirs.dirs
sed -i 's/XDG_VIDEOS_DIR=.*/XDG_VIDEOS_DIR=&quot;$HOME\/dirs\/Videos&quot;/g' ~/.config/user-dirs.dirs
# 现在使用
nautilus -q
</code></pre>
<h3 id="其它软件"><a class="header" href="#其它软件">其它软件</a></h3>
<pre><code class="language-shell">apt install -y vim git sshpass
</code></pre>
<h2 id="centos"><a class="header" href="#centos">CentOS</a></h2>
<blockquote>
<p><a href="https://mirrors.aliyun.com/ubuntu-releases/">centos阿里云镜像</a>；</p>
</blockquote>
<h1 id="基操"><a class="header" href="#基操">基操</a></h1>
<h2 id="别名"><a class="header" href="#别名">别名</a></h2>
<p>后台启动且不做输出（输出到 <code>/dev/null</code>）</p>
<pre><code class="language-shell">alias goland=&quot;nohup ~/techn/computer/lang/go/goland/bin/goland.sh &gt;/dev/null &amp; 2&gt;&amp;1&quot;'
</code></pre>
<h2 id="ssh-免密"><a class="header" href="#ssh-免密">ssh 免密</a></h2>
<pre><code class="language-shell">sshpass -p &lt;password&gt; ssh -o StrictHostKeychecking=no -o ServerAliveInterval=60 root@192.168.1.11
</code></pre>
<h2 id="批量操作"><a class="header" href="#批量操作">批量操作</a></h2>
<p>通过 <code>grep</code>、<code>awk</code>、<code>xargs</code> 实现</p>
<pre><code class="language-shell">kubectl get pod | grep Terminating | awk '{print $1}' | xargs kubectl delete pod --grace-period=0 --force
</code></pre>
<h2 id="netplan-网桥配置"><a class="header" href="#netplan-网桥配置">netplan 网桥配置</a></h2>
<blockquote>
<p><a href="https://netplan.io/examples">netplan examples</a>；</p>
<p><a href="https://netplan.io/examples#configuring-network-bridges">configuring-network-bridges</a>；</p>
</blockquote>
<pre><code class="language-shell">$ cat &gt; /etc/netplan/br.yaml &lt;&lt; EOF
network:
  version: 2
  renderer: networkd
  ethernets:
    eth0:
      dhcp4: no
  bridges:
    br0:
      dhcp4: yes
      interfaces:
        - eth0
EOF

$ netplan apply
</code></pre>
<h2 id="sh--c"><a class="header" href="#sh--c">sh -c</a></h2>
<p>这个命令将权限不够，因为重定向符号 “&gt;” 和 &quot;&gt;&gt;&quot; 也是 bash 的命令。我们使用 sudo 只是让 echo 命令具有了 root 权限</p>
<pre><code class="language-sh">sudo echo &quot;hahah&quot; &gt;&gt; test.csv`
</code></pre>
<p><code>sh -c</code> 命令，它可以让 bash 将一个字串作为完整的命令来执行，这样就可以将 sudo 的影响范围扩展到整条命令</p>
<pre><code class="language-sh">sudo sh -c echo &quot;hahah&quot; &gt;&gt; test.csv`
</code></pre>
<h2 id="hostname"><a class="header" href="#hostname">hostname</a></h2>
<pre><code class="language-sh">vim /etc/hostname
# 或者
hostnamectl set-hostname xxx
# 查看
hostname
hostnamectl
</code></pre>
<h2 id="sysctl"><a class="header" href="#sysctl">sysctl</a></h2>
<p>可以查看和修改系统参数</p>
<h2 id="grubby"><a class="header" href="#grubby">grubby</a></h2>
<p>可以修改内核参数</p>
<h2 id="快捷键"><a class="header" href="#快捷键">快捷键</a></h2>
<ul>
<li>TAB快捷键补全文件（目录）名</li>
<li>CTRL+L清屏</li>
<li>CTRL+C终止（命令）程序</li>
</ul>
<h3 id="帮助命令"><a class="header" href="#帮助命令">帮助命令</a></h3>
<h6 id="help"><a class="header" href="#help">help</a></h6>
<pre><code class="language-shell">help cd   #查看内部命令帮助
type cd   #查看命令类型。shell（命令解释器）自带的命令称为内部命令，其他的是外部命令
ls --help #查看外部命令帮助
</code></pre>
<h6 id="info"><a class="header" href="#info">info</a></h6>
<pre><code class="language-shell">info ls #查看ls命令的信息。info比help更详细，作为help的补充
</code></pre>
<h6 id="man"><a class="header" href="#man">man</a></h6>
<ul>
<li><code>man [(1)|2|3|4|5|6|7|8|9] [文件名]</code>：查看指定文件（程序）对应的手册（如果有的话）。这里1-9指定要查看手册的类型，因为系统中很多重名文件，所以需要分类来区分</li>
<li>按<code>Q</code>退出手册</li>
</ul>
<pre><code class="language-shell">man man   #查看man命令的手册。可以看到默认的选项&quot;1&quot;，表示查看 可执行程序或shell命令 这一类型的文件的手册

man ls    #查看ls命令的手册。选项&quot;1&quot;是默认选项，可以省略
man 1 ls
man -a ls #查看所有名为ls的文件的手册
</code></pre>
<h2 id="命令行语法"><a class="header" href="#命令行语法">命令行语法</a></h2>
<ul>
<li>命令 &lt;必选参数1 | 必选参数2&gt; [-option {必选参数1 | 必选参数2 | 必选参数3}] [可选参数...] {(默认参数) | 参数 | 参数}</li>
<li>命令行语法符号
<ul>
<li>方括号**[ ]**：可选参数，在命令中根据需要加以取舍</li>
<li>尖括号**&lt; &gt;**：必选参数，实际使用时应将其替换为所需要的参数</li>
<li>大括号**{ }**：必选参数, 内部使用, 包含此处允许使用的参数</li>
<li>小括号**()**：指明参数的默认值, 只用于{ }中</li>
<li>管道符（竖线）<strong>|</strong>：分隔多个互斥参数, 含义为&quot;或&quot;, 使用时只能选择一个</li>
<li>省略号**...**：多个参数</li>
<li>分号**;**：分割多个命令，命令将按顺序执行</li>
</ul>
</li>
<li>注意：命令行语法（包括在 UNIX 和 Linux 平台中使用的用户名、密码和文件名）是区分大小写的，如commandline、CommandLine、COMMANDLINE 是不一样的</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>+++</p>
<p>title = &quot;eBPF&quot;
description = &quot;it.os.linux.eBPF&quot;
tags = [&quot;it&quot;,&quot;os&quot;,&quot;linux&quot;]</p>
<p>+++</p>
<h1 id="ebpf"><a class="header" href="#ebpf">eBPF</a></h1>
<blockquote>
<p><a href="https://ebpf.io/">官网</a>；</p>
<p><a href="https://cilium.readthedocs.io/en/stable/bpf/">eBPF 和 XDP 参考指南</a> &amp; <a href="https://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/">翻译</a>；</p>
<p><a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">bpf-helpers</a>；</p>
<p><a href="https://arthurchiao.art/blog/bpf-advanced-notes-1-zh/">BPF 程序类型详解</a>；</p>
<p><a href="https://arthurchiao.art/blog/bpf-advanced-notes-2-zh/">BPF Map 类型详解</a>；</p>
<p><a href="%E8%AE%A1/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/iovisor/bcc">iovisor/bcc</a>；</p>
<p>使用 python 开发 eBPF 程序；</p>
<p><a href="%E8%AE%A1/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/cilium/ebpf">cilium/ebpf</a>；</p>
<p><a href="https://github.com/iovisor/gobpf">iovisor/gobpf</a>；</p>
<p><a href="https://www.sobyte.net/post/2022-04/go-ebfp/">使用 Go 语言开发 eBPF 程序</a>；</p>
</blockquote>
<h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<blockquote>
<p><a href="https://ebpf.io/what-is-ebpf#introduction-to-ebpf">eBPF简介</a>；</p>
</blockquote>
<p><img src="https://ebpf.io/static/go-1a1bb6f1e64b1ad5597f57dc17cf1350.png" alt="" /></p>
<h2 id="过程"><a class="header" href="#过程">过程</a></h2>
<p><img src="%E8%AE%A1/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/./img/Linux.eBPF.%E8%BF%87%E7%A8%8B.svg" alt="" /></p>
<h2 id="技术栈"><a class="header" href="#技术栈">技术栈</a></h2>
<blockquote>
<p><a href="http://arthurchiao.art/blog/bpf-portability-and-co-re-zh/">[译] BPF 可移植性和 CO-RE (compile once - run everywhere)</a>；<a href="https://facebookmicrosites.github.io/bpf/blog/2020/02/19/bpf-portability-and-co-re.html">BPF Portability and CO-RE</a>；</p>
</blockquote>
<p><img src="%E8%AE%A1/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/./img/Linux.eBPF.%E6%8A%80%E6%9C%AF%E6%A0%88.svg" alt="" /></p>
<h2 id="co-re"><a class="header" href="#co-re">CO-RE</a></h2>
<h3 id="btf"><a class="header" href="#btf">BTF</a></h3>
<p>检查BTF开启</p>
<pre><code class="language-shell">$ cat /boot/config-`uname -r` | grep BTF
CONFIG_VIDEO_SONY_BTF_MPX=m
CONFIG_DEBUG_INFO_BTF=y
CONFIG_PAHOLE_HAS_SPLIT_BTF=y
CONFIG_DEBUG_INFO_BTF_MODULES=y
</code></pre>
<h3 id="vmlinuxh"><a class="header" href="#vmlinuxh">vmlinux.h</a></h3>
<pre><code class="language-shell"># 生成vmlinux.h
$ bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h
</code></pre>
<h2 id="bpf-prog"><a class="header" href="#bpf-prog">BPF prog</a></h2>
<pre><code class="language-c">#include &quot;vmlinux.h&quot;

#include &lt;bpf/bpf_helpers.h&gt;
#include &lt;bpf/bpf_tracing.h&gt;

SEC(&quot;&lt;bpf_type&gt;/&lt;trace_name&gt;&quot;)
int kprobe__do_sys_openat2(struct pt_regs *ctx)
{
    char file_name[256];
    bpf_probe_read(file_name, sizeof(file_name), PT_REGS_PARM2(ctx));

    char fmt[] = &quot;open file %s\n&quot;;
    bpf_trace_printk(fmt, sizeof(fmt), &amp;file_name);

    return 0;
}
</code></pre>
<p>vmlinux.h：见CO-RE vmlinux.h</p>
<p>bpf_type：不同的类型有不同的使用方式和限制，详见下面<a href="%E8%AE%A1/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.eBPF.html#eBPF%E7%B1%BB%E5%9E%8B">eBPF类型</a>。</p>
<p>trace_name：对于</p>
<h3 id="编译"><a class="header" href="#编译">编译</a></h3>
<pre><code class="language-makefile"></code></pre>
<h3 id="类型"><a class="header" href="#类型">类型</a></h3>
<h3 id="kprobes"><a class="header" href="#kprobes">kprobes</a></h3>
<pre><code class="language-c">#include &quot;vmlinux.h&quot;

#include &lt;bpf/bpf_helpers.h&gt;
#include &lt;bpf/bpf_tracing.h&gt;

SEC(&quot;kprobe/do_sys_openat2&quot;)
int kprobe__do_sys_openat2(struct pt_regs *ctx)
{
    char file_name[256];
    bpf_probe_read(file_name, sizeof(file_name), PT_REGS_PARM2(ctx));

    char fmt[] = &quot;open file %s\n&quot;;
    bpf_trace_printk(fmt, sizeof(fmt), &amp;file_name);

    return 0;
}
</code></pre>
<h3 id="tracepoint"><a class="header" href="#tracepoint">tracepoint</a></h3>
<h3 id="raw_tracepoint"><a class="header" href="#raw_tracepoint">raw_tracepoint</a></h3>
<h2 id="bpf-map"><a class="header" href="#bpf-map">BPF map</a></h2>
<h2 id="vmlinux"><a class="header" href="#vmlinux">vmlinux</a></h2>
<h2 id="libbpfgo"><a class="header" href="#libbpfgo">libbpfgo</a></h2>
<blockquote>
<p><a href="https://github.com/aquasecurity/libbpfgo">aquasecurity/libbpfgo</a>：一个通过cgo调用libbpf库的go语言封装。</p>
<p><a href="https://mozillazg.com/2022/05/ebpf-libbpfgo-develop-env-and-hello-world.html">libbpfgo 使用示例：搭建开发环境以及编写第一个 ebpf 程序</a>；</p>
<p><a href="https://libbpf.readthedocs.io/en/latest/program_types.html">文档</a>；</p>
</blockquote>
<h3 id="依赖"><a class="header" href="#依赖">依赖</a></h3>
<pre><code class="language-shell"># 安装：clang llvm elf bpftool
$ apt install -y clang llvm libelf-dev linux-tools-common
# 执行：仍收到以下提示
$ bpftool 
WARNING: bpftool not found for kernel 5.15.0-52

  You may need to install the following packages for this specific kernel:
    linux-tools-5.15.0-52-generic
    linux-cloud-tools-5.15.0-52-generic

  You may also want to install one of the following packages to keep up to date:
    linux-tools-generic
    linux-cloud-tools-generic
# 安装
$ apt install -y linux-tools-5.15.0-52-generic
</code></pre>
<h3 id="makefile"><a class="header" href="#makefile">Makefile</a></h3>
<pre><code class="language-makefile">ROOT = ./
OUTPUT = ./build

$(OUTPUT):
	mkdir -p $(OUTPUT)

# ---------------- vmlinuxh
# vmlinuxh: vmlinux header file, generated by
# `bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; OUTPUT/vmlinux.h`
.PHONY: vmlinuxh
VMLINUXH = $(OUTPUT)/vmlinux.h
BPFTOOL = $(shell which bpftool || /bin/false)
BTFFILE = /sys/kernel/btf/vmlinux
DBGVMLINUX = /usr/lib/debug/boot/vmlinux-$(shell uname -r)

vmlinuxh: $(VMLINUXH)
$(VMLINUXH): $(OUTPUT)
ifeq ($(wildcard $(BPFTOOL)),)
	@echo &quot;ERROR: could not find bpftool&quot;
	@exit 1
endif
	@if [ -f $(DBGVMLINUX) ]; then \
		echo &quot;INFO: found dbg kernel, generating $(VMLINUXH) from $(DBGVMLINUX)&quot;; \
		$(BPFTOOL) btf dump file $(DBGVMLINUX) format c &gt; $(VMLINUXH); \
	fi
	@if [ ! -f $(BTFFILE) ] &amp;&amp; [ ! -f $(DBGVMLINUX) ]; then \
		echo &quot;ERROR: kernel does not seem to support BTF&quot;; \
		exit 1; \
	fi
	@if [ ! -f $(VMLINUXH) ]; then \
		echo &quot;INFO: generating $(VMLINUXH) from $(BTFFILE)&quot;; \
		$(BPFTOOL) btf dump file $(BTFFILE) format c &gt; $(VMLINUXH); \
	fi

# ---------------- c
# C
CC = gcc
CFLAGS = -ggdb -gdwarf -O2 -Wall -fpie -Wno-unused-variable -Wno-unused-function

# ---------------- libbpf
# libbpf: default static libbpf
LIBBPF_SRC = $(abspath ./3rdparty/libbpf/src)
LIBBPF_DST = $(abspath $(OUTPUT)/libbpf)
GIT = $(shell which git || /bin/false)

$(LIBBPF_SRC):
ifeq ($(wildcard $@), )
	echo &quot;INFO: updating submodule 'libbpf'&quot;
	$(GIT) submodule update --init --recursive
endif
$(LIBBPF_DST):
	mkdir -p $(LIBBPF_DST)

.PHONY: libbpf
libbpf: libbpf-static

# ---------------- ---------------- libbpf static
# libbpf static: static libbpf generation for the git submodule
LIBBPF_DESTDIR = $(abspath $(OUTPUT))
LIBBPF_OBJDIR = $(abspath $(OUTPUT)/libbpf)
LIBBPF_OBJ = $(abspath $(LIBBPF_OBJDIR)/libbpf.a)
LDFLAGS =

.PHONY: libbpf-static
libbpf-static: $(LIBBPF_OBJ)
$(LIBBPF_OBJ): $(LIBBPF_SRC) $(wildcard $(LIBBPF_SRC)/*.[ch]) | $(LIBBPF_DST)
	CC=&quot;$(CC)&quot; CFLAGS=&quot;$(CFLAGS)&quot; LD_FLAGS=&quot;$(LDFLAGS)&quot; \
	$(MAKE) -C $(LIBBPF_SRC) \
		BUILD_STATIC_ONLY=1 \
		DESTDIR=$(LIBBPF_DESTDIR) \
		OBJDIR=$(LIBBPF_OBJDIR) \
		INCLUDEDIR= LIBDIR= UAPIDIR= prefix= libdir= \
		install

# ---------------- ---------------- libbpf dynamic
# libbpf dynamic:
CGO_CFGLAGS_DYN = &quot;-I. -I/usr/include/&quot;
CGO_LDFLAGS_DYN = &quot;-lelf -lz -lbpf&quot;
CGO_EXTLDFLAGS_DYN = '-w'

.PHONY: libbpf-dynamic
libbpf-dynamic:
	echo nothing

# ---------------- program
PROGRAM = ytrace

# ---------------- bpf program
# bpf prog: clang -O2 -Wall -target bpf
CLANG = clang
BPF_SRC = $(abspath $(ROOT)/pkg/bpf)
BPF_CFLAGS_STATIC = &quot;-I$(abspath $(OUTPUT))&quot;
BPF_LDFLAGS_STATIC = &quot;-lelf -lz $(LIBBPF_OBJ)&quot;

.PHONY: $(PROGRAM).bpf.c
$(PROGRAM).bpf.o: $(PROGRAM).bpf.c | vmlinuxh
	$(CLANG) -D__TARGET_ARCH_x86 \
		$(CFLAGS) -target bpf -I. -I$(OUTPUT) \
		-c $&lt; -o $@

# ---------------- go program
# go prog
OS := $(shell uname -s)
ARCH := $(shell uname -m)
ARCH := $(subst x86_64,amd64,$(ARCH))
GOARCH := $(ARCH)
CGO_CFLAGS_STATIC = &quot;-I$(abspath $(OUTPUT))&quot;
CGO_LDFLAGS_STATIC = &quot;-lelf -lz $(LIBBPF_OBJ)&quot;
CGO_EXTLDFLAGS_STATIC = '-w -extldflags &quot;-static&quot;'

.PHONY: $(PROGRAM)
$(PROGRAM): libbpf | $(PROGRAM).bpf.o
	CC=$(CLANG) GOOS=linux GOARCH=$(GOARCH) \
	CGO_CFLAGS=$(CGO_CFLAGS_STATIC) CGO_LDFLAGS=$(CGO_LDFLAGS_STATIC) \
	go build -tags netgo -ldflags $(CGO_EXTLDFLAGS_STATIC) \
		-o $(PROGRAM) ./$(PROGRAM).go

# ---------------- all
all:
	$(MAKE) -C . $(PROGRAM)

# ---------------- clean
clean:
	$(MAKE) -C $(LIBBPF_SRC) clean
	rm -rf $(OUTPUT)
	rm -rf $(VMLINUXH)
	rm -rf $(PROGRAM) $(PROGRAM)-*static $(PROGRAM)-*dynamic
	rm -rf $(PROGRAM).bpf.o $(PROGRAM).o

</code></pre>
<p>ebpf/c/</p>
<pre><code class="language-c">#include &quot;vmlinux.h&quot;

#include &lt;bpf/bpf_helpers.h&gt;
#include &lt;bpf/bpf_tracing.h&gt;

SEC(&quot;kprobe/do_sys_openat2&quot;)
int kprobe__do_sys_openat2(struct pt_regs *ctx)
{
    char file_name[256];
    bpf_probe_read(file_name, sizeof(file_name), PT_REGS_PARM2(ctx));

    char fmt[] = &quot;open file %s\n&quot;;
    bpf_trace_printk(fmt, sizeof(fmt), &amp;file_name);

    return 0;
}
</code></pre>
<pre><code class="language-shell">clang -D__TARGET_ARCH_x86 -I. -I../c/  -target bpf -c bpf.o.c -o bpf.o
</code></pre>
<h2 id="实验基于-ebpf-的网络观测"><a class="header" href="#实验基于-ebpf-的网络观测">实验：基于 eBPF 的网络观测</a></h2>
<blockquote>
<p><a href="https://blog.csdn.net/flynetcn/article/details/119487894">Linux网络新技术基石：eBPF and XDP</a>；</p>
</blockquote>
<h2 id="tracee二次开发"><a class="header" href="#tracee二次开发">tracee二次开发</a></h2>
<blockquote>
<p><a href="https://github.com/aquasecurity/tracee">aquasecurity/tracee</a>：使用 Linux <strong>eBPF 技术</strong>在运行时<strong>跟踪您的系统和应用程序，并分析收集的事件以检测</strong>可疑的行为模式。</p>
<p>tracee 依赖于 libbpf</p>
</blockquote>
<h3 id="libbpf"><a class="header" href="#libbpf">libbpf</a></h3>
<blockquote>
<p><a href="https://github.com/libbpf/libbpf">libbpf</a>：可以构建支持 <a href="https://github.com/libbpf/libbpf#bpflibbpf-usage-and-questions">BPF CO-RE(Compile Once – Run Everywhere)</a> 的高可移植性 BPF 程序。与 <a href="https://github.com/iovisor/bcc/">BCC</a> 相比，它不需要将 Clang/LLVM 运行时部署到目标服务器，并且不依赖于可用的内核开发头文件。</p>
<p>BTF：libbpf 依赖于内核 BTF，RHEL 8.2+、Ubuntu 20.10 等发行版都已经内置内核 BTF；内核 BTF 需要在<strong>编译</strong>内核时设置<code>CONFIG_DEBUG_INFO_BTF=y</code>构建选项；通过查看是否存在文件<code>/sys/kernel/btf/vmlinux</code>以检查内核是否内置 BTF</p>
</blockquote>
<p>安装</p>
<pre><code class="language-shell"># 

# libbpf 在 tracee 项目 make 中的安装方式
CC=&quot;clang&quot; \
CFLAGS=&quot;&quot;-fPIC&quot;&quot; \
LD_FLAGS=&quot;&quot; \
make \
-C ./3rdparty/libbpf/src \
BUILD_STATIC_ONLY=1 \
DESTDIR=/root/projects/github.com/tracee/dist/libbpf \
OBJDIR=/root/projects/github.com/tracee/dist/libbpf/obj \
INCLUDEDIR= LIBDIR= UAPIDIR= prefix= libdir= \
install install_uapi_headers
</code></pre>
<h3 id="启动流程"><a class="header" href="#启动流程">启动流程</a></h3>
<h3 id="追踪流程"><a class="header" href="#追踪流程">追踪流程</a></h3>
<h3 id="实现新的追踪"><a class="header" href="#实现新的追踪">实现新的追踪</a></h3>
<p>tracee 实现了 vfs_write 追踪但并没有实现 vfs_read 追踪，这里参考 vfs_write 追踪<strong>实现 vfs_read 追踪</strong>。得益于 tracee 的代码可扩展性，只需要如下两步：</p>
<ol>
<li>在 go 代码中添加 vfs_read 事件定义</li>
</ol>
<pre><code class="language-go">// pkg/events/events.go

const (
	VfsRead  // 添加 vfs_read 事件ID
    VfsWrite
)

var Definitions = eventDefinitions{
	events: map[ID]Event{
        // 参考 VfsWrite 定义实现 VfsRead 定义
        VfsRead: {
			ID32Bit: sys32undefined,
			Name:    &quot;vfs_read&quot;,
			Probes: []probeDependency{
				{Handle: probes.VfsRead, Required: true},
				{Handle: probes.VfsReadRet, Required: true},
			},
			Sets: []string{},
			Params: []trace.ArgMeta{
				{Type: &quot;const char*&quot;, Name: &quot;pathname&quot;},
				{Type: &quot;dev_t&quot;, Name: &quot;dev&quot;},
				{Type: &quot;unsigned long&quot;, Name: &quot;inode&quot;},
				{Type: &quot;size_t&quot;, Name: &quot;count&quot;},
				{Type: &quot;off_t&quot;, Name: &quot;pos&quot;},
				{Type: &quot;unsigned int&quot;, Name: &quot;flags&quot;}, // 顺手添加一个 flags
			},
		},
        VfsWrite: { /*...*/ },
    }
}
</code></pre>
<pre><code class="language-go">// pkg/ebpf/probes/probes.go

const (
	VfsRead    // 添加入参处理标识
    VfsReadRet // 添加出参处理标识
	VfsWrite
	VfsWriteRet
)

// Init initializes a Probes interface
func Init(module *bpf.Module, netEnabled bool) (Probes, error) {
	allProbes := map[Handle]Probe{
		VfsRead:                   &amp;traceProbe{eventName: &quot;vfs_read&quot;, probeType: kprobe, programName: &quot;trace_vfs_read&quot;},        // 注册入参探针
		VfsReadRet:                &amp;traceProbe{eventName: &quot;vfs_read&quot;, probeType: kretprobe, programName: &quot;trace_ret_vfs_read&quot;}, // 注册出参探针
		VfsWrite:                   &amp;traceProbe{eventName: &quot;vfs_write&quot;, probeType: kprobe, programName: &quot;trace_vfs_write&quot;},
		VfsWriteRet:                &amp;traceProbe{eventName: &quot;vfs_write&quot;, probeType: kretprobe, programName: &quot;trace_ret_vfs_write&quot;},
    }
}
</code></pre>
<ol start="2">
<li>编写 bpf 代码</li>
</ol>
<pre><code class="language-c">// pkg/ebpf/c/tracee.bpf.c

enum tail_call_id_e // 原有内容
{
    TAIL_VFS_READ,
    TAIL_VFS_WRITE, // 原有内容
}

enum event_id_e // 原有内容
{
    VFS_READ,
    VFS_WRITE, // 原有内容
}

// 参考方法 get_inode_nr_from_file，通过宏 READ_KERN 获取，否则将报错寄存器内存未初始化
static __always_inline unsigned int get_flags_from_file(struct file *file)
{
    return READ_KERN(file-&gt;f_flags);
}

static __always_inline int
do_file_read_operation(struct pt_regs *ctx, u32 event_id, u32 tail_call_id)
{
    args_t saved_args;
    if (load_args(&amp;saved_args, event_id) != 0) {
        // missed entry or not traced
        return 0;
    }

    int zero = 0;
    config_entry_t *config = bpf_map_lookup_elem(&amp;config_map, &amp;zero);
    if (config == NULL)
        return 0;

    if (!should_submit(VFS_READ, config)) {
        bpf_tail_call(ctx, &amp;prog_array, tail_call_id);
        return 0;
    }

    loff_t start_pos;
    void *ptr;
    struct iovec *vec;
    size_t count;

    struct file *file = (struct file *) saved_args.args[0];
    void *file_path = get_path_str(GET_FIELD_ADDR(file-&gt;f_path));
    unsigned int flags = get_flags_from_file(file); // 顺手加个 flags

    ptr = (void *) saved_args.args[1];
    count = (size_t) saved_args.args[2];
    loff_t *pos = (loff_t *) saved_args.args[3];

    // Extract device id, inode number, and pos (offset)
    dev_t s_dev = get_dev_from_file(file);
    unsigned long inode_nr = get_inode_nr_from_file(file);
    bpf_probe_read(&amp;start_pos, sizeof(off_t), pos);

    bool char_dev = (start_pos == 0);
    u32 bytes_read = PT_REGS_RC(ctx);

    // Calculate read start offset
    if (start_pos != 0)
        start_pos -= bytes_read;

    event_data_t data = {};
    if (!init_event_data(&amp;data, ctx))
        return 0;

    if (should_submit(VFS_READ, data.config)) {
        save_str_to_buf(&amp;data, file_path, 0);
        save_to_submit_buf(&amp;data, &amp;s_dev, sizeof(dev_t), 1);
        save_to_submit_buf(&amp;data, &amp;inode_nr, sizeof(unsigned long), 2);
        save_to_submit_buf(&amp;data, &amp;count, sizeof(size_t), 3);
        save_to_submit_buf(&amp;data, &amp;start_pos, sizeof(off_t), 4);
        save_to_submit_buf(&amp;data, &amp;flags, sizeof(int), 5); // flags

        // Submit vfs_read(v) event
        events_perf_submit(&amp;data, event_id, PT_REGS_RC(ctx));
    }

    bpf_tail_call(ctx, &amp;prog_array, tail_call_id);
    return 0;
}

SEC(&quot;kprobe/vfs_read&quot;)
TRACE_ENT_FUNC(vfs_read, VFS_READ);

SEC(&quot;kretprobe/vfs_read&quot;)
int BPF_KPROBE(trace_ret_vfs_read)
{
    return do_file_read_operation(ctx, VFS_READ, TAIL_VFS_READ);
}
</code></pre>
<p>重新编译并执行</p>
<pre><code class="language-shell">$ make
make ./dist/tracee.bpf
clang \
	-D__TARGET_ARCH_x86 \
	-D__BPF_TRACING__ \
	-DCORE \
	-I./pkg/ebpf/c/ \
	-I./dist/tracee.bpf \
	-target bpf \
	-O2 -g \
	-march=bpf -mcpu=v2 \
	-c ./pkg/ebpf/c/tracee.bpf.c \
	-o dist/tracee.bpf.core.o
make ./dist/btfhub
make btfhub
GOOS=linux CC=clang GOARCH=amd64 CGO_CFLAGS=&quot;-I/root/projects/github.com/tracee/dist/libbpf&quot; CGO_LDFLAGS=&quot;-lelf  -lz  /root/projects/github.com/tracee/dist/libbpf/libbpf.a&quot; go build \
	-tags core,ebpf \
	-ldflags=&quot;-w \
		-extldflags \&quot;\&quot; \
		-X main.version=\&quot;v0.8.0\&quot; \
		&quot; \
	-v -o dist/tracee-ebpf \
	./cmd/tracee-ebpf
make[1]: “dist/btfhub”已是最新。
make[1]: 对“btfhub”无需做任何事。
github.com/aquasecurity/tracee
github.com/aquasecurity/tracee/pkg/events
github.com/aquasecurity/tracee/pkg/events/derive
github.com/aquasecurity/tracee/pkg/bufferdecoder
github.com/aquasecurity/tracee/pkg/ebpf
github.com/aquasecurity/tracee/cmd/tracee-ebpf/internal/flags
github.com/aquasecurity/tracee/cmd/tracee-ebpf

$ ./dist/tracee-ebpf --trace event=vfs_read
TIME             UID    COMM             PID     TID     RET              EVENT                ARGS
22:14:26:651850  0      kubelet          17433   17433   549              vfs_read             pathname: /etc/selinux/config, dev: 265289728, inode: 51223044, count: 4096, pos: 0, flags: 32768
...
</code></pre>
<h3 id="容器运行"><a class="header" href="#容器运行">容器运行</a></h3>
<p>builder 目录中提供了一些 Makefile &amp; Dockerfile</p>
<h3 id="自定义容器运行"><a class="header" href="#自定义容器运行">自定义容器运行</a></h3>
<p>tracee 提供的 Makefile &amp; Dockerfile 中做了很多事情，包括在容器中下载一些编译执行依赖。但我更想让 tracee-ebpf 可执行文件拷贝到我自己自定义的容器中直接运行</p>
<ol>
<li>编写 makefile.minimal</li>
</ol>
<pre><code class="language-makefile">.PHONY: build-binary build-container run-container clean

build-binary:
	GOOS=linux CC=clang GOARCH=amd64 CGO_CFLAGS=&quot;-I/root/projects/github.com/tracee/dist/libbpf&quot; CGO_LDFLAGS=&quot;-lelf  -lz  /root/projects/github.com/tracee/dist/libbpf/libbpf.a&quot; go build \
    	-tags core,ebpf \
    	-ldflags=&quot;-w \
    		-extldflags \&quot;\&quot; \
    		-X main.version=\&quot;v0.8.0\&quot; \
    		&quot; \
    	-v -o bin/tracee-ebpf \
    	./cmd/tracee-ebpf

build-container: build-binary
	docker build -f Dockerfile.minimal -t tracee-minimal:0.1 .

run-container: build-container
	docker run -it --name tracee-minimal tracee-minimal:0.1

clean:
	docker rm tracee-minimal
	docker rmi tracee-minimal:0.1
</code></pre>
<ol start="2">
<li>编写 dockerfile.minimal</li>
</ol>
<pre><code class="language-dockerfile">FROM alpine:3.15

# 因为 bpf 程序依赖于一些 so 库，所以也需要一一拷贝
COPY /usr/lib64/libelf.so.1 /lib64/libelf.so.1

COPY bin/tracee-ebpf /tracee/tracee-ebpf

ENTRYPOINT [&quot;sh&quot;,&quot;-c&quot;,&quot;/tracee/tracee-ebpf --trace container --trace event=vfs_write --trace event=vfs_read&quot;]
</code></pre>
<p>测试运行</p>
<pre><code class="language-shell">$ make -f Makefile.minimal run-container
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wsl"><a class="header" href="#wsl">WSL</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows"><a class="header" href="#windows">Windows</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>+++</p>
<p>title = &quot;Title.sub_title&quot;
description = &quot;Title sub_title quick_start&quot;
tags = [&quot;techn&quot;, &quot;computer&quot;, &quot;tagx&quot;, &quot;Title&quot;, &quot;_sub_title&quot;, &quot;__quick_start(content)&quot;]</p>
<p>+++</p>
<h1 id="ovs"><a class="header" href="#ovs">OVS</a></h1>
<blockquote>
<p><a href="https://www.openvswitch.org/">官网</a>；<a href="https://docs.openvswitch.org/en/stable/">文档</a>；</p>
</blockquote>
<h3 id="安装-ovs"><a class="header" href="#安装-ovs">安装 ovs</a></h3>
<blockquote>
<p><a href="https://docs.openvswitch.org/en/stable/intro/install/distributions/#debian-ubuntu">Debian / Ubuntu</a>；</p>
</blockquote>
<p>核心用户空间组件软件包：<code>openvswitch-switch</code> &amp; <code>openvswitch-common</code>。</p>
<pre><code class="language-shell">apt install -y openvswitch-switch openvswitch-common

</code></pre>
<p>进入沙箱</p>
<pre><code class="language-shell">git clone https://github.com/openvswitch/ovs.git
git ch v2.17.6
tutorial/ovs-sandbox
</code></pre>
<h3 id="启动-faucet"><a class="header" href="#启动-faucet">启动 faucet</a></h3>
<pre><code class="language-shell">mkdir inst
docker run -d --name faucet --restart=always -v $(pwd)/inst/:/etc/faucet/ -v $(pwd)/inst/:/var/log/faucet/ -p 6653:6653 -p 9302:9302 faucet/faucet
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>+++</p>
<p>title = &quot;虚拟化.虚拟网络&quot;
description = &quot;虚拟化.虚拟设备 quick start&quot;
tags = [&quot;techn&quot;, &quot;computer&quot;, &quot;虚拟化&quot;, &quot;虚拟网络&quot;, &quot;__quick_start&quot;]</p>
<p>+++</p>
<h1 id="虚拟化虚拟网络"><a class="header" href="#虚拟化虚拟网络">虚拟化.虚拟网络</a></h1>
<h2 id="虚拟网络设备"><a class="header" href="#虚拟网络设备">虚拟网络设备</a></h2>
<h3 id="tuntap"><a class="header" href="#tuntap">TUN/TAP</a></h3>
<blockquote>
<p><a href="https://www.zhaohuabing.com/post/2020-02-24-linux-taptun/">Linux Tun/Tap 介绍</a>；</p>
</blockquote>
<p>TUN/TAP 是操作系统内核中<strong>软件实现的虚拟网络设备</strong>，与物理网络设备完全相同的<strong>逻辑</strong>功能。实现上的区别在于：</p>
<ul>
<li>在物理网络设备上<strong>数据以比特流的形式由物理介质承载</strong>，物理网卡从网线接口（或无线信号）接收数据，通过 DMA 拷贝数据到内存，交由内核协议栈处理，发送反之</li>
<li>在虚拟网络设备上<strong>数据以字符的形式由内存承载</strong>，发送数据时，协议栈将数据交给，虚拟网卡从字符设备（文件）接受数据</li>
</ul>
<p>TUN 模拟 L3 网络层设备；TAP 模拟 L2 链路层设备，以太网（Ethernet）网卡。</p>
<p><img src="%E8%AE%A1/%E8%99%9A%E6%8B%9F%E5%8C%96/./img/%E8%99%9A%E6%8B%9F%E5%8C%96.%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C.TUNTAP.drawio.svg" alt="" /></p>
<h3 id="veth-pair"><a class="header" href="#veth-pair">veth pair</a></h3>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/293659939">Linux veth pair 详解</a>；</p>
<p><a href="https://www.cnblogs.com/bakari/p/10613710.html">Linux 虚拟网络设备 veth-pair 详解</a>；</p>
</blockquote>
<p>veth 设备均为成对使用</p>
<p><img src="%E8%AE%A1/%E8%99%9A%E6%8B%9F%E5%8C%96/./img/%E8%99%9A%E6%8B%9F%E5%8C%96.%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C.veth_pair.drawio.svg" alt="" /></p>
<h2 id="隧道网络"><a class="header" href="#隧道网络">隧道网络</a></h2>
<h3 id="vxlan"><a class="header" href="#vxlan">vxlan</a></h3>
<blockquote>
<p><a href="https://community.cisco.com/t5/%E7%BD%91%E7%BB%9C%E5%8D%9A%E5%AE%A2/%E5%81%9A%E4%BA%86%E5%87%A0%E5%B9%B4%E7%9A%84%E7%BD%91%E5%B7%A5%E4%B9%9F%E6%9C%AA%E5%BF%85%E4%BA%86%E8%A7%A3vlan%E5%92%8Cvxlan%E7%9A%84%E5%8C%BA%E5%88%AB-%E4%BB%8A%E5%A4%A9%E6%88%91%E6%9D%A5%E5%91%8A%E8%AF%89%E4%BD%A0/ba-p/4383418">VLAN和VXLAN的区别</a>；</p>
<p><a href="https://cizixs.com/2017/09/28/linux-vxlan/">linux 上实现 vxlan 网络</a>；</p>
</blockquote>
<p>vlan（虚拟局域网）将同一网络划分为多个逻辑上的虚拟子网，在以太网的基础上实现了广播域隔离，解决了广播报文泛滥的问题；</p>
<p>vxlan 将 header 扩展到了 8 字节，支撑如今云服务等大规模场景，解决网络地址重叠问题以满足多租户场景</p>
<h3 id="ipip"><a class="header" href="#ipip">ipip</a></h3>
<h3 id="bgp"><a class="header" href="#bgp">bgp</a></h3>
<h2 id="组网模式"><a class="header" href="#组网模式">组网模式</a></h2>
<div style="break-before: page; page-break-before: always;"></div><p>+++</p>
<p>title = &quot;Docker&quot;
description = &quot;Docker&quot;
tags = [&quot;it&quot;, &quot;container&quot;, &quot;docker&quot;]</p>
<p>+++</p>
<h1 id="docker"><a class="header" href="#docker">Docker</a></h1>
<blockquote>
<p><a href="https://www.docker.com/">官网</a>；<a href="https://docs.docker.com/reference/">文档</a>；<a href="https://docs.docker.com/engine/reference/commandline/docker/">命令</a>；</p>
<p><a href="https://hub.docker.com/">镜像仓库 DockerHub</a>；</p>
</blockquote>
<h2 id="--快开--"><a class="header" href="#--快开--">- 快开 -</a></h2>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<blockquote>
<p><a href="https://docs.docker.com/engine/install/">Install Docker Engine</a>；</p>
</blockquote>
<h3 id="ubuntu-1"><a class="header" href="#ubuntu-1">ubuntu</a></h3>
<blockquote>
<p><a href="https://docs.docker.com/engine/install/ubuntu/">Install Docker Engine on Ubuntu</a>；</p>
</blockquote>
<pre><code class="language-shell"># 勿在没有配置Docker APT源的情况下直接使用apt命令安装Docker
# 先卸载
apt remove -y docker.io docker docker-engine
</code></pre>
<p>ubuntu 后台运行的 openvpn 会<a href="https://askubuntu.com/questions/1302371/docker-ce-post-installation-configuration-failure-on-ubuntu-20-04">影响 docker-ce 安装</a>，产生<code>Errors were encountered while processing</code></p>
<pre><code class="language-shell"># 停止openvpn
service openvpn stop
</code></pre>
<p>安装</p>
<pre><code class="language-shell"># GPG 密钥
curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
# apt 源
echo &quot;deb [arch=&quot;$(dpkg --print-architecture)&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu &quot;$(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;)&quot; stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null

sudo apt update &amp;&amp; apt-cache madison docker-ce &amp;&amp; apt-cache madison containerd.io
sudo apt install -y docker-ce docker-ce-cli containerd.io
</code></pre>
<h3 id="centos-1"><a class="header" href="#centos-1">centos</a></h3>
<blockquote>
<p><a href="https://docs.docker.com/engine/install/rhel/">Install Docker Engine on RHEL</a>；</p>
</blockquote>
<pre><code class="language-sh"># 设置存储库
cat &gt;/etc/yum.repos.d/docker.repo&lt;&lt;EOF
[docker-ce-stable]
name=Docker CE Stable - $basearch
baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/$basearch/stable
enabled=1
gpgcheck=1
gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg
EOF

# 安装 Docker Engine 和 containerd。
# centos8 默认使用 podman 代替 docker，会提示冲突，根据提示使用 --allowerasing 替换冲突的软件包
yum install -y --allowerasing docker-ce docker-ce-cli containerd.io
</code></pre>
<h3 id="开机启动"><a class="header" href="#开机启动">开机启动</a></h3>
<pre><code class="language-shell"># 开机启动并立即启动
systemctl enable --now docker
</code></pre>
<h3 id="配置"><a class="header" href="#配置">配置</a></h3>
<blockquote>
<p>cgroup 驱动：<a href="https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/#docker">systemd</a>；</p>
<p>存储驱动：；</p>
<p>容器镜像仓库：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云</a>；</p>
<p>dockerd 代理；</p>
</blockquote>
<pre><code class="language-shell"># 配置 cgroup 驱动、存储驱动、 通用
cat &gt; /etc/docker/daemon.json &lt;&lt; EOF
{
  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],
  &quot;log-driver&quot;: &quot;json-file&quot;,
  &quot;log-opts&quot;: {
    &quot;max-size&quot;: &quot;100m&quot;
  },
  
  &quot;storage-driver&quot;: &quot;overlay2&quot;,
  
  &quot;registry-mirrors&quot;: [&quot;https://ohm5orzk.mirror.aliyuncs.com&quot;],
  &quot;insecure-registries&quot;: [&quot;192.168.xxx.xxx:5000&quot;,&quot;registry.aliyuncs.com&quot;],
  
  &quot;runtimes&quot;: {
    &quot;nvidia&quot;: {
      &quot;args&quot;: [],
      &quot;path&quot;: &quot;nvidia-container-runtime&quot;
    }
  }
}
EOF

# 配置 dockerd 代理
cat &gt; /etc/systemd/system/docker.service.d/proxy.conf &lt;&lt; EOF
[Service]
Environment=&quot;HTTP_PROXY=http://proxy.example.com:8080/&quot;
Environment=&quot;HTTPS_PROXY=https://proxy.example.com:8080/&quot;
Environment=&quot;NO_PROXY=127.0.0.1,私有仓库ip,example.com&quot;
EOF

# 重启
systemctl daemon-reload &amp;&amp; systemctl restart docker
# 检查
docker info
</code></pre>
<h2 id="--基操--"><a class="header" href="#--基操--">- 基操 -</a></h2>
<h3 id="dockerfile"><a class="header" href="#dockerfile">Dockerfile</a></h3>
<pre><code class="language-dockerfile">ARG BASE_IMAGE
FROM ${BASE_IMAGE}
MAINTAINER yuanya&lt;yuanyatianchi@google.com&gt;

ENV WORK_DIR /tmp
WORKDIR $WORK_DIR

EXPOSE 80

# ARG OUTPUT
# RUN mkdir ${OUTPUT}
# COPY ${OUTPUT}/main ${OUTPUT}/main

RUN 

ENTRYPOINT [&quot;bash&quot;]
</code></pre>
<h3 id="makefile-1"><a class="header" href="#makefile-1">Makefile</a></h3>
<pre><code class="language-makefile">NAME = aquickstart

# image
IMAGE_REPOSITORY=
IMAGE_VERSION = &quot;v0.0.1&quot;
IMAGE_NAME = $(IMAGE_REPOSITORY)$(NAME):$(IMAGE_VERSION)
ARG_BASE_IMAGE = &quot;ubuntu:2204&quot;

.PHONY: image
image: $(IMAGE_NAME)
$(IMAGE_NAME): Dockerfile
	docker build -t $(IMAGE_NAME) \
		--network host \
		--build-arg BASE_IMAGE=$(ARG_BASE_IMAGE) \
		.

.PHONY: image_tar
image_tar: | $(IMAGE_NAME)
	docker save -t $(IMAGE_NAME)-$(IMAGE_VERSION).tar

.PHONY: image_clean
image_clean:
$(IMAGE_NAME)_clean: | $(IMAGE_NAME)
	docker rmi $(IMAGE_NAME)

.PHONY: image_clean_none
image_clean_none:
	docker images | grep none | awk '{print $3}' | xargs docker rmi

# container
CONTAINER_NAME = $(NAME)
.PHONY: container_run
container_run: $(CONTAINER_NAME)_run
$(CONTAINER_NAME)_run: | $(IMAGE_NAME)
	docker run -d \
		--network=host \
		--restart=always \
		--name $(CONTAINER_NAME) \
		$(IMAGE_NAME)

CONTAINER_NAME = $(NAME)
.PHONY: container_update
container_update: $(CONTAINER_NAME)_update
$(CONTAINER_NAME)_update: | $(IMAGE_NAME)
	docker update \
		--network=host \
		--restart=always \
		--name $(CONTAINER_NAME)

# clean
.PHONY: clean
clean: | image_clean 
	docker images | grep none | awk '{print $3}' | xargs docker rmi
</code></pre>
<h2 id="批删"><a class="header" href="#批删">批删</a></h2>
<pre><code class="language-shell">docker images | grep none | awk '{print $3}' | xargs docker rmi
</code></pre>
<h2 id="镜像"><a class="header" href="#镜像">镜像</a></h2>
<h3 id="镜像仓库"><a class="header" href="#镜像仓库">镜像仓库</a></h3>
<h4 id="http"><a class="header" href="#http">http</a></h4>
<p>docker-registry 安装：使用官方 <code>registry</code> 镜像来安装执行。注意，此时启用的 registry 是一个 http server</p>
<pre><code class="language-shell"># 仓库默认被创建在容器的 /var/lib/registry 目录下，通过 -v 挂载主机目录，以将镜像文件持久存储到主机
docker run -d --restart=always --name registry -p 5000:5000 \
-v /var/lib/docker/registry:/var/lib/registry registry
</code></pre>
<p>在 Docker client 上，默认接收 https 响应，因此还 push 不了镜像，将出现错误 <code>http: server gave HTTP response to HTTPS client</code>，可以通过在 docker <strong>client 所在主机</strong>的 <code>/etc/docker/daemon.json</code> 中配置取消这个限制，<code>192.168.31.11:5000</code> 为 <strong>registry server</strong> 地址</p>
<pre><code class="language-json">{
  &quot;insecure-registries&quot;: [&quot;192.168.xxx.xxx:5000&quot;,&quot;registry.aliyuncs.com&quot;]
}
</code></pre>
<p>但kubelet通过cri调用时默认使用https，因此https更佳</p>
<h4 id="httpsca"><a class="header" href="#httpsca">https(ca)</a></h4>
<p>在 registry server 主机上创建证书，指定 server <a href="%E8%AE%A1/%E4%BA%91%E5%8E%9F%E7%94%9F/../it.crypto.tool.html#%E7%AD%BE%E5%8F%91%E9%85%8D%E7%BD%AE">配置</a>。</p>
<pre><code class="language-shell"># 证书签名请求
$ cat &gt; docker-csr.json &lt;&lt;EOF
{
    &quot;CN&quot;: &quot;docker&quot;,
    &quot;hosts&quot;: [
      &quot;127.0.0.1&quot;,
      &quot;192.168.31.11&quot;
    ],
    &quot;key&quot;: {
        &quot;algo&quot;: &quot;rsa&quot;,
        &quot;size&quot;: 2048
    },
    &quot;names&quot;: [
        {
            &quot;C&quot;: &quot;CN&quot;,
            &quot;ST&quot;: &quot;BeiJing&quot;,
            &quot;L&quot;: &quot;BeiJing&quot;,
            &quot;O&quot;: &quot;docker&quot;,
            &quot;OU&quot;: &quot;docker&quot;
        }
    ]
}
EOF

# 签发证书
$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=server docker-csr.json | cfssljson -bare docker
</code></pre>
<p>启动 https 的 registry server</p>
<pre><code class="language-shell"># -v 挂载证书所在目录，通过环境变量指定证书和key
docker run -d --restart=always --name registry -p 5000:5000 \
-v /var/lib/docker/registry:/var/lib/registry \
-v /etc/docker/ssl:/etc/docker/ssl \
-e REGISTRY_HTTP_ADDR=0.0.0.0:5000 \
-e REGISTRY_HTTP_TLS_CERTIFICATE=/etc/docker/ssl/docker.pem \
-e REGISTRY_HTTP_TLS_KEY=/etc/docker/ssl/docker-key.pem \
registry
</code></pre>
<p>此时 docker client 仍然无法访问私有仓库，将报错<code>Get &quot;https://192.168.31.11:5000/v2/&quot;: x509: certificate signed by unknown authority</code>，是私有仓库使用 server 证书是我们自己生成的 ca 证书签名的自签名证书，client 主机无法对其 CA 进行验证，需要下载 ca 证书到 <code>/etc/docker/certs.d/&lt;地址&gt;:&lt;端口&gt;</code>或<code>/etc/docker/certs.d/&lt;域名&gt;</code>目录下</p>
<pre><code class="language-shell"># client 端下载 ca 证书
scp -r root@192.168.31.11:/root/ssl/ca.pem /etc/docker/certs.d/192.168.31.11:5000/ca.crt
docker push 192.168.31.11:5000/guestbook:1.0
</code></pre>
<h4 id="httpspw"><a class="header" href="#httpspw">https(pw)</a></h4>
<pre><code class="language-shell">mkdir /etc/docker/auth
# 生成密码认证
htpasswd -Bbn admin admin &gt; /etc/docker/auth/htpasswd
# run时指定
docker run -d --restart=always --name registry -p 5000:5000 \
-v /var/lib/docker/registry:/var/lib/registry \
-v /etc/docker/auth:/etc/docker/auth \
-e REGISTRY_AUTH=htpasswd \
-e REGISTRY_AUTH_HTPASSWD_PATH=/etc/docker/auth/htpasswd \
-e REGISTRY_AUTH_HTPASSWD_REALM=&quot;Registry Realm&quot; \
registry

# 登录
docker login 192.168.31.11:5000
</code></pre>
<h3 id="镜像管理"><a class="header" href="#镜像管理">镜像管理</a></h3>
<h6 id="镜像搜索"><a class="header" href="#镜像搜索">镜像搜索</a></h6>
<h6 id="镜像拉取"><a class="header" href="#镜像拉取">镜像拉取</a></h6>
<h6 id="镜像导出"><a class="header" href="#镜像导出">镜像导出</a></h6>
<pre><code class="language-shell"># 一般导出命名后缀为.tar
docker save arm64v8/centos:latest -o ./centos.arm64.tar
</code></pre>
<h6 id="镜像导入"><a class="header" href="#镜像导入">镜像导入</a></h6>
<pre><code class="language-shell">docker load &lt; centos.arm64.tar
</code></pre>
<h6 id="镜像构建"><a class="header" href="#镜像构建">镜像构建</a></h6>
<p>https://www.runoob.com/docker/docker-build-command.html</p>
<pre><code class="language-shell"># 默认使用当前目录下的 Dockerfile 构建镜像
$ docker build -t yuanya:1.0 .
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>option</th><th>description</th></tr></thead><tbody>
<tr><td>-f</td><td>指定要使用的Dockerfile</td></tr>
<tr><td>-t;-tag</td><td>镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</td></tr>
</tbody></table>
</div>
<h6 id="提交容器为镜像"><a class="header" href="#提交容器为镜像">提交容器为镜像</a></h6>
<pre><code class="language-shell">docker commit 261314c94305 imagexxx
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>option</th><th>description</th></tr></thead><tbody>
<tr><td>-a</td><td>提交的镜像作者</td></tr>
<tr><td>-c</td><td>使用Dockerfile指令来创建镜像；</td></tr>
<tr><td>-m</td><td>提交时的说明文字；</td></tr>
<tr><td>-p</td><td>在commit时，将容器暂停。</td></tr>
</tbody></table>
</div>
<h3 id="跨平台构建"><a class="header" href="#跨平台构建">跨平台构建</a></h3>
<p>qemu-user-static：https://github.com/multiarch/qemu-user-static</p>
<p>https://juejin.cn/post/6844903605355577358</p>
<p>https://zhuanlan.zhihu.com/p/106054643</p>
<p>在x86机器上模拟arm架构指令来构建arm架构的镜像，使用 <a href="https://github.com/multiarch/qemu-user-static">multiarch/qemu-user-static</a> 来实现在x86主机上模拟arm环境</p>
<p><strong>multiarch/qemu-user-static</strong> 是通过 QEMU 和 binfmt_misc 启用不同多架构容器的执行。以下是 Docker 的示例。</p>
<p>通过 qemu-user-static （该程序使用内核 binfmt_misc 文件系统功能）可以模拟各种环境</p>
<pre><code class="language-shell"># 我的环境是 centos8
$ uname -mrs
Linux 4.18.0-305.7.1.el8_4.x86_64 x86_64

# 拉取一个 arm 的 centos 镜像
$ docker pull arm64v8/centos

# 在 x86 上执行一个 arm centos 镜像时，会因无法解析 arm 指令而报错
$ docker run --rm -t arm64v8/centos uname -m
standard_init_linux.go:211: exec user process caused &quot;exec format error&quot;

# 此时执行 qemu-user-static 镜像，将为我们设置模拟 arm 环境
$ docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
Setting /usr/bin/qemu-alpha-static as binfmt interpreter for alpha
Setting /usr/bin/qemu-arm-static as binfmt interpreter for arm
Setting /usr/bin/qemu-armeb-static as binfmt interpreter for armeb
Setting /usr/bin/qemu-sparc-static as binfmt interpreter for sparc
Setting /usr/bin/qemu-sparc32plus-static as binfmt interpreter for sparc32plus
Setting /usr/bin/qemu-sparc64-static as binfmt interpreter for sparc64
Setting /usr/bin/qemu-ppc-static as binfmt interpreter for ppc
Setting /usr/bin/qemu-ppc64-static as binfmt interpreter for ppc64
Setting /usr/bin/qemu-ppc64le-static as binfmt interpreter for ppc64le
Setting /usr/bin/qemu-m68k-static as binfmt interpreter for m68k
Setting /usr/bin/qemu-mips-static as binfmt interpreter for mips
Setting /usr/bin/qemu-mipsel-static as binfmt interpreter for mipsel
Setting /usr/bin/qemu-mipsn32-static as binfmt interpreter for mipsn32
Setting /usr/bin/qemu-mipsn32el-static as binfmt interpreter for mipsn32el
Setting /usr/bin/qemu-mips64-static as binfmt interpreter for mips64
Setting /usr/bin/qemu-mips64el-static as binfmt interpreter for mips64el
Setting /usr/bin/qemu-sh4-static as binfmt interpreter for sh4
Setting /usr/bin/qemu-sh4eb-static as binfmt interpreter for sh4eb
Setting /usr/bin/qemu-s390x-static as binfmt interpreter for s390x
Setting /usr/bin/qemu-aarch64-static as binfmt interpreter for aarch64
Setting /usr/bin/qemu-aarch64_be-static as binfmt interpreter for aarch64_be
Setting /usr/bin/qemu-hppa-static as binfmt interpreter for hppa
Setting /usr/bin/qemu-riscv32-static as binfmt interpreter for riscv32
Setting /usr/bin/qemu-riscv64-static as binfmt interpreter for riscv64
Setting /usr/bin/qemu-xtensa-static as binfmt interpreter for xtensa
Setting /usr/bin/qemu-xtensaeb-static as binfmt interpreter for xtensaeb
Setting /usr/bin/qemu-microblaze-static as binfmt interpreter for microblaze
Setting /usr/bin/qemu-microblazeel-static as binfmt interpreter for microblazeel
Setting /usr/bin/qemu-or1k-static as binfmt interpreter for or1k

# centos7会出现报错 sh: write error: Invalid argument，因为使用 -p yes 选项至少需要内核版本 4.10 上的 binfmt_misc，https://github.com/multiarch/qemu-user-static/issues/100。可以去掉 -p yes 选项，之后还有一堆其它问题，直接放弃，换 centos8 了
$ docker run --rm --privileged multiarch/qemu-user-static --reset

# 之后就可以执行这个 arm centos 镜像了，因为 qemu-user-static将arm架构的指令解释成x86架构的指令执行
$ docker run --rm -t arm64v8/centos uname -m
aarch64

# 这里将 hello.arm 所在目录挂载进来执行
docker run --rm -t -v /it/go/gopath/src/yuanyatianchi.io/hello/bin:/usr/bin/qemu-aarch64-static arm64v8/centos ls /go/bin
</code></pre>
<p>现在 arm64v8/centos 已经可以 run 了，将其作为基础镜像编写 Dockerfile ，build 后 run 起来即可，这里用一个 hello 代码</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	fmt.Println(&quot;hello&quot;)
}
</code></pre>
<pre><code class="language-dockerfile">FROM arm64v8/centos

COPY ./bin/hello /usr/bin
</code></pre>
<pre><code class="language-makefile">.PHONY: build-hello build-image export-image clean

# 构建程序
build-hello: ./cmd/hello.go
	CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -o ./bin/hello ./cmd/hello.go

# 构建镜像
build-image: build-hello
	docker build . -t hello:v1.0

# 导出镜像
export-image: build-image
	docker save hello:v1.0 -o ./bin/hello.tar

clean:
	rm -rf ./bin
</code></pre>
<pre><code class="language-shell"># 构建并导出镜像
$ make export-image
CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -o ./bin/hello ./cmd/hello.go
docker build . -t hello:v1.0
Sending build context to Docker daemon  7.443MB
Step 1/2 : FROM arm64v8/centos
 ---&gt; a0477e85b8ae
Step 2/2 : COPY ./bin/hello /usr/bin
 ---&gt; 8a0e7d42e2f7
Successfully built 8a0e7d42e2f7
Successfully tagged hello:v1.0
docker save hello:v1.0 -o ./bin/hello.tar

# 可以看到镜像包
$ ls ./bin/
hello  hello.tar

# 验证一下执行 hello
$ docker run --rm -t hello:v1.0 hello
hello
</code></pre>
<h2 id="容器"><a class="header" href="#容器">容器</a></h2>
<p>加载镜像运行容器</p>
<pre><code class="language-shell">docker run -it --name 容器名称 镜像名称 /bin.bash
</code></pre>
<p>启动</p>
<p>停止</p>
<h2 id="网络"><a class="header" href="#网络">网络</a></h2>
<h3 id="代理"><a class="header" href="#代理">代理</a></h3>
<p>https://note.qidong.name/2020/05/docker-proxy/</p>
<p>有时因为网络原因，比如公司NAT，或其它啥的，需要使用代理。 Docker的代理配置，略显复杂，因为有三种场景。 但基本原理都是一致的，都是利用Linux的<code>http_proxy</code>等环境变量。</p>
<h4 id="dockerd"><a class="header" href="#dockerd">dockerd</a></h4>
<p>https://docs.docker.com/config/daemon/systemd/</p>
<p>执行<code>docker pull</code>时，是由守护进程<code>dockerd</code>来执行。 因此，代理需要配在<code>dockerd</code>的环境中。 而这个环境，则是受<code>systemd</code>所管控，因此实际是<code>systemd</code>的配置。</p>
<pre><code class="language-shell">sudo mkdir -p /etc/systemd/system/docker.service.d
sudo touch /etc/systemd/system/docker.service.d/proxy.conf
</code></pre>
<p><code>proxy.conf</code>文件（可以是任意<code>*.conf</code>的形式）内容如下</p>
<pre><code class="language-ini">[Service]
Environment=&quot;HTTP_PROXY=http://proxy.example.com:8080/&quot;
Environment=&quot;HTTPS_PROXY=https://proxy.example.com:8080/&quot;
Environment=&quot;NO_PROXY=127.0.0.1,私有仓库ip,example.com&quot;
</code></pre>
<p>其中，<code>proxy.example.com:8080</code>要换成可用的免密代理。 通常使用<code>cntlm</code>在本机自建免密代理，去对接公司的代理。 可参考《<a href="https://note.qidong.name/2018/11/cntlm-proxy/">Linux下安装配置Cntlm代理</a>》。</p>
<p>重启。<code>dockerd</code>代理的修改比较特殊，它实际上是改<code>systemd</code>的配置，因此需要重载<code>systemd</code>并重启<code>dockerd</code>才能生效。</p>
<pre><code class="language-shell">sudo systemctl daemon-reload
sudo systemctl restart docker
</code></pre>
<h4 id="container"><a class="header" href="#container">container</a></h4>
<p>https://docs.docker.com/network/proxy/</p>
<p>在容器运行阶段，如果需要代理上网，则需要配置<code>~/.docker/config.json</code>。 以下配置，只在Docker 17.07及以上版本生效。</p>
<pre><code class="language-json">{
  &quot;proxies&quot;:
  {
    &quot;default&quot;:
    {
      &quot;httpProxy&quot;: &quot;http://proxy.example.com:8080&quot;,
      &quot;httpsProxy&quot;: &quot;http://proxy.example.com:8080&quot;,
      &quot;noProxy&quot;: &quot;localhost,127.0.0.1,.example.com&quot;
    }
  }
}
</code></pre>
<p>这个是用户级的配置，除了<code>proxies</code>，<code>docker login</code>等相关信息也会在其中。 而且还可以配置信息展示的格式、插件参数等。</p>
<p>此外，容器的网络代理，也可以直接在其运行时通过<code>-e</code>注入<code>http_proxy</code>等环境变量。 这两种方法分别适合不同场景。 <code>config.json</code>非常方便，默认在所有配置修改后启动的容器生效，适合个人开发环境。 在CI/CD的自动构建环境、或者实际上线运行的环境中，这种方法就不太合适，用<code>-e</code>注入这种显式配置会更好，减轻对构建、部署环境的依赖。 当然，在这些环境中，最好用良好的设计避免配置代理上网。</p>
<h4 id="docker-build"><a class="header" href="#docker-build">docker build</a></h4>
<p>https://docs.docker.com/engine/reference/commandline/cli/#automatic-proxy-configuration-for-containers</p>
<p>虽然<code>docker build</code>的本质，也是启动一个容器，但是环境会略有不同，用户级配置无效。 在构建时，需要注入<code>http_proxy</code>等参数。</p>
<pre><code class="language-sh">docker build . \
    --build-arg &quot;HTTP_PROXY=http://proxy.example.com:8080/&quot; \
    --build-arg &quot;HTTPS_PROXY=http://proxy.example.com:8080/&quot; \
    --build-arg &quot;NO_PROXY=localhost,127.0.0.1,.example.com&quot; \
    -t your/image:tag
</code></pre>
<p><strong>注意</strong>：无论是<code>docker run</code>还是<code>docker build</code>，默认是网络隔绝的。 如果代理使用的是<code>localhost:3128</code>这类，则会无效。 这类仅限本地的代理，必须加上<code>--network host</code>才能正常使用。 而一般则需要配置代理的外部IP，而且代理本身要开启gateway模式。</p>
<h3 id="修改docker0默认网段"><a class="header" href="#修改docker0默认网段">修改Docker0默认网段</a></h3>
<p>https://blog.51cto.com/lisea/1940023</p>
<p>Docker 服务启动后默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信，它还给出了 MTU（接口允许接收的最大传输单元），通常是 1500 Bytes，或宿主主机网络路由上支持的默认值。这些值都可以在服务启动的时候进行配置。</p>
<pre><code class="language-shell"># 查看
$ ifconfig docker0
docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500
        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:61:ff:7b:91  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</code></pre>
<p>修改文件 <code>/etc/docker/daemon.json</code> 添加内容 <code>&quot;bip&quot;: &quot;ip/netmask&quot;</code> 即可。注意切勿与宿主机同网段</p>
<pre><code class="language-json">{
  &quot;bip&quot;: &quot;192.168.100.1/24&quot;
}
</code></pre>
<pre><code class="language-shell"># 重启即可
$ systemctl restart docker
</code></pre>
<h2 id="client"><a class="header" href="#client">client</a></h2>
<p>命令：</p>
<h3 id="镜像-1"><a class="header" href="#镜像-1">镜像</a></h3>
<p>docker中一个centos镜像大小200m不到，docker相当于隔离了进程，</p>
<pre><code class="language-shell">$ docker images #本地镜像列表
$ docker search &lt;关键字&gt; #检索镜像
$ docker pull &lt;镜像名&gt;[:&lt;tag&gt;] #拉取镜像。tag指定版本，缺省则为latest
$ docker inspect &lt;镜像名&gt;#查看镜像详细信息
$ docker rmi &lt;镜像id&gt; #删除指定镜像

docker network ps
docker network rm &lt;网络名&gt; #注意几个默认的不要删除
</code></pre>
<h3 id="容器-1"><a class="header" href="#容器-1">容器</a></h3>
<ul>
<li>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</li>
<li>UnionFS (联合文件系统) : Union文件系统(UnionFS) 是一种分层、 轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种具体的应用镜像。
<ul>
<li>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</li>
</ul>
</li>
<li>Docker镜像加载原理：docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS.
<ul>
<li>bootfs(boot file system)主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权己由bootfs转交给内核，此时系统也会卸载bootfs。</li>
<li>rootfs (root file system)，在bootfs之 上。 包含的就是典型Linux系统中的/dev, /proc, /bin, /etc等标准目录和文件。rootfs 就是各种不同的操作系统发行版，比如Ubuntu，Centos等 等。</li>
<li>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了,因为底层直接用Host的kernel,自己只需要提供rootfs就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别,因此不同的发行版可以公用bootfs。</li>
</ul>
</li>
<li>分层的镜像：以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载很多镜像</li>
<li>最大的一个好处就是：共享资源
<ul>
<li>比如:有多个镜像都从相同的base镜像构建而来，那么宿主机只需在磁盘上保存一-份base镜像，同时内存中也只需加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</li>
</ul>
</li>
<li>Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容 器层”之下的都叫&quot;镜像层</li>
</ul>
<pre><code class="language-shell">$ docker ps #容器列表。-a表示所有包括未运行的容器
$ docker logs &lt;container-name | container-id&gt; #查看指定容器日志
$ docker run [--name &lt;container-name&gt;] [-d|-it] [-p &lt;container-port&gt;:&lt;port&gt;] [-e &lt;key&gt;:&lt;value&gt;] &lt;image-id&gt;  #运行指定容器。--name为容器取名；-d守护式运行（即后台运行），-it交互式运行（即进入容器交互）；-p指定将容器内的端口映射到实体机的端口；-e配置环境参数
$ docker start &lt;container-name | container-id&gt; #启动
$ docker restart &lt;container-name | container-id&gt; #重启
$ docker stop &lt;container-name | container-id&gt; #停止
$ docker stop &lt;container-name | container-id&gt; #强制停止
$ docker rm &lt;container-id&gt; #删除指定容器
$ docker rm -f $(docker ps -a -q) #条件批量删除
$ docker ps-a-q | xargs docker rm #条件批量删除

$ docker top &lt;container-id&gt;
$ docker commit &lt;container-id&gt; &lt;要创建的目标镜像名:[标签名]&gt;  -a=&quot;&lt;作者&gt;&quot; -m=&quot;&lt;提交的描述信息&gt;&quot;
 #提交容器副本使之成为一个新的镜像，可以docker ps -a看到
</code></pre>
<p>停止并删除所有容器</p>
<pre><code class="language-sh">docker stop $(docker ps -q)
docker rm $(docker ps -aq)
</code></pre>
<p>执行容器</p>
<pre><code class="language-shell">$ docker exec -it &lt;container-id&gt; &lt;bashshell&gt; #执行伪终端。-it表示-i -t，将为容器分配伪终端，可以进行交互
$ docker exec -it &lt;container-id&gt; /bin/bash
$ docker exec -it &lt;container-id&gt; bash
$ docker exec -it &lt;container-id&gt; ls /
$ docker attach &lt;container-id&gt; #重新进入
$ exit #退出容器交互并停止容器
ctrl+q+p #退出容器交互但容器不停止

$ docker cp &lt;container-id&gt;:/xxx/xxx.log /app/temp #拷贝容器中的文件到本地宿主主机
</code></pre>
<pre><code class="language-cmd">docker exec -it mysql8 bash #进入容器名为mysql8的容器
mysql -uroot -p123456 #进入mysql8后，可以使用mysql命令行，登录mysql

grant all privileges on *.* to 'root'@'%'; #添加权限，%表示所有ip可以登入，%可以替换为具体ip以给某ip开放root登入权限

#也可以这样到表中修改权限
use mysql; #进到mysql库
select host, user, plugin from user; #查看user表，可以看到root的host是localhost，只允许本地登入
update user set host='%' where user='root' #修改权限，%表示所有ip可以登入，%可以替换为具体ip以给某ip开放root登入权限

flush privileges; #重新加载权限
</code></pre>
<h2 id="容器数据卷"><a class="header" href="#容器数据卷">容器数据卷</a></h2>
<ul>
<li>持久化
<ul>
<li>将运用与运行的环境打包形成容器运行，运行可以伴随着容器，但是我们对数据的要求希望是持久化的</li>
<li>容器之间希望有可能共享数据</li>
<li>Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一 部分保存下来，那么当容器删除后，数据自然也就没有了。</li>
<li>为了能保存数据在docker中我们使用卷。</li>
</ul>
</li>
<li>卷就是目录或文件，存在于-一个或多个容器中，由docker挂 载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性:卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷
<ul>
<li>1:数据卷可在容器之间共享或重用数据</li>
<li>2: 卷中的更改可以直接生效</li>
<li>3:数据卷中的更改不会包含在镜像的更新中</li>
<li>4:数据卷的生命周期一直持续到没有容器使用它为止</li>
</ul>
</li>
</ul>
<h3 id="容器卷添加"><a class="header" href="#容器卷添加">容器卷添加</a></h3>
<h6 id="直接命令添加"><a class="header" href="#直接命令添加">直接命令添加</a></h6>
<pre><code class="language-shell">$ docker run &lt;指定镜像&gt; -it -v &lt;/宿主机绝对路径目录&gt;:&lt;/容器内目录&gt;  #-v指定host与container的数据同步目录，如果目录不存在则将创建目录，数据将实现实时同步，两边都可读写。-v参数可以多使用，形成一一对应的多对同步目录
$ docker run &lt;指定镜像&gt; -it -v &lt;/宿主机绝对路径目录&gt;:&lt;/容器内目录:ro&gt; #限制容器目录只读
</code></pre>
<h6 id="dockerfile添加"><a class="header" href="#dockerfile添加">DockerFile添加</a></h6>
<ul>
<li>新建/mydocker文件夹并进入</li>
<li>在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷
<ul>
<li>VOLUME[&quot;/dataVolumeContainer&quot;,&quot;/dataVolumeContainer2&quot;, &quot;/dataVolumeContainer3&quot;]</li>
<li>出于可移植和分享的考虑，用-v主机目录:容器目录这种方法不能够直接在Dockerfile中实现。由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。但是会有默认的目录，通过<code>docker inspect</code>即可查看到</li>
</ul>
</li>
</ul>
<pre><code class="language-dockerfile">#dockerfile，按序执行的脚本，每个FROM的镜像都会作为一层环境被装载
FROM centos
VOLUME [&quot; /dataVolumeContainerA&quot; ,&quot; /dataVolumeContainerB&quot; ]
CMD echo &quot;finished, -------- success1&quot;
CMD /bin/bash
</code></pre>
<ul>
<li>
<p>docker build生成镜像</p>
<pre><code class="language-shell">$ docker build -f /mydocker/dockerfile -t yuanya/centos . #-f指定要构建的dockerfile；-t为生成的镜像取名
$ docker run yuanya/centos -d #如果后面出现容器数据卷只能读的情况，就加上--privileged=true赋予容器扩展的特权
$ docker inspect yuanya/centos
</code></pre>
</li>
</ul>
<h6 id="数据卷容器"><a class="header" href="#数据卷容器">数据卷容器</a></h6>
<ul>
<li>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器</li>
<li>即容器间传递共享(--volumes-from)</li>
</ul>
<pre><code class="language-shell">$ docker run yuanya/centos -it --name dc01 #启动一个01
$ docker run yuanya/centos -it --name dc02 --volumes-from dc01 #将使dc02与dc01共享VOLUME配置的数据卷
$ docker run yuanya/centos -it --name dc03 --volumes-from dc01 #将使dc03与dc01共享VOLUME配置的数据卷
#即完成dc01、dc02、dc03之间相互共享VOLUME配置的数据卷
</code></pre>
<h2 id="dockerfile-1"><a class="header" href="#dockerfile-1">DockerFile</a></h2>
<ul>
<li>Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本</li>
</ul>
<pre><code class="language-dockerfile">#相当于docker run 时加 bash
CMD /bin/bash
CMD [&quot;/bin/bash&quot;]
</code></pre>
<p>dockerfile解析过程</p>
<ul>
<li>Dockerfile内容基础知识
<ul>
<li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li>
<li>指令按照从上到下，顺序执行</li>
<li>#表示注释</li>
<li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li>
</ul>
</li>
<li>保留字指令（关键字）
<ul>
<li>FROM：基础镜像，当前新镜像是基于哪个镜像的</li>
<li>MAINTAINER：镜像维护者 的姓名和邮箱地址</li>
<li>RUN：容器构建时需要运行的命令</li>
<li>EXPOSE：当前容器对外暴露出的端口</li>
<li>WORKDIR：指定在创建容器后，进入容器伪终端的默认工作目录</li>
<li>ENV：用来在构建镜像过程中设置环境变量
<ul>
<li>如 ENV MY_ PATH /usr/mytest。这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一-样；也可以在其它指令中直接使用这些环境变量，比如: WORKDIR $MY_ PATH</li>
</ul>
</li>
<li>ADD：copy + 解压缩。将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</li>
<li>COPY：类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置
<ul>
<li>shell格式：COPY src des</li>
<li>exec格式：COPY [&quot;src&quot;, &quot;dest&quot;]</li>
</ul>
</li>
<li>VOLUME：容器数据卷， 用于数据保存和持久化工作</li>
<li>CMD
<ul>
<li>指定一个容器启动时要运行的命令。CMD指令的格式和RUN 相似,也是两种格式
<ul>
<li>shell格式：CMD &lt;命令&gt;</li>
<li>exec格式：CMD [&quot;可执行文件&quot;，”参数1&quot;， “参数2...]</li>
<li>参数列表格式：CMD [&quot;参数1&quot;，“参数2&quot;...]。在指定了ENTRYPOINT 指令后，用CMD 指定具体的参
数。</li>
</ul>
</li>
<li>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换.。</li>
</ul>
</li>
<li>ENTRYPOINT
<ul>
<li>指定一个容器启动时要运行的命令</li>
<li>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数，但是命令是追加的，不会覆盖前面的命令，比如在是 ENTRYPOINT [&quot;可执行文件&quot;，”参数1&quot;]，运行时docker run xxx -i，将变为ENTRYPOINT [&quot;可执行文件&quot;，”参数1&quot;，&quot;-i&quot;]，等于可以追加参数的效果</li>
</ul>
</li>
<li>ONBUILD：当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</li>
</ul>
</li>
</ul>
<p>案例</p>
<ul>
<li>
<p>Base镜像(scratch)：DockerHub中99%的镜像都是通过在base镜像中安装和配置需要的软件构建出来的</p>
<ul>
<li>scratch：an explicitly empty image, especially for building images &quot;FROM scratch&quot;</li>
</ul>
</li>
<li>
<p>centos的镜像很精简，我们通过dockerfile自定义一个centos镜像使其拥有vim、ifconfig等命令及其它自定义内容</p>
<p>/mydocker/dockerfile01</p>
<pre><code class="language-dockerfile">from centos
MAINTAINER yuanya&lt;yuanyatianchi@google.com&gt;

ENV MY_PATH /tmp
WORKDIR $MY_PATH

RUN yum -y install vim
RUN yum -y install net-tools

EXPOSE 80

CMD echo $MY_PATH
CMD echo &quot;success-ok&quot;
CMD /bin/bash
</code></pre>
<pre><code class="language-shell">$ docker build -f /mydocker/dockerfile01 -t mycentos:1.0 #构建
$ docker run - it mycentos:1.0 #运行
$ docker history &lt;容器id&gt; #查看历史
</code></pre>
</li>
</ul>
<p>定制tomcat9</p>
<pre><code class="language-dockerfile">FROM centos
MAINTAINER zzyy&lt; zzyybs@126. com&gt;
#把宿主机当前上下文的C. txt拷贝到容器/usr/local/路径下
COPY c.txt /usr/local/cincontainer.txt
#把java与tomcat添加到容器中
ADD jdk 8u171- linux -x64. tar .gz /usr/local/
ADD apache tomcat 9.0.8. tar.gz /usr/local/
#安装vim编辑器
RUN yum -y install vim
#设置工作访问时候的WORKDIR路径，登录落脚点
ENV MYPATH /usr/local
WORKDIR $MYPATH
#配置java与tomcat环境变量
ENV JAVA HOME /usr/local/jdk1.8.0_ 171
ENV CLASSPATH $JAVA HOME/lib/dt . jar :$JAVA_ HOME/1ib/ tools. jan
ENV CATALINA HOME /usr/local/apache-tomcat-9.0.8
ENV CATALINA BASE /usr/ local/ apache-tomcat-9.0.8
ENV PATH $PATH:$JAVA_ HOME/bin: $CATAL INA HOME/lib: $CATAL INA HOME/bin
#容器运行时监听的端口
EXPOSE 8080
#启动时运行tomcat
# ENTRYPOINT [&quot; /usr/local/ apache -tomcat 9.0.8/bin/startup.sh&quot; ]
# CMD [&quot; /usr/local/apache -tomcat- 9.0. 8/bin/catalina. sh&quot; ,&quot;run&quot;]
CMD /usr/1ocal/apache-tomcat-9.0.8/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.8/bin/1ogs/catalina.out

</code></pre>
<pre><code class="language-shell">docker run -d -p 9080:8080 --name myt9
-V /zzyyuse/mydockerfile/tomcat9/tesf:/usr/local/apache-tomcat-9.0.8/webapps/ test
-V /zzyyuse/mydockerfile/tomcat9/tomcat9logs/:/usr/local/apache-tomcat-9.0.8/logs
--pr ivi leged=true
zzyytomcat9
#设置容器卷，可以使我们直接把服务部署到主机tomcat9/test即可同步到容器tomcat-9.0.8/webapps/test上运行了
</code></pre>
<h2 id="软件"><a class="header" href="#软件">软件</a></h2>
<h6 id="mysql"><a class="header" href="#mysql">MySql</a></h6>
<pre><code class="language-shell">$ docker pull mysql:5.7
$ docker run mysql:5.7 --name mysql01 -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=yuanya #设置MYSQL_ROOT_PASSWORD，否则密码随机
</code></pre>
<h6 id="elesticsearch"><a class="header" href="#elesticsearch">ElesticSearch</a></h6>
<pre><code class="language-shell">$ docker pull elasticsearch:7.5.2

$ docker run --name elasticsearch -d -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e &quot;ES_JAVA_OPTS=-Xms256m -Xmx256m&quot; elasticsearch:tag
</code></pre>
<h6 id="kibana"><a class="header" href="#kibana">Kibana</a></h6>
<pre><code class="language-shell">$ ocker pull kibana:7.5.2
$ docker run --name kibana --link elasticsearch_CONTAINER_ID:elasticsearch -d -p 5601:5601 kibana:tag
</code></pre>
<h6 id="rabbitmq"><a class="header" href="#rabbitmq">RabbitMQ</a></h6>
<p>带有management的是带有web控制台的，通过15672端口访问控制台，缺省账号密码guest</p>
<pre><code class="language-shell">$ docker pull rabbitmq:3.7.24-management 
$ docker run -d -p 5672:5672 -p 15672:15672 rabbitmq:3.7.24-management
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>+++</p>
<p>title = &quot;kubernetes&quot;
description = &quot;it.cloud.kubernetes&quot;
tags = [&quot;it&quot;, &quot;cloud&quot;, &quot;kubernetes&quot;]</p>
<p>+++</p>
<h1 id="kubernetes"><a class="header" href="#kubernetes">kubernetes</a></h1>
<h2 id="--快开---1"><a class="header" href="#--快开---1">- 快开 -</a></h2>
<h2 id="安装-1"><a class="header" href="#安装-1">安装</a></h2>
<blockquote>
<p><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#installing-kubeadm-kubelet-and-kubectl">安装 kubeadm、kubelet 和 kubectl</a>；</p>
</blockquote>
<p>遵照 <a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#%E5%87%86%E5%A4%87%E5%BC%80%E5%A7%8B">kubeadm 安装准备</a>，禁用交换分区，启用<a href="https://kubernetes.io/zh/docs/reference/ports-and-protocols/">必需端口</a>并进行<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#check-required-ports">检查</a>，<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#%E5%85%81%E8%AE%B8-iptables-%E6%A3%80%E6%9F%A5%E6%A1%A5%E6%8E%A5%E6%B5%81%E9%87%8F">允许iptables检查桥接流量</a>。</p>
<pre><code class="language-shell"># 关闭swap分区(永久)：把加载swap分区的那行记录注释掉，重启生效
sed -ri 's/.*swap.*/#&amp;/' /etc/fstab

# 配置br_netfilter模块
cat &lt;&lt;EOF | tee /etc/modules-load.d/k8s.conf
br_netfilter
EOF
# 加载。也可以reboot以加载
modprobe  br_netfilter &amp;&amp; lsmod | grep br_netfilter

# 允许iptables检查桥接流量
cat &lt;&lt;EOF | tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
# 使生效
sysctl --system
</code></pre>
<h3 id="ubuntu-2"><a class="header" href="#ubuntu-2">ubuntu</a></h3>
<pre><code class="language-shell"># 关闭swap分区(临时)
swapoff -a

# 防火墙：关闭防火墙或者开放官方指南中指定的端口。ubuntu默认为关闭状态，这里仅查看
ufw status

# 必要工具
apt install -y apt-transport-https ca-certificates curl gnupg lsb-release
</code></pre>
<p>安装</p>
<pre><code class="language-shell"># GPG密钥
curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg
# apt源
echo &quot;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main&quot; | sudo tee /etc/apt/sources.list.d/kubernetes.list

# 查看版本。如果出现版本错误可能需要降低尝 kubenetes 版本
apt update &amp;&amp; apt-cache madison kubeadm | grep 1.26
# 安装
apt install -y kubeadm=1.26.3-00 kubelet=1.26.3-00 kubectl=1.26.3-00

# 开机启动并立即启动
systemctl enable --now kubelet
</code></pre>
<h3 id="centos-2"><a class="header" href="#centos-2">centos</a></h3>
<pre><code class="language-shell"># 关闭swap分区(临时)
setenforce 0

# 防火墙：关闭防火墙或者开放官方指南中指定的端口
systemctl disable --now firewalld &amp;&amp; firewall-cmd --state
</code></pre>
<p>使用 <a href="https://mirrors.aliyun.com/kubernetes/yum/repos/">kubernetes 阿里源</a>。</p>
<pre><code class="language-shell">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-\$basearch
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
exclude=kubelet kubeadm kubectl
EOF

# 将 SELinux 设置为 permissive 模式（相当于将其禁用）。临时设置立即生效，并永久禁用
setenforce 0
sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config

# 安装。kubelet-x.x.x kubeadm-x.x.x kubectl-x.x.x 可以指定版本
yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes
# 设置为开机启动并立即启动，但 kubelet 现在每隔几秒就会重启，因为它陷入了一个等待 kubeadm 指令的死循环
systemctl enable --now kubelet
# 查看 kubelet
systemctl status kubelet
</code></pre>
<h3 id="二进制"><a class="header" href="#二进制">二进制</a></h3>
<h4 id="kubectl"><a class="header" href="#kubectl">kubectl</a></h4>
<blockquote>
<p><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/">安装kubectl</a>。</p>
</blockquote>
<pre><code class="language-shell"># kubectl
curl -LO &quot;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl&quot;
# 校验和
curl -LO &quot;https://dl.k8s.io/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256&quot;
# 校验
echo &quot;$(cat kubectl.sha256)  kubectl&quot; | sha256sum --check
# 移动
mv kubectl /usr/local/bin
</code></pre>
<h2 id="开机启动-1"><a class="header" href="#开机启动-1">开机启动</a></h2>
<pre><code class="language-shell"># 开机启动并立即启动
# kubelet 现在每隔几秒就会重启，因为当前主机还没有成为 kubernetes 节点，无法正常运作
systemctl enable --now kubelet
</code></pre>
<h2 id="命令补全--别名"><a class="header" href="#命令补全--别名">命令补全 &amp; 别名</a></h2>
<blockquote>
<p><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/included/optional-kubectl-configs-bash-linux/">Linux 系统中的 bash 自动补全功能</a>。</p>
</blockquote>
<p>向 <code>~/.bashrc</code> 中添加内容。如果没有 bash-completion 需要先 <code>apt install -y bash-completion</code>。</p>
<pre><code class="language-shell">cat &gt;&gt; ~/.bashrc &lt;&lt; EOF



# bash-completion
source /usr/share/bash-completion/bash_completion
# kubectl
source &lt;(kubectl completion bash)
alias kc=kubectl
complete -o default -F __start_kubectl kc
EOF

# 更新
source .bashrc
</code></pre>
<h2 id="时间同步"><a class="header" href="#时间同步">时间同步</a></h2>
<pre><code class="language-shell"># 在各节点上执行如下命令
apt install -y ntpdate
ntpdate time.windows.com
</code></pre>
<h2 id="--备份点--"><a class="header" href="#--备份点--">- 备份点 -</a></h2>
<h2 id="准备工作"><a class="header" href="#准备工作">准备工作</a></h2>
<h3 id="cgroup-驱动"><a class="header" href="#cgroup-驱动">cgroup 驱动</a></h3>
<blockquote>
<p><a href="https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/#docker">dokcer 配置 systemd 作 cgroup 驱动</a>；</p>
<p><a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/configure-cgroup-driver/#%E9%85%8D%E7%BD%AE-kubelet-%E7%9A%84-cgroup-%E9%A9%B1%E5%8A%A8">kubelet 配置 systemd 作 cgroup 驱动</a>；</p>
</blockquote>
<p>注意 docker 容器需要配置systemd作cgroup驱动；</p>
<p>1.22及之后<code>kubeadm init</code>默认使用 <code>systemd</code> 作为 kubelet 的 cgroup 驱动，而不是 <code>cgroupfs</code>。</p>
<h3 id="控制平面准备"><a class="header" href="#控制平面准备">控制平面准备</a></h3>
<pre><code class="language-shell"># 设置 hostname
hostnamectl set-hostname 192.168.31.11

# 主节点添加本机 DNS 映射
sed -i '$a192.168.31.11 kubecpe' /etc/hosts
</code></pre>
<h3 id="数据平面准备"><a class="header" href="#数据平面准备">数据平面准备</a></h3>
<pre><code class="language-shell"># 设置 hostname
hostnamectl set-hostname 192.168.31.15
</code></pre>
<h2 id="集群创建"><a class="header" href="#集群创建">集群创建</a></h2>
<p>准备3台完成安装的机器</p>
<h3 id="kubeadm"><a class="header" href="#kubeadm">kubeadm</a></h3>
<p><a href="https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/">kubeadm 参考指南</a>。</p>
<h4 id="控制平面"><a class="header" href="#控制平面">控制平面</a></h4>
<p><a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E8%8A%82%E7%82%B9">初始化控制平面节点</a>。注意要再次运行 <code>kubeadm init</code>，必须首先<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#tear-down">卸载集群</a>。如果是非root用户</p>
<pre><code class="language-shell"># --apiserver-advertise-address 设置 master ip
# --image-repository 指定阿里云镜像仓库地址，因为默认拉取镜像地址 k8s.gcr.io 国内无法访问；
$ kubeadm init \
--node-name 192.168.31.11 \
--control-plane-endpoint=kubecpe \
--apiserver-advertise-address=192.168.31.11 \
--pod-network-cidr=10.244.0.0/16 \
--image-repository registry.aliyuncs.com/google_containers

# 创建成功后得到如下操作提示
......
Your Kubernetes control-plane has initialized successfully!

# 如何开始使用集群（kubectl）
To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

Alternatively, if you are the root user, you can run:

  export KUBECONFIG=/etc/kubernetes/admin.conf

# 如何安装 pod 网络
You should now deploy a pod network to the cluster.
Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

# 如何添加控制平面节点
You can now join any number of control-plane nodes by copying certificate authorities
and service account keys on each node and then running the following as root:

  kubeadm join kubecpe:6443 --token nhn70c.ck1r8ceu4j4pq3ep \
        --discovery-token-ca-cert-hash sha256:55b9644fc941d4928f40baa30a700973cf375b826fdb8e00012797cdbe0c90c1 \
        --control-plane

# 如何添加工作节点
Then you can join any number of worker nodes by running the following on each as root:

kubeadm join kubecpe:6443 --token nhn70c.ck1r8ceu4j4pq3ep \
        --discovery-token-ca-cert-hash sha256:55b9644fc941d4928f40baa30a700973cf375b826fdb8e00012797cdbe0c90c1
</code></pre>
<h4 id="使用集群"><a class="header" href="#使用集群">使用集群</a></h4>
<p>复制 /etc/kubernetes/admin.conf 到 $HOME/.kube/config 即可使用 kubectl</p>
<pre><code class="language-shell">mkdir ~/.kube
cp -i /etc/kubernetes/admin.conf ~/.kube/config
chown $(id -u):$(id -g) ~/.kube/config
</code></pre>
<h4 id="pod-网络"><a class="header" href="#pod-网络">pod 网络</a></h4>
<p><a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#pod-network">安装 pod 网络</a>。从 <a href="https://github.com/flannel-io/flannel/blob/v0.15.1/Documentation/kube-flannel.yml">flannel github</a> 上复制下来使用，使用 -f 直接指定或者使用 wget 下载后 -f 指定，都会出现 yaml 解析错误</p>
<p>如有需要请<a href="https://huangzhongde.cn/istio/Chapter6/Chapter6-8.html">配置网卡</a>。</p>
<pre><code class="language-shell"># 部署 kube-flannel
kubectl apply -f /mnt/share/kube-flannel.yaml
</code></pre>
<h4 id="工作节点"><a class="header" href="#工作节点">工作节点</a></h4>
<p>集群<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#join-nodes">加入节点</a>。如果前面提示的 token 和 hash 已经找不到了，可以在控制平面节点上查看 token 和 hash</p>
<pre><code class="language-shell"># 查看 token 列表
kubeadm token list
# 或者创建新的 token
kubeadm token create
# 查看 CA 公钥的哈希值
openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //'
</code></pre>
<p>然后在工作节点上通过 <code>kubeadm join --token &lt;token&gt; &lt;control-plane-host&gt;:&lt;control-plane-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</code> 加入集群。</p>
<pre><code class="language-shell"># 工作节点添加控制平面节点的 DNS 映射
sed -i '$a192.168.31.11 kubecpe' /etc/hosts
# 加入集群
kubeadm join kubecpe:6443 \
--node-name 192.168.31.11 \
--token st4khy.2j4qmbuge5mh1d76 \
--discovery-token-ca-cert-hash sha256:55b9644fc941d4928f40baa30a700973cf375b826fdb8e00012797cdbe0c90c1
</code></pre>
<h4 id="节点删除"><a class="header" href="#节点删除">节点删除</a></h4>
<blockquote>
<p>节点清理</p>
</blockquote>
<p>先在节点上重置 kubeadm 安装的状态，然后通过 kubectl 删除节点即可。主节点只需调用 <code>kubeadm reset</code> 会进行尽力而为的清理</p>
<pre><code class="language-shell"># 使节点不调度
kubectl drain &lt;node name&gt; --delete-emptydir-data --force --ignore-daemonsets
kubeadm reset
kubectl delete node &lt;node_name&gt;
</code></pre>
<h4 id="网络卸载"><a class="header" href="#网络卸载">网络卸载</a></h4>
<p>重置过程 <code>kubeadm reset</code> 不会重置或清除 iptables 规则或 IPVS 表</p>
<pre><code class="language-shell"># iptables清理
iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X
</code></pre>
<pre><code class="language-shell"># IPVS 清理
ipvsadm -C
</code></pre>
<p>网卡清理</p>
<pre><code class="language-shell"># flannel，清理完需重启 kubelet
kubectl delete -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
ifconfig cni0 down
ip link delete cni0
ifconfig flannel.1 down
ip link delete flannel.1
rm -rf /var/lib/cni/
rm -f /etc/cni/net.d/*
systemctl restart kubelet
</code></pre>
<h3 id="最佳实践"><a class="header" href="#最佳实践">最佳实践</a></h3>
<h4 id="tls-证书和秘钥"><a class="header" href="#tls-证书和秘钥">TLS 证书和秘钥</a></h4>
<p>安装 CFSSL</p>
<pre><code class="language-shell">$ go get -u github.com/cloudflare/cfssl/cmd/...
$ ls $GOPATH/bin/cfssl*
/root/go/path/bin/cfssl         /root/go/path/bin/cfssl-certinfo  /root/go/path/bin/cfssl-newkey
/root/go/path/bin/cfssl-bundle  /root/go/path/bin/cfssljson       /root/go/path/bin/cfssl-scan
</code></pre>
<h5 id="ca-证书"><a class="header" href="#ca-证书">CA 证书</a></h5>
<p>创建 CA 配置文件。</p>
<pre><code class="language-shell">$ cfssl print-defaults config &gt; config.json
$ cfssl print-defaults csr &gt; csr.json

# 根据 config.json 文件的格式创建如下的 ca-config.json 文件，过期时间设置成了 87600h
$ cat &gt; ca-config.json &lt;&lt;EOF
{
  &quot;signing&quot;: {
    &quot;default&quot;: {
      &quot;expiry&quot;: &quot;87600h&quot;
    },
    &quot;profiles&quot;: {
      &quot;kubernetes&quot;: {
        &quot;usages&quot;: [
            &quot;signing&quot;,
            &quot;key encipherment&quot;,
            &quot;server auth&quot;,
            &quot;client auth&quot;
        ],
        &quot;expiry&quot;: &quot;87600h&quot;
      }
    }
  }
}
EOF
</code></pre>
<p>字段说明：</p>
<ul>
<li><code>ca-config.json</code>：可以定义多个 profiles，分别指定不同的过期时间、使用场景等参数；后续在签名证书时使用某个 profile；</li>
<li><code>signing</code>：表示该证书可用于签名其它证书；生成的 ca.pem 证书中 <code>CA=TRUE</code>；</li>
<li><code>server auth</code>：表示client可以用该 CA 对server提供的证书进行验证；</li>
<li><code>client auth</code>：表示server可以用该CA对client提供的证书进行验证；</li>
</ul>
<p>创建 CA 证书签名请求文件</p>
<pre><code class="language-shell">cat &gt; ca-csr.json &lt;&lt; EOF
&gt; {
&gt;   &quot;CN&quot;: &quot;kubernetes&quot;,
&gt;   &quot;key&quot;: {
&gt;     &quot;algo&quot;: &quot;rsa&quot;,
&gt;     &quot;size&quot;: 2048
&gt;   },
&gt;   &quot;names&quot;: [
&gt;     {
&gt;       &quot;C&quot;: &quot;CN&quot;,
&gt;       &quot;ST&quot;: &quot;BeiJing&quot;,
&gt;       &quot;L&quot;: &quot;BeiJing&quot;,
&gt;       &quot;O&quot;: &quot;k8s&quot;,
&gt;       &quot;OU&quot;: &quot;System&quot;
&gt;     }
&gt;   ],
&gt;     &quot;ca&quot;: {
&gt;        &quot;expiry&quot;: &quot;87600h&quot;
&gt;     }
&gt; }
&gt; EOF
</code></pre>
<p>字段说明：</p>
<ul>
<li>&quot;CN&quot;：<code>Common Name</code>，kube-apiserver 从证书中提取该字段作为请求的用户名 (User Name)；浏览器使用该字段验证网站是否合法；</li>
<li>&quot;O&quot;：<code>Organization</code>，kube-apiserver 从证书中提取该字段作为请求用户所属的组 (Group)；</li>
</ul>
<p><strong>生成 CA 证书和私钥</strong>。</p>
<pre><code class="language-shell">$ cfssl gencert -initca ca-csr.json | cfssljson -bare ca
$ ls ca*
ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem
</code></pre>
<h5 id="kubernetes-证书"><a class="header" href="#kubernetes-证书">kubernetes 证书</a></h5>
<p>创建 kubernetes 证书签名请求文件</p>
<pre><code class="language-shell">$ cat &gt; kubernetes-csr.json &lt;&lt; EOF
&gt; {
&gt;     &quot;CN&quot;: &quot;kubernetes&quot;,
&gt;     &quot;hosts&quot;: [
&gt;       &quot;127.0.0.1&quot;,
&gt;       &quot;172.20.0.112&quot;,
&gt;       &quot;172.20.0.113&quot;,
&gt;       &quot;172.20.0.114&quot;,
&gt;       &quot;172.20.0.115&quot;,
&gt;       &quot;10.254.0.1&quot;,
&gt;       &quot;kubernetes&quot;,
&gt;       &quot;kubernetes.default&quot;,
&gt;       &quot;kubernetes.default.svc&quot;,
&gt;       &quot;kubernetes.default.svc.cluster&quot;,
        &quot;algo&quot;: &quot;rsa&quot;,
&gt;       &quot;kubernetes.default.svc.cluster.local&quot;
&gt;     ],
&gt;     &quot;key&quot;: {
&gt;         &quot;algo&quot;: &quot;rsa&quot;,
&gt;         &quot;size&quot;: 2048
&gt;     },
&gt;     &quot;names&quot;: [
&gt;         {
&gt;             &quot;C&quot;: &quot;CN&quot;,
&gt;             &quot;ST&quot;: &quot;BeiJing&quot;,
&gt;             &quot;L&quot;: &quot;BeiJing&quot;,
&gt;             &quot;O&quot;: &quot;k8s&quot;,
&gt;             &quot;OU&quot;: &quot;System&quot;
&gt;         }
&gt;     ]
&gt; }
&gt; EOF
</code></pre>
<ul>
<li>如果 hosts 字段不为空则需要指定授权使用该证书的 <strong>IP 或域名列表</strong>，由于该证书后续被 <code>etcd</code> 集群和 <code>kubernetes master</code> 集群使用，所以上面分别指定了 <code>etcd</code> 集群、<code>kubernetes master</code> 集群的主机 IP 和 <strong><code>kubernetes</code> 服务的服务 IP</strong>（一般是 <code>kube-apiserver</code> 指定的 <code>service-cluster-ip-range</code> 网段的第一个IP，如 10.254.0.1）。</li>
<li>这是最小化安装的kubernetes集群，包括一个私有镜像仓库，三个节点的kubernetes集群，以上物理节点的IP也可以更换为主机名。</li>
</ul>
<p><strong>生成 kubernetes 证书和私钥</strong></p>
<pre><code class="language-shell">$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kubernetes-csr.json | cfssljson -bare kubernetes
$ ls kubernetes*
kubernetes.csr  kubernetes-csr.json  kubernetes-key.pem  kubernetes.pem
</code></pre>
<h5 id="admin-证书"><a class="header" href="#admin-证书">admin 证书</a></h5>
<p>创建 admin 证书签名请求文件</p>
<pre><code class="language-shell">$ cat &gt; admin-csr.json &lt;&lt; EOF
&gt; {
&gt;   &quot;CN&quot;: &quot;admin&quot;,
&gt;   &quot;hosts&quot;: [],
&gt;   &quot;key&quot;: {
&gt;     &quot;algo&quot;: &quot;rsa&quot;,
&gt;     &quot;size&quot;: 2048
&gt;   },
&gt;   &quot;names&quot;: [
&gt;     {
&gt;       &quot;C&quot;: &quot;CN&quot;,
&gt;       &quot;ST&quot;: &quot;BeiJing&quot;,
&gt;       &quot;L&quot;: &quot;BeiJing&quot;,
&gt;       &quot;O&quot;: &quot;system:masters&quot;,
&gt;       &quot;OU&quot;: &quot;System&quot;
&gt;     }
&gt;   ]
&gt; }
&gt; EOF
</code></pre>
<ul>
<li>后续 <code>kube-apiserver</code> 使用 <code>RBAC</code> 对客户端(如 <code>kubelet</code>、<code>kube-proxy</code>、<code>Pod</code>)请求进行授权；</li>
<li><code>kube-apiserver</code> 预定义了一些 <code>RBAC</code> 使用的 <code>RoleBindings</code>，如 <code>cluster-admin</code> 将 Group <code>system:masters</code> 与 Role <code>cluster-admin</code> 绑定，该 Role 授予了调用<code>kube-apiserver</code> 的<strong>所有 API</strong>的权限；</li>
<li>O 指定该证书的 Group 为 <code>system:masters</code>，<code>kubelet</code> 使用该证书访问 <code>kube-apiserver</code> 时 ，由于证书被 CA 签名，所以认证通过，同时由于证书用户组为经过预授权的 <code>system:masters</code>，所以被授予访问所有 API 的权限；</li>
</ul>
<p><strong>生成 admin 证书和私钥</strong></p>
<pre><code class="language-shell">$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin
$ ls admin*
admin.csr  admin-csr.json  admin-key.pem  admin.pem
</code></pre>
<p><strong>注意</strong>：这个admin 证书，是将来生成管理员用的kube config 配置文件用的，现在我们一般建议使用RBAC 来对kubernetes 进行角色权限控制， kubernetes 将证书中的CN 字段 作为User， O 字段作为 Group（具体参考<a href="https://jimmysong.io/kubernetes-handbook/guide/authentication.html"> Kubernetes中的用户与身份认证授权</a>中 X509 Client Certs 一段）。</p>
<p>在搭建完 kubernetes 集群后，我们可以通过命令: <code>kubectl get clusterrolebinding cluster-admin -o yaml</code> ,查看到 <code>clusterrolebinding cluster-admin</code> 的 subjects 的 kind 是 Group，name 是 <code>system:masters</code>。 <code>roleRef</code> 对象是 <code>ClusterRole cluster-admin</code>。 意思是凡是 <code>system:masters Group</code> 的 user 或者 <code>serviceAccount</code> 都拥有 <code>cluster-admin</code> 的角色。 因此我们在使用 kubectl 命令时候，才拥有整个集群的管理权限。</p>
<pre><code class="language-yaml">$ kubectl get clusterrolebinding cluster-admin -o yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;
  creationTimestamp: 2017-04-11T11:20:42Z
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  name: cluster-admin
  resourceVersion: &quot;52&quot;
  selfLink: /apis/rbac.authorization.k8s.io/v1/clusterrolebindings/cluster-admin
  uid: e61b97b2-1ea8-11e7-8cd7-f4e9d49f8ed0
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: system:masters
</code></pre>
<h5 id="kube-proxy-证书"><a class="header" href="#kube-proxy-证书">kube-proxy 证书</a></h5>
<p>创建 kube-proxy 证书签名请求文件</p>
<pre><code class="language-shell">$ cat &gt; kube-proxy-csr.json &lt;&lt; EOF
&gt; {
&gt;   &quot;CN&quot;: &quot;system:kube-proxy&quot;,
&gt;   &quot;hosts&quot;: [],
&gt;   &quot;key&quot;: {
&gt;     &quot;algo&quot;: &quot;rsa&quot;,
&gt;     &quot;size&quot;: 2048
&gt;   },
&gt;   &quot;names&quot;: [
&gt;     {
&gt;       &quot;C&quot;: &quot;CN&quot;,
&gt;       &quot;ST&quot;: &quot;BeiJing&quot;,
&gt;       &quot;L&quot;: &quot;BeiJing&quot;,
&gt;       &quot;O&quot;: &quot;k8s&quot;,
&gt;       &quot;OU&quot;: &quot;System&quot;
&gt;     }
&gt;   ]
&gt; }
&gt; EOF
</code></pre>
<ul>
<li>CN 指定该证书的 User 为 <code>system:kube-proxy</code>；</li>
<li><code>kube-apiserver</code> 预定义的 RoleBinding <code>system:node-proxier</code> 将User <code>system:kube-proxy</code> 与 Role <code>system:node-proxier</code> 绑定，该 Role 授予了调用 <code>kube-apiserver</code> Proxy 相关 API 的权限；</li>
</ul>
<p>生成 kube-proxy 客户端证书和私钥</p>
<pre><code class="language-shell">$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes  kube-proxy-csr.json | cfssljson -bare kube-proxy
$ ls kube-proxy*
</code></pre>
<h5 id="校验证书"><a class="header" href="#校验证书">校验证书</a></h5>
<h6 id="使用-openssl"><a class="header" href="#使用-openssl">使用 openssl</a></h6>
<p>以 Kubernetes 证书为例，使用 openssl 命令读取证书信息</p>
<ul>
<li>确认 <code>Issuer</code> 字段的内容和 <code>ca-csr.json</code> 一致；</li>
<li>确认 <code>Subject</code> 字段的内容和 <code>kubernetes-csr.json</code> 一致；</li>
<li>确认 <code>X509v3 Subject Alternative Name</code> 字段的内容和 <code>kubernetes-csr.json</code> 一致；</li>
<li>确认 <code>X509v3 Key Usage、Extended Key Usage</code> 字段的内容和 <code>ca-config.json</code> 中 <code>kubernetes</code> profile 一致；</li>
</ul>
<pre><code class="language-shell">$ openssl x509  -noout -text -in  kubernetes.pem
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            03:0e:b4:83:5e:6d:02:fa:bf:62:21:aa:37:47:f1:c4:88:f4:8a:0c
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C = CN, ST = BeiJing, L = BeiJing, O = k8s, OU = System, CN = kubernetes
        Validity
            Not Before: Mar 12 12:04:00 2022 GMT
            Not After : Mar  9 12:04:00 2032 GMT
        Subject: C = CN, ST = BeiJing, L = BeiJing, O = k8s, OU = System, CN = kubernetes
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: (2048 bit)
                Modulus:
                    ......
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Key Usage: critical
                Digital Signature, Key Encipherment
            X509v3 Extended Key Usage:
                TLS Web Server Authentication, TLS Web Client Authentication
            X509v3 Basic Constraints: critical
                CA:FALSE
            X509v3 Subject Key Identifier:
                B7:15:10:43:1B:E1:53:B0:6A:12:56:5B:A5:CD:EF:77:E4:A0:79:F4
            X509v3 Subject Alternative Name:
                DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster, DNS:kubernetes.default.svc.cluster.local, IP Address:127.0.0.1, IP Address:172.20.0.112, IP Address:172.20.0.113, IP Address:172.20.0.114, IP Address:172.20.0.115, IP Address:10.254.0.1
    Signature Algorithm: sha256WithRSAEncryption
         ......
</code></pre>
<h6 id="使用cfssl-certinfo"><a class="header" href="#使用cfssl-certinfo">使用cfssl-certinfo</a></h6>
<pre><code class="language-shell">cfssl-certinfo -cert kubernetes.pem
{
  &quot;subject&quot;: {
    &quot;common_name&quot;: &quot;kubernetes&quot;,
    &quot;country&quot;: &quot;CN&quot;,
    &quot;organization&quot;: &quot;k8s&quot;,
    &quot;organizational_unit&quot;: &quot;System&quot;,
    &quot;locality&quot;: &quot;BeiJing&quot;,
    &quot;province&quot;: &quot;BeiJing&quot;,
    &quot;names&quot;: [
      &quot;CN&quot;,
      &quot;BeiJing&quot;,
      &quot;BeiJing&quot;,
      &quot;k8s&quot;,
      &quot;System&quot;,
      &quot;kubernetes&quot;
    ]
  },
  &quot;issuer&quot;: {
    &quot;common_name&quot;: &quot;kubernetes&quot;,
    &quot;country&quot;: &quot;CN&quot;,
    &quot;organization&quot;: &quot;k8s&quot;,
    &quot;organizational_unit&quot;: &quot;System&quot;,
    &quot;locality&quot;: &quot;BeiJing&quot;,
    &quot;province&quot;: &quot;BeiJing&quot;,
    &quot;names&quot;: [
      &quot;CN&quot;,
      &quot;BeiJing&quot;,
      &quot;BeiJing&quot;,
      &quot;k8s&quot;,
      &quot;System&quot;,
      &quot;kubernetes&quot;
    ]
  },
  &quot;serial_number&quot;: &quot;17454907659222183176468532411310969421540133388&quot;,
  &quot;sans&quot;: [
    &quot;kubernetes&quot;,
    &quot;kubernetes.default&quot;,
    &quot;kubernetes.default.svc&quot;,
    &quot;kubernetes.default.svc.cluster&quot;,
    &quot;kubernetes.default.svc.cluster.local&quot;,
    &quot;127.0.0.1&quot;,
    &quot;172.20.0.112&quot;,
    &quot;172.20.0.113&quot;,
    &quot;172.20.0.114&quot;,
    &quot;172.20.0.115&quot;,
    &quot;10.254.0.1&quot;
  ],
  &quot;not_before&quot;: &quot;2022-03-12T12:04:00Z&quot;,
  &quot;not_after&quot;: &quot;2032-03-09T12:04:00Z&quot;,
  &quot;sigalg&quot;: &quot;SHA256WithRSA&quot;,
  &quot;authority_key_id&quot;: &quot;&quot;,
  &quot;subject_key_id&quot;: &quot;B7:15:10:43:1B:E1:53:B0:6A:12:56:5B:A5:CD:EF:77:E4:A0:79:F4&quot;,
  &quot;pem&quot;: &quot;-----BEGIN CERTIFICATE-----\nMIIEajCCA1KgAwIBAgIUAw60g15tAvq/YiGqN0fxxIj0igwwDQYJKoZIhvcNAQEL\nBQAwZTELMAkGA1UEBhMCQ04xEDAOBgNVBAgTB0JlaUppbmcxEDAOBgNVBAcTB0Jl\naUppbmcxDDAKBgNVBAoTA2s4czEPMA0GA1UECxMGU3lzdGVtMRMwEQYDVQQDEwpr\ndWJlcm5ldGVzMB4XDTIyMDMxMjEyMDQwMFoXDTMyMDMwOTEyMDQwMFowZTELMAkG\nA1UEBhMCQ04xEDAOBgNVBAgTB0JlaUppbmcxEDAOBgNVBAcTB0JlaUppbmcxDDAK\nBgNVBAoTA2s4czEPMA0GA1UECxMGU3lzdGVtMRMwEQYDVQQDEwprdWJlcm5ldGVz\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA3QrEXpJnjVNsYnFGnu4f\nJG99y/P49uL0VTEZP4+6X/NRN1Fq9clX8acDHQcYBPud6OSI2Lvah9hxKQTpmIIQ\nky2lEnA64c9BDU5x0CUP5UOzwryjddFshHfvNOg7dySR3hzOKiKac31RKCtOo3OB\nlVctX+ksm1dAsTuGoAvYXKTl2fbR6p+Ew7tkMjbtaghXS9MXVy3RN1t7G3X9Xj9U\ndHnfdTCtTVxJF6kRrOBuP3ad+YDj6QAk8jXKefkFzfezj+w1g1zPJXcTtSko/YiH\n9A0lfiKxiv+6RGoXWQRnMT1J2Or8sKP0yWb0qLkk/+jINCiNulLL+mDQrEVlSSn3\ncwIDAQABo4IBEDCCAQwwDgYDVR0PAQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUF\nBwMBBggrBgEFBQcDAjAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBS3FRBDG+FTsGoS\nVlulze935KB59DCBrQYDVR0RBIGlMIGiggprdWJlcm5ldGVzghJrdWJlcm5ldGVz\nLmRlZmF1bHSCFmt1YmVybmV0ZXMuZGVmYXVsdC5zdmOCHmt1YmVybmV0ZXMuZGVm\nYXVsdC5zdmMuY2x1c3RlcoIka3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVy\nLmxvY2FshwR/AAABhwSsFABwhwSsFABxhwSsFAByhwSsFABzhwQK/gABMA0GCSqG\nSIb3DQEBCwUAA4IBAQAJTaKt98jCvsRo2vq9RvK732UO4tgYdhyAcQTREvsEyjdT\nYlA85xix0I9j5MlBgyfplQLCIobGjjdmkIdVcJsciPaqRdCjurHkDF5pBs4m/qlr\nfhxjEjZr36aT3/taq5xUA//TkCTb9p8Ijm+3AMdPGxovXE/TokEYcXDNasaVYsLY\naBxKDv3Bymwv9RIzPDrcNnn7llsCba6IX+L8u3TB4GIOxv7yH6XwVhqAFKh1yXUZ\n6H8Wky5z8l91virnRBfi3y4jJsl/odIznp16We8VnWCA36eTzBwOOEZiU3MvlPYc\nei7FKCGN5U3ZwwLsTMH2WzWX+Zw+dZGA97FmDYnX\n-----END CERTIFICATE-----\n&quot;
}
</code></pre>
<h5 id="颁发证书"><a class="header" href="#颁发证书">颁发证书</a></h5>
<p>将生成的证书和秘钥文件（后缀名为<code>.pem</code>）拷贝到所有（需要的）机器（包括当前）的 <code>/etc/kubernetes/ssl</code> 目录下备用</p>
<pre><code class="language-shell">mkdir -p /etc/kubernetes/ssl &amp;&amp; cp *.pem /etc/kubernetes/ssl
</code></pre>
<h4 id="kubelet"><a class="header" href="#kubelet">kubelet</a></h4>
<pre><code class="language-shell">export KUBE_APISERVER=&quot;https://kubecpe:6443&quot;

# 设置集群参数
kubectl config set-cluster kubernetes \
  --certificate-authority=/etc/kubernetes/ssl/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER}
# 设置客户端认证参数
kubectl config set-credentials admin \
  --client-certificate=/etc/kubernetes/ssl/admin.pem \
  --embed-certs=true \
  --client-key=/etc/kubernetes/ssl/admin-key.pem
# 设置上下文参数
kubectl config set-context kubernetes \
  --cluster=kubernetes \
  --user=admin
# 设置默认上下文
kubectl config use-context kubernetes
</code></pre>
<ul>
<li><code>admin.pem</code> 证书 OU 字段值为 <code>system:masters</code>，<code>kube-apiserver</code> 预定义的 RoleBinding <code>cluster-admin</code> 将 Group <code>system:masters</code> 与 Role <code>cluster-admin</code> 绑定，该 Role 授予了调用<code>kube-apiserver</code> 相关 API 的权限；</li>
<li>生成的 kubeconfig 被保存到 <code>~/.kube/config</code> 文件；</li>
</ul>
<p><strong>注意：</strong><code>~/.kube/config</code>文件拥有对该集群的最高权限，请妥善保管。</p>
<h4 id="kubeconfig"><a class="header" href="#kubeconfig">kubeconfig</a></h4>
<h5 id="tls-bootstrapping-token"><a class="header" href="#tls-bootstrapping-token">TLS Bootstrapping Token</a></h5>
<p>Token可以是任意的包含128 bit的字符串，可以使用安全的随机数发生器生成。</p>
<pre><code class="language-shell">export BOOTSTRAP_TOKEN=$(head -c 16 /dev/urandom | od -An -t x | tr -d ' ')

cat &gt; token.csv &lt;&lt;EOF
${BOOTSTRAP_TOKEN},kubelet-bootstrap,10001,&quot;system:kubelet-bootstrap&quot;
EOF

# 检查 token.csv 文件，确认其中的 ${BOOTSTRAP_TOKEN} 环境变量已经被真实的值替换
cat token.csv
c16e2aa67b2d10569d68ee176af17017,kubelet-bootstrap,10001,&quot;system:kubelet-bootstrap&quot;
</code></pre>
<p><strong>BOOTSTRAP_TOKEN</strong> 将被写入到 kube-apiserver 使用的 token.csv 文件和 kubelet 使用的 <code>bootstrap.kubeconfig</code> 文件，如果后续重新生成了 BOOTSTRAP_TOKEN，则需要：</p>
<ol>
<li>更新 token.csv 文件，分发到所有机器 (master 和 node）的 /etc/kubernetes/ 目录下，分发到node节点上非必需；</li>
<li>重新生成 bootstrap.kubeconfig 文件，分发到所有 node 机器的 /etc/kubernetes/ 目录下；</li>
<li>重启 kube-apiserver 和 kubelet 进程；</li>
<li>重新 approve kubelet 的 csr 请求；</li>
</ol>
<pre><code class="language-shell">cp token.csv /etc/kubernetes/
</code></pre>
<h5 id="kubelet-bootstrapping-kubeconfig"><a class="header" href="#kubelet-bootstrapping-kubeconfig">kubelet bootstrapping kubeconfig</a></h5>
<pre><code class="language-shell">cd /etc/kubernetes
export KUBE_APISERVER=&quot;https://kubecpe:6443&quot;

# 设置集群参数
kubectl config set-cluster kubernetes \
  --certificate-authority=/etc/kubernetes/ssl/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=bootstrap.kubeconfig

# 设置客户端认证参数
kubectl config set-credentials kubelet-bootstrap \
  --token=${BOOTSTRAP_TOKEN} \
  --kubeconfig=bootstrap.kubeconfig

# 设置上下文参数
kubectl config set-context default \
  --cluster=kubernetes \
  --user=kubelet-bootstrap \
  --kubeconfig=bootstrap.kubeconfig

# 设置默认上下文
kubectl config use-context default --kubeconfig=bootstrap.kubeconfig
</code></pre>
<ul>
<li><code>--embed-certs</code> 为 <code>true</code> 时表示将 <code>certificate-authority</code> 证书写入到生成的 <code>bootstrap.kubeconfig</code> 文件中；</li>
<li>设置客户端认证参数时<strong>没有</strong>指定秘钥和证书，后续由 <code>kube-apiserver</code> 自动生成；</li>
</ul>
<h5 id="kube-proxy-kubeconfig"><a class="header" href="#kube-proxy-kubeconfig">kube-proxy kubeconfig</a></h5>
<pre><code class="language-shell">export KUBE_APISERVER=&quot;https://172.20.0.113:6443&quot;
# 设置集群参数
kubectl config set-cluster kubernetes \
  --certificate-authority=/etc/kubernetes/ssl/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=kube-proxy.kubeconfig
# 设置客户端认证参数
kubectl config set-credentials kube-proxy \
  --client-certificate=/etc/kubernetes/ssl/kube-proxy.pem \
  --client-key=/etc/kubernetes/ssl/kube-proxy-key.pem \
  --embed-certs=true \
  --kubeconfig=kube-proxy.kubeconfig
# 设置上下文参数
kubectl config set-context default \
  --cluster=kubernetes \
  --user=kube-proxy \
  --kubeconfig=kube-proxy.kubeconfig
# 设置默认上下文
kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig
</code></pre>
<h5 id="分发-kubeconfig"><a class="header" href="#分发-kubeconfig">分发 kubeconfig</a></h5>
<p>将两个 kubeconfig 文件分发到所有 Node 机器的 <code>/etc/kubernetes/</code> 目录</p>
<pre><code class="language-shell">cp bootstrap.kubeconfig kube-proxy.kubeconfig /etc/kubernetes/
</code></pre>
<h4 id="etcd"><a class="header" href="#etcd">etcd</a></h4>
<h5 id="准备"><a class="header" href="#准备">准备</a></h5>
<p>添加 hosts</p>
<pre><code class="language-shell">sed -i '$a192.168.43.201 kubecpe' /etc/hosts
</code></pre>
<h5 id="安装-2"><a class="header" href="#安装-2">安装</a></h5>
<pre><code class="language-shell">wget https://github.com/etcd-io/etcd/releases/download/v3.4.18/etcd-v3.4.18-linux-amd64.tar.gz
tar -xvf etcd-v3.4.18-linux-amd64.tar.gz
mv etcd-v3.1.5-linux-amd64/etcd* /usr/local/bin
</code></pre>
<h5 id="创建-etcd-的-systemd-unit-文件"><a class="header" href="#创建-etcd-的-systemd-unit-文件">创建 etcd 的 systemd unit 文件</a></h5>
<p>在/usr/lib/systemd/system/目录下创建文件etcd.service，内容如下。注意替换IP地址为你自己的etcd集群的主机IP。</p>
<pre><code class="language-toml">[Unit]
Description=Etcd Server
After=network.target
After=network-online.target
Wants=network-online.target
Documentation=https://github.com/coreos

[Service]
Type=notify
WorkingDirectory=/var/lib/etcd/
EnvironmentFile=-/etc/etcd/etcd.conf
ExecStart=/usr/local/bin/etcd \
  --name ${ETCD_NAME} \
  --cert-file=/etc/kubernetes/ssl/kubernetes.pem \
  --key-file=/etc/kubernetes/ssl/kubernetes-key.pem \
  --peer-cert-file=/etc/kubernetes/ssl/kubernetes.pem \
  --peer-key-file=/etc/kubernetes/ssl/kubernetes-key.pem \
  --trusted-ca-file=/etc/kubernetes/ssl/ca.pem \
  --peer-trusted-ca-file=/etc/kubernetes/ssl/ca.pem \
  --initial-advertise-peer-urls ${ETCD_INITIAL_ADVERTISE_PEER_URLS} \
  --listen-peer-urls ${ETCD_LISTEN_PEER_URLS} \
  --listen-client-urls ${ETCD_LISTEN_CLIENT_URLS},http://127.0.0.1:2379 \
  --advertise-client-urls ${ETCD_ADVERTISE_CLIENT_URLS} \
  --initial-cluster-token ${ETCD_INITIAL_CLUSTER_TOKEN} \
  --initial-cluster infra1=https://etce01:2380,infra2=https://etce02:2380,infra3=https://etce03:2380 \
  --initial-cluster-state new \
  --data-dir=${ETCD_DATA_DIR}
Restart=on-failure
RestartSec=5
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
</code></pre>
<ul>
<li>指定 <code>etcd</code> 的工作目录为 <code>/var/lib/etcd</code>，数据目录为 <code>/var/lib/etcd</code>，需在启动服务前创建这个目录，否则启动服务的时候会报错“Failed at step CHDIR spawning /usr/bin/etcd: No such file or directory”；</li>
<li>为了保证通信安全，需要指定 etcd 的公私钥(cert-file和key-file)、Peers 通信的公私钥和 CA 证书(peer-cert-file、peer-key-file、peer-trusted-ca-file)、客户端的CA证书（trusted-ca-file）；</li>
<li>创建 <code>kubernetes.pem</code> 证书时使用的 <code>kubernetes-csr.json</code> 文件的 <code>hosts</code> 字段<strong>包含所有 etcd 节点的IP</strong>，否则证书校验会出错；</li>
<li><code>--initial-cluster-state</code> 值为 <code>new</code> 时，<code>--name</code> 的参数值必须位于 <code>--initial-cluster</code> 列表中；</li>
</ul>
<p>完整 unit 文件见：<a href="https://jimmysong.io/kubernetes-handbook/systemd/etcd.service">etcd.service</a></p>
<p>环境变量配置文件<code>/etc/etcd/etcd.conf</code>。</p>
<pre><code class="language-ini"># [member]
ETCD_NAME=infra1
ETCD_DATA_DIR=&quot;/var/lib/etcd&quot;
ETCD_LISTEN_PEER_URLS=&quot;https://172.20.0.113:2380&quot;
ETCD_LISTEN_CLIENT_URLS=&quot;https://172.20.0.113:2379&quot;

#[cluster]
ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;https://172.20.0.113:2380&quot;
ETCD_INITIAL_CLUSTER_TOKEN=&quot;etcd-cluster&quot;
ETCD_ADVERTISE_CLIENT_URLS=&quot;https://172.20.0.113:2379&quot;
</code></pre>
<h2 id="--基操---1"><a class="header" href="#--基操---1">- 基操 -</a></h2>
<h2 id="强制删除"><a class="header" href="#强制删除">强制删除</a></h2>
<pre><code class="language-shell">kubectl get pod | grep Terminating | awk '{print $1}' | xargs kubectl delete pod --grace-period=0 --force
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>+++</p>
<p>title = &quot;prometheus&quot;
description = &quot;prometheus&quot;
tags = [&quot;it&quot;, &quot;cloud&quot;, &quot;prometheus&quot;]</p>
<p>+++</p>
<h1 id="prometheus"><a class="header" href="#prometheus">prometheus</a></h1>
<h2 id="cadvisor"><a class="header" href="#cadvisor">cAdvisor</a></h2>
<p>Kubelet 内置 cAdvisor，无需单独安装，可通过 https://127.0.0.1:10250/metrics/cadvisor 访问</p>
<pre><code class="language-shell"># 创建 ServiceAccount
kubectl create serviceaccount cadvisor-sa -n monitoring
# 创建 ClusterRoleBinding 并绑定 ClusterRole 到 ServiceAccount，这里直接使用 cluster-admin
kubectl create clusterrolebinding cadvisor-crb --clusterrole=cluster-admin --serviceaccount=monitoring:cadvisor-sa
# 查看 secret
kubectl get secret -n monitoring
kubectl describe secret cadvisor-sa-token-&lt;xxxxx&gt; -n monitoring
# 通过 http 访问
curl https://127.0.0.1:10250/metrics/cadvisor -k -H &quot;Authorization: Bearer &lt;token&gt;&quot;
</code></pre>
<h2 id="grafana"><a class="header" href="#grafana">Grafana</a></h2>
<blockquote>
<p><a href="https://grafana.com/docs/grafana/latest/setup-grafana/installation/kubernetes/">在 Kubernetes 上部署 Grafana</a>。</p>
<p><a href="http://www.mydlq.club/article/111/">Kubernetes 部署图表工具 Grafana</a>。</p>
</blockquote>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: grafana-pv
  labels:
    app: grafana
spec:
  storageClassName: grafana-storage
  capacity:
    storage: 5Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: &quot;/mnt/data/grafana&quot;
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: grafana-pvc
spec:
  selector:
    matchLabels:
      app: grafana
  storageClassName: grafana-storage
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
---
apiVersion: v1
kind: Service
metadata:
  name: grafana-svc
  labels:
    app: grafana
spec:
  type: NodePort
  ports:
  - name: http-grafana
    port: 3000
    nodePort: 30300
    targetPort: http-grafana
  selector:
    app: grafana
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: grafana
  labels:
    app: grafana
spec:
  selector:
    matchLabels:
      app: grafana
  template:
    metadata:
      labels:
        app: grafana
    spec:
      securityContext:
        fsGroup: 472
        supplementalGroups:
          - 0
      initContainers: # 初始化容器，用于修改挂载的存储的文件夹归属组与归属用户
        - name: init-file
          image: busybox:latest
          imagePullPolicy: IfNotPresent
          securityContext:
            runAsUser: 0
          command: ['chown', '-R', &quot;472:0&quot;, &quot;/var/lib/grafana&quot;]
          volumeMounts:
            - name: grafana-volume
              mountPath: &quot;/var/lib/grafana&quot;
              subPath: grafana-subpath
      containers:
        - name: grafana
          image: grafana/grafana:latest
          imagePullPolicy: IfNotPresent
          ports:
            - name: http-grafana
              containerPort: 3000
          readinessProbe: # 就绪探针
            failureThreshold: 3
            httpGet:
              path: /robots.txt
              port: 3000
              scheme: HTTP
            initialDelaySeconds: 10
            periodSeconds: 30
            successThreshold: 1
            timeoutSeconds: 2
          livenessProbe: # 存活探针
            failureThreshold: 3
            initialDelaySeconds: 30
            periodSeconds: 10
            successThreshold: 1
            tcpSocket:
              port: 3000
            timeoutSeconds: 1
          env: # 配置环境变量，设置 Grafana 的默认管理员用户名/密码
            - name: GF_SECURITY_ADMIN_USER
              value: &quot;admin&quot;
            - name: GF_SECURITY_ADMIN_PASSWORD
              value: &quot;admin&quot;
          resources:
            requests:
              cpu: 250m
              memory: 750Mi
          securityContext: # 容器安全策略，设置运行容器使用的归属组与用户
            runAsUser: 472
          volumeMounts:
            - name: grafana-volume
              mountPath: &quot;/var/lib/grafana&quot;
              subPath: grafana-subpath
      volumes:
        - name: grafana-volume
          persistentVolumeClaim:
            claimName: grafana-pvc
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>+++</p>
<p>title = &quot;Title.sub_title&quot;
description = &quot;Title sub_title quick_start&quot;
tags = [&quot;techn&quot;, &quot;computer&quot;, &quot;tagx&quot;, &quot;Title&quot;, &quot;_sub_title&quot;, &quot;__quick_start(content)&quot;]</p>
<p>+++</p>
<h1 id="sealos"><a class="header" href="#sealos">Sealos</a></h1>
<blockquote>
<p><a href="https://docs.sealos.io/zh-Hans/">官网</a>；<a href="https://docs.sealos.io/zh-Hans/docs/Intro">文档</a>；</p>
</blockquote>
<h1 id="快开-1"><a class="header" href="#快开-1">快开</a></h1>
<h2 id="安装-3"><a class="header" href="#安装-3">安装</a></h2>
<blockquote>
<p><a href="https://github.com/labring/sealos/releases">releases</a>；</p>
</blockquote>
<h3 id="二进制-1"><a class="header" href="#二进制-1">二进制</a></h3>
<pre><code class="language-shell">wget https://github.com/labring/sealos/releases/download/v4.1.7/sealos_4.1.7_linux_amd64.tar.gz

tar zxvf sealos_4.1.7_linux_amd64.tar.gz sealos &amp;&amp; mv sealos /usr/local/bin
</code></pre>
<h2 id="一键启动集群"><a class="header" href="#一键启动集群">一键启动集群</a></h2>
<blockquote>
<p><a href="https://docs.sealos.io/zh-Hans/docs/getting-started/kuberentes-life-cycle#%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85-kuberentes">集群安装 Kuberentes</a>；</p>
</blockquote>
<pre><code class="language-shell"># sealos 支持使用 containerd，使用前关闭docker 或者直接删除
$ systemctl disable --now docker
$ apt autoremove -y docker-ce

$ sealos run \
    labring/kubernetes:v1.25.0 \
    labring/helm:v3.8.2 \
    labring/calico:v3.24.1 \
    --masters 192.168.11.21,192.168.11.22,192.168.11.23 \
    --nodes 192.168.11.31,192.168.11.32 -p [your-ssh-passwd]
</code></pre>
<h1 id="常用"><a class="header" href="#常用">常用</a></h1>
<h3 id="使用-sealos-pull-从本地-dockerd-拉取镜像"><a class="header" href="#使用-sealos-pull-从本地-dockerd-拉取镜像">使用 sealos pull 从本地 dockerd 拉取镜像</a></h3>
<pre><code class="language-shell">$ sealos pull -h
...
Examples:
  sealos pull imagename
  sealos pull docker-daemon:imagename:imagetag
  sealos pull myregistry/myrepository/imagename:imagetag
...

$ sealos pull docker-daemon:labring/kubernetes:v1.26
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概念"><a class="header" href="#概念">概念</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>+++</p>
<p>title = &quot;Go&quot;
description = &quot;Go quick start&quot;
tags = [&quot;techn&quot;, &quot;computer&quot;, &quot;lang&quot;, &quot;Go&quot;, &quot;__quick_start&quot;]</p>
<p>+++</p>
<h1 id="go"><a class="header" href="#go">Go</a></h1>
<blockquote>
<p><a href="https://go.dev/">官网</a>；</p>
</blockquote>
<h2 id="go-1"><a class="header" href="#go-1">go</a></h2>
<blockquote>
<p><a href="https://go.dev/dl/">下载</a>：选择 <code>.linux-amd64.tar.gz</code>，Win 选择 <code>.windows-amd64.zip</code>；</p>
</blockquote>
<p>安装：解压即可</p>
<pre><code class="language-shell">tar -zxf gox.x.x.linux-amd64.tar.gz
</code></pre>
<p>环境变量：导入到系统环境变量，或者通过命令如 <code>go env -w GOROOT=</code> 写入</p>
<pre><code class="language-shell">export GOROOT=~/techn/computer/lang/go/go
export GOPATH=~/techn/computer/lang/go/path
# go install 安装的程序将保存到 $GOPATH/bin 下
export PATH=$PATH:$GOROOT/bin:$GOPATH/bin
# 代理：七牛云代理 goproxy.cn,direct；阿里代理 mirrors.aliyun.com/goproxy/
export GOPROXY=https://goproxy.cn,direct

# gomod：go 1.14 后默认开启
export GO111MODULE=on
# 私有库：设置私有库以跳过代理，比如公司使用 Gitlab、Gitee 等，多私有库逗号分隔
export GOPRIVATE=*.gitlab.com,*.gitee.com
# 用于验证包的有效性的服务地址，默认 sum.golang.org。有时候如 go mod vendor 会用到，无法连接则设置可连接的地址如 sum.golang.google.cn，这是专为国内提供的 sum 验证服务地址，或者直接关闭即可。私有仓库自动忽略验证
export GOSUMDB=off

# 如写入 ~/.bashrc 则刷新
source ~/.bashrc
</code></pre>
<h2 id="vs-code"><a class="header" href="#vs-code">vs code</a></h2>
<blockquote>
<p><a href="https://learn.microsoft.com/zh-cn/azure/developer/go/configure-visual-studio-code">为 Go 开发配置 Visual Studio Code</a>；</p>
</blockquote>
<ol>
<li><code>Ctrl+Shift+X</code> 打开扩展视图，搜索 <code>Go</code> 插件并安装</li>
<li><code>Ctrl+Shift+P</code> 打开 vs code 命令框，搜索 <code>Go: Install/Update tools</code> 并执行</li>
</ol>
<h2 id="hello-world"><a class="header" href="#hello-world">hello world</a></h2>
<p>helloworld.go</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	fmt.Println(&quot;Hello world!&quot;)
}
</code></pre>
<pre><code class="language-shell">$ go build -o ./helloworld-exec ./helloworld.go
$ ./helloworld-exec
Hello world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>+++</p>
<p>title = &quot;Git&quot;
description = &quot;Git&quot;
tags = [&quot;it&quot;, &quot;versioncontrol&quot;]</p>
<p>+++</p>
<h1 id="git"><a class="header" href="#git">Git</a></h1>
<blockquote>
<p><a href="https://git-scm.com/">官网</a>；</p>
</blockquote>
<h1 id="快开-2"><a class="header" href="#快开-2">快开</a></h1>
<h3 id="安装-4"><a class="header" href="#安装-4">安装</a></h3>
<blockquote>
<p><a href="https://git-scm.com/downloads">下载</a>；</p>
</blockquote>
<pre><code class="language-shell">apt install -y git
</code></pre>
<h3 id="配置-gitconfig"><a class="header" href="#配置-gitconfig">配置 gitconfig</a></h3>
<ul>
<li>仓库配置：<code>&lt;git-repository&gt;/.git/config</code>；</li>
<li>全局配置：<code>~/.gitconfig</code>；</li>
</ul>
<pre><code class="language-shell">cat &gt; ~/.gitconfig &lt;&lt;EOF
[core]
  # 关闭 quotepath，使中文不以八进制的字符编码显示，而是显示汉字
  quotepath=false
[user]
  name = LyonTianchi
  email = yuanyatianchi@gmail.com
[alias]
  st = status
  co = commit
  br = branch
  ch = checkout
  lg = log --graph --abbrev-commit --pretty=oneline
  rebh = git rebase -i HEAD~

[http]
  # http 代理
  proxy = http://&lt;proxy_server_ip&gt;:&lt;port&gt;
[https]
  # https 代理
  proxy = https://&lt;proxy_server_ip&gt;:&lt;port&gt;
  # 关闭证书校验
  sslVerify = false
EOF
# 查看
git config --list
</code></pre>
<h3 id="配置-gitignore"><a class="header" href="#配置-gitignore">配置 gitignore</a></h3>
<blockquote>
<p><a href="https://gist.github.com/octocat/9257657">.gitignore常用配置</a></p>
</blockquote>
<pre><code class="language-shell">.idea
</code></pre>
<h3 id="配置-github-加速"><a class="header" href="#配置-github-加速">配置 GitHub 加速</a></h3>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/248356236">让你访问github提速到2MB每秒</a> - 知乎..</p>
</blockquote>
<p>修改系统Hosts文件</p>
<pre><code class="language-host">cat &gt;&gt; /etc/hosts &lt;&lt; EOF


140.82.114.3   github.com
151.101.1.194  github.global.ssl.fastly.net
EOF
</code></pre>
<h1 id="基操-1"><a class="header" href="#基操-1">基操</a></h1>
<h3 id="rebase-pull"><a class="header" href="#rebase-pull">rebase pull</a></h3>
<p>避免产生 merge commit 记录</p>
<pre><code class="language-shell">git pull --rebase &lt;remote_name&gt; &lt;branch_name&gt;
</code></pre>
<h3 id="从-tag-切出分支"><a class="header" href="#从-tag-切出分支">从 tag 切出分支</a></h3>
<pre><code class="language-shell"></code></pre>
<h3 id="本地仓"><a class="header" href="#本地仓">本地仓</a></h3>
<h3 id="远程仓"><a class="header" href="#远程仓">远程仓</a></h3>
<pre><code class="language-shell"># 添加
git remote add &lt;origin_name&gt; &lt;git@x.x:x/x.git or https://x.x/x/x.git&gt;
# 删除

# 修改 url
git remote set-url &lt;origin_name&gt; &lt;git@x.x:x/x.git or https://x.x/x/x.git&gt;
# 查看
git remote
# 查看详细地址
git remote -v
</code></pre>
<ul>
<li>git remote remove <repositoryName>：删除远程的仓库的所有跟踪分支和配置设置</li>
<li>git remote rename <oldName> <newName>：重命名远程仓库在本地的简称</li>
<li>git remote show <repositoryName>：查看某个远程仓库的详细信息</li>
<li></li>
<li>git pull &lt;--rebase&gt; <repositoryName> <branchName> &lt;--allow-unrelated-histories&gt;：获取远程仓库项目文件
<ul>
<li>--allow-unrelated-histories：可选参数，可以合并两个独立启动仓库的历史</li>
</ul>
</li>
<li>提交到本地仓库后再推送到远程仓库</li>
<li>git push &lt;--set-upstream&gt; <repositoryName> <branchName>：推送到远程仓库</li>
<li>git remote rm：删除源(origin)</li>
</ul>
<h2 id="概念-1"><a class="header" href="#概念-1">概念</a></h2>
<ul>
<li>192.30.253.113 <a href="http://github.com">github.com</a>：修改host，提高GitHub的push和pull速度</li>
<li>命令行符号
<ul>
<li>[ ]：可写可不写</li>
<li>&lt;&gt;：必须写且需要用你自己的内容替换</li>
<li>{ }：必须在其中做出选择(选项之间以 | 隔开)</li>
</ul>
</li>
<li>结构
<ul>
<li>工作区</li>
<li>暂存区</li>
<li>本地库</li>
</ul>
</li>
</ul>
<p>https://www.yiibai.com/git</p>
<h2 id="操作"><a class="header" href="#操作">操作</a></h2>
<h3 id="推拉"><a class="header" href="#推拉">推拉</a></h3>
<h4 id="pull"><a class="header" href="#pull">pull</a></h4>
<ul>
<li><code>git pull [option]... &lt;远程主机名&gt; [branch-name]:[local-branch-name]</code>
<ul>
<li>-q：</li>
</ul>
</li>
</ul>
<pre><code class="language-shell">git pull origin remoteBranch:localBranch #获取远程origin上的分支branch1，并合并到本地的分支branch2
</code></pre>
<h4 id="push"><a class="header" href="#push">push</a></h4>
<h4 id="clone"><a class="header" href="#clone">clone</a></h4>
<p>clone。一般建议使用ssh，https有可能出一些不知所以的问题</p>
<pre><code class="language-shell">#ssh
git clone git@github.com:YuanyaTianchi/yuanyatianchi.git
#https
git clone https://github.com/YuanyaTianchi/yuanyatianchi.git
</code></pre>
<h3 id="版本"><a class="header" href="#版本">版本</a></h3>
<h4 id="log"><a class="header" href="#log">log</a></h4>
<ul>
<li>git log</li>
</ul>
<pre><code class="language-shell">git log --graph --abbrev-commit --pretty=oneline #图形化，hash值简化，单行
</code></pre>
<h4 id="revert"><a class="header" href="#revert">revert</a></h4>
<p>https://juejin.im/post/6844903614767448072</p>
<p>重提回退版本</p>
<pre><code class="language-shell">git revert -n xxxxxxx
git commit -m &quot;恢复到xxxxxxx版本&quot;
</code></pre>
<p>重提回退到指定版本，将此次回退作为新的提交重提，不删除该版本之后的提交。效果如下</p>
<pre><code class="language-shell">$ git log
xxxxxx3 第3次提交
xxxxxx2 第2次提交
xxxxxx1 第1次提交
$ git revert -n xxxxxx2
$ git commit -m &quot;恢复到第2次提交&quot;
$ git log
xxxxxx4 恢复到第2次提交
xxxxxx3 第3次提交
xxxxxx2 第2次提交
xxxxxx1 第1次提交
</code></pre>
<p>推荐使用，尤其是在将回退版本的后面的提交已推送到远程仓库时，revert 后也能简单直接提交</p>
<h4 id="reset"><a class="header" href="#reset">reset</a></h4>
<p>重设回退版本</p>
<pre><code class="language-shell"># HEAD 直接指向指定版本号
git reset --hard xxxxxxx
# 前移 HEAD，几个^表示前移几个版本
git reset --hard HEAD^
</code></pre>
<p>重设回退到指定版本，该版本之后的提交都将被删除。效果如下</p>
<pre><code class="language-shell">$ git log
xxxxxx3 第3次提交
xxxxxx2 第2次提交
xxxxxx1 第1次提交
$ git reset --hard HEAD^
$ git log
xxxxxx2 第2次提交
xxxxxx1 第1次提交
</code></pre>
<p>参数</p>
<ul>
<li>--soft： 回退后a分支修改的代码被保留并标记为add的状态（git status 是绿色的状态）</li>
<li>--mixed： 重置索引，但不重置工作树，更改后的文件标记为未提交（add）的状态。默认操作。</li>
<li>--hard： 重置索引和工作树，并且a分支修改的所有文件和中间的提交，没提交的代码都被丢弃了。</li>
<li>--merge： 和--hard类似，只不过如果在执行reset命令之前你有改动一些文件并且未提交，merge会保留你的这些修改，hard则不会。【注：如果你的这些修改add过或commit过，merge和hard都将删除你的提交】 </li>
<li>--keep： 和--hard类似，执行reset之前改动文件如果是a分支修改了的，会提示你修改了相同的文件，不能合并。如果不是a分支修改的文件，会移除缓存区。git status还是可以看到保持了这些修改。</li>
</ul>
<p>视情况使用，尤其不建议在将回退版本的后面的提交已推送到远程仓库时使用，否则本地版本落后于远程版本，只有强推才能覆盖推送，风险较大</p>
<h3 id="分支"><a class="header" href="#分支">分支</a></h3>
<h4 id="branch"><a class="header" href="#branch">branch</a></h4>
<h4 id="merge"><a class="header" href="#merge">merge</a></h4>
<p>我的需求在<code>feature/tianchi/xxx</code>分支上写完，要合并到<code>develop</code>里面，需要先选择到开发分支再去merge我的分支，会是<code>Merge branch 'feature/tianchi/xxx' into 'develop'</code>，千万<strong>不要</strong>在我的分支上去merge开发分支，会变成<code>Merge branch 'develop' into 'feature/tianchi/xxx'</code></p>
<pre><code class="language-shell">#正确操作如下
git pull origin develop:develop
git checkout develop
git merge feature/tianchi/xxx
</code></pre>
<h4 id="rebase"><a class="header" href="#rebase">rebase</a></h4>
<p>重定，变基(?)，指将分支移到一个新的基提交的过程</p>
<ul>
<li>rebase
<ul>
<li>-r：--rebase-merges简写。</li>
</ul>
</li>
</ul>
<pre><code class="language-shell">git rebase -r
</code></pre>
<h2 id="规范"><a class="header" href="#规范">规范</a></h2>
<p>https://www.jianshu.com/p/201bd81e7dc9?utm_source=oschina-app</p>
<h3 id="commit-message-的作用"><a class="header" href="#commit-message-的作用">Commit message 的作用</a></h3>
<p>提供更多的历史信息，方便快速浏览。</p>
<p>比如，下面的命令显示上次发布后的变动，每个commit占据一行。你只看行首，就知道某次 commit 的目的。</p>
<pre><code class="language-bash">$ git log &lt;last tag&gt; HEAD --pretty=format:%s
</code></pre>
<p>可以过滤某些commit（比如文档改动），便于快速查找信息</p>
<pre><code class="language-bash">$ git log &lt;last release&gt; HEAD --grep feature
</code></pre>
<p>可以直接从commit生成Change log。Change Log 是发布新版本时，用来说明与上一个版本差异的文档，详见后文。</p>
<p>其他优点</p>
<ul>
<li>可读性好，清晰，不必深入看代码即可了解当前commit的作用。</li>
<li>为 Code Reviewing做准备</li>
<li>方便跟踪工程历史</li>
<li>让其他的开发者在运行 git blame 的时候想跪谢</li>
<li>提高项目的整体质量，提高个人工程素质</li>
</ul>
<h3 id="commit-message-的格式"><a class="header" href="#commit-message-的格式">Commit message 的格式</a></h3>
<p>每次提交，Commit message 都包括三个部分：header，body 和 footer。</p>
<pre><code class="language-xml">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;
&lt;BLANK LINE&gt;
&lt;body&gt;
&lt;BLANK LINE&gt;
&lt;footer&gt;
</code></pre>
<p>其中，header 是必需的，body 和 footer 可以省略。
不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。</p>
<h4 id="header"><a class="header" href="#header">Header</a></h4>
<p>Header部分只有一行，包括三个字段：<code>type</code>（必需）、<code>scope</code>（可选）和<code>subject</code>（必需）。</p>
<h5 id="type"><a class="header" href="#type">type</a></h5>
<p>用于说明 commit 的类别，只允许使用下面7个标识。</p>
<ul>
<li>feat：新功能（feature）</li>
<li>fix：修补bug</li>
<li>docs：文档（documentation）</li>
<li>style： 格式（不影响代码运行的变动）</li>
<li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li>
<li>test：增加测试</li>
<li>chore：构建过程或辅助工具的变动</li>
</ul>
<p>如果type为<code>feat</code>和<code>fix</code>，则该 commit 将肯定出现在 Change log 之中。其他情况（<code>docs</code>、<code>chore</code>、<code>style</code>、<code>refactor</code>、<code>test</code>）由你决定，要不要放入 Change log，建议是不要。</p>
<h5 id="scope"><a class="header" href="#scope">scope</a></h5>
<p>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>
<p>例如在<code>Angular</code>，可以是<code>$location</code>, <code>$browser</code>, <code>$compile</code>, <code>$rootScope</code>, <code>ngHref</code>, <code>ngClick</code>, <code>ngView</code>等。</p>
<p>如果你的修改影响了不止一个<code>scope</code>，你可以使用<code>*</code>代替。</p>
<h5 id="subject"><a class="header" href="#subject">subject</a></h5>
<p><code>subject</code>是 commit 目的的简短描述，不超过50个字符。</p>
<p>其他注意事项：</p>
<ul>
<li>以动词开头，使用第一人称现在时，比如change，而不是changed或changes</li>
<li>第一个字母小写</li>
<li>结尾不加句号（.）</li>
</ul>
<h4 id="body"><a class="header" href="#body">Body</a></h4>
<p>Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。</p>
<pre><code class="language-php">More detailed explanatory text, if necessary.  Wrap it to 
about 72 characters or so. 

Further paragraphs come after blank lines.

- Bullet points are okay, too
- Use a hanging indent
</code></pre>
<p>有两个注意点:</p>
<ul>
<li>使用第一人称现在时，比如使用change而不是changed或changes。</li>
<li>永远别忘了第2行是空行</li>
<li>应该说明代码变动的动机，以及与以前行为的对比。</li>
</ul>
<h4 id="footer"><a class="header" href="#footer">Footer</a></h4>
<p>Footer 部分只用于以下两种情况：</p>
<h5 id="不兼容变动"><a class="header" href="#不兼容变动">不兼容变动</a></h5>
<p>如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。</p>
<pre><code class="language-go">BREAKING CHANGE: isolate scope bindings definition has changed.

    To migrate the code follow the example below:

    Before:

    scope: {
      myAttr: 'attribute',
    }

    After:

    scope: {
      myAttr: '@',
    }

    The removed `inject` wasn't generaly useful for directives so there should be no code using it.
</code></pre>
<h5 id="关闭-issue"><a class="header" href="#关闭-issue">关闭 Issue</a></h5>
<p>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。</p>
<pre><code class="language-bash">Closes #234
</code></pre>
<h4 id="revert-1"><a class="header" href="#revert-1">Revert</a></h4>
<p>还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。</p>
<pre><code class="language-csharp">revert: feat(pencil): add 'graphiteWidth' option

This reverts commit 667ecc1654a317a13331b17617d973392f415f02.
</code></pre>
<p>Body部分的格式是固定的，必须写成<code>This reverts commit &lt;hash&gt;</code>.，其中的hash是被撤销 commit 的 SHA 标识符。</p>
<p>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。</p>
<h3 id="commitizen"><a class="header" href="#commitizen">Commitizen</a></h3>
<p>可以使用典型的git工作流程或通过使用CLI向导<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fcommitizen%2Fcz-cli">Commitizen</a>来添加提交消息格式。</p>
<h3 id="安装-5"><a class="header" href="#安装-5">安装</a></h3>
<pre><code class="language-undefined">npm install -g commitizen
</code></pre>
<p>然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。</p>
<pre><code class="language-kotlin">commitizen init cz-conventional-changelog --save --save-exact
</code></pre>
<p>以后，凡是用到<code>git commit</code>命令，一律改为使用<code>git cz</code>。这时，就会出现选项，用来生成符合格式的 Commit message。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3827973-39053e8f0259dfda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/557/format/webp" alt="img" /></p>
<p>5.png</p>
<h3 id="validate-commit-msg"><a class="header" href="#validate-commit-msg">validate-commit-msg</a></h3>
<p><a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fkentcdodds%2Fvalidate-commit-msg">validate-commit-msg</a> 用于检查项目的 Commit message 是否符合Angular规范。</p>
<p>该包提供了使用githooks来校验<code>commit message</code>的一些二进制文件。在这里，我推荐使用<a href="https://link.jianshu.com?t=http%3A%2F%2Fnpm.im%2Fhusky">husky</a>，只需要添加<code>&quot;commitmsg&quot;: &quot;validate-commit-msg&quot;</code>到你的<code>package.json</code>中的<code>nam scripts</code>即可.</p>
<p>当然，你还可以通过定义配置文件<code>.vcmrc</code>来自定义校验格式。详细使用请见文档 <a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fkentcdodds%2Fvalidate-commit-msg">validate-commit-msg</a></p>
<h3 id="生成-change-log"><a class="header" href="#生成-change-log">生成 Change log</a></h3>
<p>如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成。生成的文档包括以下三个部分：</p>
<ul>
<li>New features</li>
<li>Bug fixes</li>
<li>Breaking changes.</li>
</ul>
<p>每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。</p>
<p><a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fajoslin%2Fconventional-changelog">conventional-changelog</a> 就是生成 Change log 的工具，运行下面的命令即可。</p>
<pre><code class="language-ruby">$ npm install -g conventional-changelog
$ cd my-project
$ conventional-changelog -p angular -i CHANGELOG.md -w
</code></pre>
<h2 id="本地库操作"><a class="header" href="#本地库操作">本地库操作</a></h2>
<h3 id="本地库初始化"><a class="header" href="#本地库初始化">本地库初始化</a></h3>
<ol>
<li>在cmd中进到项目目录下</li>
<li>git init：本地库初始化。生成一个.git目录，该目录中存放的是本地库相关的子目录和文件</li>
<li>设置签名：username和email用于区分不同开发人员的身份。这里设置的签名和登录远程库(代码托管中心)的账号密码没有任何关系。默认项目级别(仓库级别)仅在当前本地库范围内生效，项目级别信息保存在.git/config下。系统用户级别：指定--global，系统用户级别信息保存在系统用户家目录下的.config文件中。项目级别优先于系统用户级别。至少设置一个
<ol>
<li>git config [--global] user.name <username>：设置用户名</li>
<li>git config [--global] user.email <email>：设置Email地址</li>
<li>cat .git/cogfig：查看本地库配置文件</li>
</ol>
</li>
</ol>
<h3 id="基本操作"><a class="header" href="#基本操作">基本操作</a></h3>
<ul>
<li>git help &lt;命令&gt;：查看该命令文档</li>
</ul>
<h3 id="文件操作"><a class="header" href="#文件操作">文件操作</a></h3>
<ul>
<li>git status：查看状态。
<ul>
<li>on branch master表示在主分支上，no commits yet表示无提交内容</li>
<li>红色文件表示未添加到暂存区中，绿色表示已添加到暂存区中</li>
</ul>
</li>
<li>git add <filename>：将文件从工作区添加到暂存区。unstage表示从暂存区中移除</li>
<li>git rm <filename>：从暂存区删除</li>
<li>git commit [-m <description>] [-a] <filename>：将文件从暂存区中提交到本地库，添加后会进入vim，写本次提交描述内容
<ul>
<li>-m：无需编辑vim，直接在后面写入描述内容，；</li>
<li>-a：无需git add操作，直接添加&amp;提交，不过就不存在暂存区的撤销操作时间了</li>
<li>结果内容：
<ul>
<li>root-commit：表示根提交(第一次提交)</li>
<li>数字编号：暂时粗略认为是本次提交的版本号</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="版本移动"><a class="header" href="#版本移动">版本移动</a></h3>
<ul>
<li>git log [--pretty={oneline}] [--oneline]：查看日志版本，只显示当前及以前版本。这里有2个版本的记录，这里hash值表示该次提交的索引，HEAD是指向当前版本的指针
<ul>
<li>--pretty=oneline将每个版本只以一行显示</li>
<li>--oneline不仅一行显示还只显示部分hash值</li>
</ul>
</li>
<li>git reflog：查看日志，显示前后所有版本以及版本移动
<ul>
<li>HEAD@{n}表示移动到对应版本指针需要移动n步</li>
</ul>
</li>
<li>git reset --{hard/mixed/soft} HEAD <headHash>：索引移动(推荐)
<ul>
<li>--mixed在本地枯移动HEAD指针，重置暂存区，默认策略</li>
<li>--hard在本地库移动HEAD指针，重置暂存区，重置工作区（会删除文件），</li>
<li>--soft仅在本地库移动HEAD指针</li>
</ul>
</li>
<li>git reset  --hard HEAD^^^：^移动，只能后退，3个^即表示后退3个版本</li>
<li>git reset  --hard HEAD~<n>：~移动，只能后退，n即表示后退n个版本</li>
<li>git checkout <versionNumber> <filename>：选择某个版本的文件到工作区</li>
<li>git diff [HEAD] [<filename>]：在修改工作区文件之后
<ul>
<li>无HEAD：表示工作区与暂存区的该文件比较，显示文件变化</li>
<li>有HEAD：表示工作区与本地库的该文件比较，显示文件变化</li>
<li>无<filename>：将比较当前工作区中的所有文件</li>
</ul>
</li>
</ul>
<h3 id="分支管理"><a class="header" href="#分支管理">分支管理</a></h3>
<p>分支：在版本控制过程中，使用多条线同时推进多个任务。同时并行推进多个功能开发，提高开发效率。各个分支在开发过程中，如果一个分支开发失败，不会对其他分支有任何影响，删除重新开始即可</p>
<ul>
<li>git branch [-v] [-a]：
<ul>
<li>-v：显示版本号</li>
<li>-a：包括远程分支</li>
</ul>
</li>
<li>git branch <branchName>：创建分支</li>
<li>git branch -D <branchName>：删除分支</li>
<li>git checkout <branchName>：切换分支</li>
<li>git merge <branchName>：合并某分支，将当前所在分支与某分支合并。
<ul>
<li>分支合并冲突：当两个分支都修改了同一个文件中同一行的内容，合并时取舍哪个分支的该处内容git是无法判断的，只需要vim手动编辑后再添加提交(提交不能带文件名)即可</li>
</ul>
</li>
</ul>
<h3 id="clean"><a class="header" href="#clean">clean</a></h3>
<pre><code class="language-sh">git clean -f
git clean -d -fx #强制删除Untracked files
</code></pre>
<h2 id="合并工程"><a class="header" href="#合并工程">合并工程</a></h2>
<ul>
<li>假如有master、test、develop分支，现在有一个需求从master切出来一个demand，需求子任务从demand切出来一个demand/child：<code>git pull origin demand:demand</code>，<code>git ch demand</code>，<code>git ch -b demand/child</code>
<ul>
<li>任务开发完后，需要merge demand/child into develop。切到任务分支<code>git ch demand/child</code>，拉取develop分支<code>git pull origin develop:develop</code>，会有很多改变，会因版本而merge develop into demand/child的相关提示，中止merge<code>git merge --abort</code>，不能让merge develop into demand/child发生，这反了，切到dev<code>git ch develop</code>，merge demand/child into develop<code>git merge demand/child</code>，编译检查<code>go build xxx</code>，提交之前再检查版本<code>git lg -5</code>是否是merge demand/child into develop，推送<code>git push origin develop:develop</code></li>
<li>develop环境调试完，需要merge demand/child into demand。切到任务分支<code>git ch demand/child</code>，直接拉取远程demand并合并到demand/child<code>git pull origin demand:demand/child</code>，因为demand本来就是demand/child的源，所以直接合并之后要再合并回去<code>git push origin demand/child:demand</code>，不会有什么影响，也能将其他人的更改合并进来，如果develop也这么做的话，会将demand/child不需要的develop的内容合并进来，那就只有回退版本再重新操作了</li>
</ul>
</li>
</ul>
<h2 id="git-flow"><a class="header" href="#git-flow">git flow</a></h2>
<p>开发</p>
<pre><code class="language-shell"># 创建 feature/&lt;brance_name&gt; 分支
git flow feature start brance_name
# 合并 feature/&lt;brance_name&gt; 到 develop，删除 feature/&lt;brance_name&gt;，并切换到 develop
git flow feature finish brance_name
</code></pre>
<p>发布</p>
<pre><code class="language-shell"># 创建 release-1.1.1 分支
git flow release start 1.1.1
# 合并 release-1.1.1 到 master，使用 release-1.1.1 分支名称打 tag，回合 release-1.1.1 到 develop，删除 release-1.1.1，并切换到 develop
git flow release finish 1.1.1
</code></pre>
<p>紧急修复</p>
<pre><code class="language-shell"># 创建 hotfix-1.1.1 分支
git flow hotfix start 1.1.1
# 合并 hotfix-1.1.1 到 master；
# 如果存在 release-1.1.1，则合并 hotfix-1.1.1 到 release-1.1.1，否则合并 hotfix-1.1.1 到 develop；
# 删除 hotfix-1.1.1，并切换到 develop
git flow release finish 1.1.1
</code></pre>
<h1 id="github"><a class="header" href="#github">GitHub</a></h1>
<h3 id="ssh"><a class="header" href="#ssh">ssh</a></h3>
<pre><code class="language-shell"># ed25519算法
ssh-keygen -t ed25519 -C &quot;yuanyatianchi@example.com&quot;
# rsa算法
ssh-keygen -t rsa -b 4096 -C &quot;yuanyatianchi@gmail.com&quot;
</code></pre>
<h3 id="搜索"><a class="header" href="#搜索">搜索</a></h3>
<p>匹配语法。</p>
<ul>
<li>模糊匹配：<code>in:&lt;field&gt; &lt;xxx&gt;</code>，表示匹配某字段中包含 xxx 字符串
<ul>
<li>name：<code>in:name xxx</code></li>
<li>readme：<code>in:readme xxx</code></li>
<li>descriptio：<code>in:description xxx</code></li>
</ul>
</li>
<li>数字
<ul>
<li>stars:&gt;1000 或 star&gt;1000</li>
<li>forks:&gt;1000 或 fork&gt;1000</li>
</ul>
</li>
<li>日期
<ul>
<li>pushed:&gt;2019-04-15，表示2019年4月15日后有更新的</li>
</ul>
</li>
<li>语言
<ul>
<li>language:go，表示 go 语言项目</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
