<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>YuanyaDocs</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Root</a></li><li class="chapter-item expanded "><a href="模板.html"><strong aria-hidden="true">1.</strong> 模板</a></li><li class="chapter-item expanded "><a href="番.html"><strong aria-hidden="true">2.</strong> 番</a></li><li class="chapter-item expanded affix "><li class="part-title">计</li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> 语言</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="计/语言/Go.html"><strong aria-hidden="true">3.1.</strong> Go</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 云原生</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="计/云原生/Kubernetes.html"><strong aria-hidden="true">4.1.</strong> Kuberntes</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 操作系统</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Linux</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="计/操作系统/Linux.eBPF.html"><strong aria-hidden="true">5.1.1.</strong> Linux.eBPF</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">YuanyaDocs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h3 id="hi-there-"><a class="header" href="#hi-there-">Hi there 👋</a></h3>
<!--
**YuanyaTianchi/yuanyatianchi** is a ✨ _special_ ✨ repository because its `README.md` (this file) appears on your GitHub profile.

Here are some ideas to get you started:

- 🔭 I’m currently working on ...
- 🌱 I’m currently learning ...
- 👯 I’m looking to collaborate on ...
- 🤔 I’m looking for help with ...
- 💬 Ask me about ...
- 📫 How to reach me: ...
- 😄 Pronouns: ...
- ⚡ Fun fact: ...
-->
<p><img src="./img/%E6%A0%88.svg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>+++</p>
<p>title = &quot;Title&quot;
description = &quot;it.tag.tag.Title&quot;
tags = [&quot;it&quot;,&quot;tag&quot;,&quot;tag&quot;]</p>
<p>+++</p>
<h1 id="title"><a class="header" href="#title">Title</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="追番"><a class="header" href="#追番">追番</a></h1>
<h2 id="2022"><a class="header" href="#2022">2022</a></h2>
<p>【202301】【日】fate/strangeFake-0</p>
<p>【202301】【日】high card-周一0</p>
<p>【202211】【日】阿尔斯的巨兽-0</p>
<p>【202211】【日】别当欧尼酱了-0</p>
<p>【202301】【日】冰海战记2-0</p>
<p>【202301】【日】大雪海的凯纳-0</p>
<p>【202301】【日】东京复仇者</p>
<p>【202301】【日】辉夜大小姐想让我告白 初吻不会结束-0</p>
<p>【202301】【日】间谍教室-0</p>
<p>【202301】【日】尼尔：机械纪元-0</p>
<p>【202301】【日】七大罪 怨嗟的爱丁堡 前篇-0</p>
<p>【202301】【日】枪神</p>
<p>【202301】【日】<a href="https://www.yhdmp.cc/showp/23092.html">文豪野犬4</a>-周三0</p>
<p>【202301】【日】虚构推理2-0</p>
<p>伊藤润二2-0</p>
<p>【202301】【日】因为太怕痛就全点防御力了</p>
<p>【202211】【日】<a href="https://www.yhdmp.cc/showp/22099.html">JOJO的奇妙冒险6石之海Part3</a></p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/22465.html"><strong>4个人各自有着自己的秘密</strong></a></p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/22508.html">飙速宅男5</a>-周一10</p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/21333.html">电锯人</a></p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/22203.html">孤独摇滚</a></p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/22322.html">黄金神威4</a>-周一0</p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/22266.html">机动战士高达 水星的魔女</a>-周日0</p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/22518.html">间谍过家家 Part2</a></p>
<p>【202210】【日】<a href="https://www.bilibili.com/bangumi/media/md28339709">灵能百分百3</a></p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/22473.html">名侦探柯南 犯人犯泽先生</a>-周二0</p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/22438.html"><strong>秋叶原女仆战争</strong></a></p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/22209.html">死神 千年血战篇</a>-周二0</p>
<p>【202210】【日】<a href="https://www.yhdmp.cc/showp/22536.html">银河英雄传说 Die Neue These 策谋</a>-周五0</p>
<p>【202209】【日】<a href="https://www.yhdmp.cc/showp/22524.html"><strong>赛博朋克：边缘行者</strong></a></p>
<p>【202207】【日】<a href="https://www.yhdmp.cc/showp/22099.html">JOJO的奇妙冒险6石之海Part2</a></p>
<p>【202207】【日】<a href="https://www.yhdmp.cc/showp/22224.html">Lycoris Recoil</a></p>
<p>【202207】【日】<a href="https://www.yhdmp.cc/showp/21285.html">Overlord4</a></p>
<p>【202207】【日】<a href="https://www.yhdmp.cc/showp/22332.html">RWBY-冰雪帝国</a>-周日4</p>
<p>【202207】【日】<a href="https://www.yhdmp.cc/showp/22294.html">欢迎来到实力至上主义教室2</a></p>
<p>【202207】【日】<a href="https://www.yhdmp.cc/showp/22170.html">狂赌之渊双</a></p>
<p>【202207】【日】<a href="https://www.yhdmp.cc/showp/20181.html"><strong>来自深渊2 烈日的黄金乡</strong></a></p>
<p>【202207】【日】<a href="https://www.yhdmp.cc/showp/22216.html">异世界舅舅</a>-周三9</p>
<p>【202207】【日】<a href="https://www.yhdmp.cc/showp/22084.html">租界女友2</a>-周六18</p>
<p>【202201】【日】<a href="https://www.yhdmp.cc/showp/21157.html">处刑少女的生存之道</a></p>
<p>【202201】【日】<a href="https://www.yhdmp.cc/showp/21104.html"><strong>辉夜大小姐想让我告白3</strong></a></p>
<p>【202201】【日】<a href="https://www.yhdmp.cc/showp/22164.html"><strong>间谍过家家</strong></a></p>
<p>【202201】【日】<a href="https://www.bilibili.com/bangumi/play/ss39725/">理科生坠入情网，故尝试证明2</a>-周六4</p>
<p>【202201】【日】<a href="https://www.bilibili.com/bangumi/play/ss41418/"><strong>恋爱要在征服世界后</strong></a></p>
<p>【202201】【日】<a href="https://www.bilibili.com/bangumi/play/ep478912">恋爱游戏世界对路人角色很不友好</a></p>
<p>【202201】【日】<a href="https://www.yhdmp.cc/showp/22172.html">派对浪客诸葛孔明</a></p>
<p>【202201】【日】<a href="https://www.yhdmp.cc/showp/22165.html">朋友游戏1</a></p>
<p>【202201】【日】<a href="https://www.yhdmp.cc/showp/22162.html"><strong>青之芦苇</strong></a></p>
<p>【202201】【日】<a href="https://www.yhdmp.cc/showp/22174.html">夏日重现</a></p>
<p>【202201】【日】鬼灭之刃3游郭篇</p>
<p>【202201】【日】<strong>进击的巨人最终季part2</strong></p>
<p>【202201】【日】天才王子的赤字国家振兴术</p>
<p>【202201】【日】<strong>与变成了异世界美少女的好友一起冒险</strong></p>
<h2 id="2021"><a class="header" href="#2021">2021</a></h2>
<p>【202110】【日】jojo的奇妙冒险.石之海</p>
<p>【202110】【日】铂金终局</p>
<p>【202110】【日】范马刃牙</p>
<p>【202110】【日】国王排名</p>
<p>【202101】【日】<a href="https://www.agemys.cc/detail/20210314">境界触发者3</a>-0</p>
<p>【202110】【日】魔法使的新娘2-1</p>
<p>【202110】【日】七原罪剧场版 被光诅咒的众人</p>
<p>【202110】【日】<strong>无职转生1part2</strong></p>
<p>【202110】【日】<strong>英雄联盟：双城之战</strong></p>
<p>【202107】【日】超龙珠英雄BM-17</p>
<p>【202107】【日】歌剧少女-0</p>
<p>【202107】【日】<strong>关于我转生变成史莱姆这件事3</strong></p>
<p>【202107】【日】寒蝉鸣泣之时 卒-0</p>
<p>【202107】【日】见面5秒开始战斗</p>
<p>【202107】【日】精灵幻想记</p>
<p>【202107】【日】<strong>平稳世代的韦驮天们</strong></p>
<p>【202107】【日】奇巧计程车</p>
<p>【202107】【日】小林家的龙女仆S</p>
<p>【202107】【日】异世界迷宫黑心企业</p>
<p>【202104】【日】MARS RED-1</p>
<p>【202104】【日】MegaloBOX2</p>
<p>【202104】【日】极道主夫-5</p>
<p>【202104】【日】如果究极进化的完全沉浸RPG比现实更垃圾的话1</p>
<p>【202104】【日】入间同学入魔了2-0</p>
<p>【202104】【日】战斗员派遣中</p>
<p>【202104】【日】转生史莱姆日记-2</p>
<p>【202101】【国】<strong>刺客伍六七之玄武国篇</strong></p>
<p>【202101】【日】BackArrow</p>
<p>【202101】【日】从零开始的异世界生活2.2</p>
<p>【202101】【日】动物狂想曲2</p>
<p>【202101】【日】工作细胞2</p>
<p>【202101】【日】工作细胞Black</p>
<p>【202101】【日】好比是最终迷宫前的少年到新手村生活一般的故事</p>
<p>【202101】【日】<strong>关于我转生变成史莱姆这件事2</strong></p>
<p>【202101】【日】回复术士的重启人生</p>
<p>【202101】【日】记录的地平线3</p>
<p>【202101】【日】<strong>进击的巨人最终季part1</strong></p>
<p>【202101】【日】境界触发者2</p>
<p>【202101】【日】堀与宫村</p>
<p>【202101】【日】七大罪4-14</p>
<p>【202101】【日】弱势角色友崎君</p>
<p>【202101】【日】赛马娘-5</p>
<p>【202101】【日】天空侵犯1</p>
<p>【202101】【日】<strong>无职转生1part1</strong></p>
<p>【202101】【日】摇曳露营2-2</p>
<p>【202101】【日】约定的梦幻岛2</p>
<p>【202101】【日】<strong>转生成蜘蛛又怎样</strong></p>
<h2 id="2020"><a class="header" href="#2020">2020</a></h2>
<p>【202010】【日】成神之日</p>
<p>【202010】【日】鬼灭之刃剧场版 无限列车篇</p>
<p>【202010】【日】魔女之旅1</p>
<p>【202010】【日】全员恶玉</p>
<p>【202010】【日】*在魔王城说晚安</p>
<p>【202010】【日】*咒术回战1</p>
<p>【202007】【国】雾山五行1</p>
<p>【202007】【日】从零开始的异世界生活2.1</p>
<p>【202007】【日】大欺诈师</p>
<p>【202007】【日】刀剑神域3 Alicization3-12</p>
<p>【202007】【日】高校之神-6</p>
<p>【202007】【日】没落要塞/DECA-DENCE</p>
<p>【202007】【日】刃牙2</p>
<p>【202007】【日】天晴烂漫</p>
<p>【202007】【日】我的青春恋爱物语果然有问题3-7</p>
<p>【202007】【日】炎炎消防队2</p>
<p>【202007】【日】租界女友1</p>
<p>【202004】【日】食戟之灵5豪之皿-0</p>
<p>【202004】【日】隐瞒之事</p>
<p>【202004】【日】格莱普尼尔1</p>
<p>【202004】【日】辉夜大小姐想让我告白2</p>
<p>【202004】【日】转生成为了只有乙女游戏破灭Flag的邪恶大小姐</p>
<p>【202004】【日】神之塔1</p>
<p>【202004】【日】动物新世代/BNA</p>
<p>【202001】【日】因为太怕痛就全点防御力了</p>
<p>【202001】【日】异种族风俗娘评鉴指南</p>
<p>【202001】【日】异度入侵ID:INVADED</p>
<p>【202001】【日】虚构推理</p>
<p>【202001】【日】齐木楠雄的灾难 始动篇</p>
<p>【202001】【日】某科学的超电磁炮T-15</p>
<p>【202001】【日】猎龙飞船</p>
<p>【202001】【日】理科生坠入情网，故尝试证明</p>
<p>【202001】【日】达尔文游戏</p>
<p>【202001】【日】<a href="https://www.agemys.cc/detail/20200054"><strong>来自深渊 深沉灵魂的黎明</strong></a></p>
<h2 id="2019"><a class="header" href="#2019">2019</a></h2>
<p>【201910】【日】这个勇者明明超强却过分慎重</p>
<p>【201910】【日】心理测量者3</p>
<p>【201910】【日】我不是说了能力要平均值么</p>
<p>【201910】【日】食戟之灵4神之皿-0</p>
<p>【201910】【日】入间同学入魔了</p>
<p>【201910】【日】七大罪3</p>
<p>【201910】【日】动物狂想曲BEASTARS1</p>
<p>【201910】【日】刀剑神域3 Alicization2</p>
<p>【201910】【国】伍六七之最强发型师</p>
<p>【201908】【日】为美好的世界献上祝福！红传说</p>
<p>【201907】【日】炎炎消防队1</p>
<p>【201907】【日】女高中生的虚度日常</p>
<p>【201907】【日】流汗吧！健身少女</p>
<p>【201907】【日】fate 君主·埃尔梅罗二世事件簿 魔眼收集列车 Grace note</p>
<p>【201907】【日】冰寒战记</p>
<p>【201907】【日】在地下城寻求邂逅是否搞错了什么2-8</p>
<p>【201905】【日】*普罗米亚</p>
<p>【201904】【日】异世界四重奏2</p>
<p>【201904】【日】一拳超人2</p>
<p>【201904】【日】一个人的OO小日子</p>
<p>【201904】【日】贤者之孙</p>
<p>【201904】【日】文豪野犬3</p>
<p>【201904】【日】进击的巨人3</p>
<p>【201904】【日】鬼灭之刃</p>
<p>【201904】【日】CAROLE &amp; TUESDAY</p>
<p>【201901】【日】约定的梦幻岛</p>
<p>【201901】【日】灵能百分百2</p>
<p>【201901】【日】狂赌之渊2</p>
<p>【201901】【日】辉夜大小姐想让我告白</p>
<p>【201901】【日】多罗罗</p>
<p>【201901】【日】盾之勇者成名录</p>
<p>【201901】【日】不吉波普不笑</p>
<h2 id="2018"><a class="header" href="#2018">2018</a></h2>
<p>【201810】【日】佐贺偶像是传奇</p>
<p>【201810】【日】终将成为你</p>
<p>【201810】【日】青春猪头少年不会梦到兔女郎学姐</p>
<p>【201810】【日】强风吹拂</p>
<p>【201810】【日】关于我转生变成史莱姆这件事</p>
<p>【201810】【日】哥布林杀手</p>
<p>【201810】【日】刀剑神域3 Alicization1</p>
<p>【201810】【日】JOJO的奇妙冒险5黄金之风</p>
<p>【201807】【日】游戏3人娘</p>
<p>【201807】【日】异世界魔王与召唤少女的奴隶魔术</p>
<p>【201807】【日】杀戮天使</p>
<p>【201807】【日】刃牙</p>
<p>【201807】【日】轻羽飞扬</p>
<p>【201807】【日】进击的巨人3</p>
<p>【201807】【日】工作细胞</p>
<p>【201807】【日】碧蓝之海</p>
<p>【201807】【日】Overlord2</p>
<p>【201804】【日】宅男腐女恋爱真难</p>
<p>【201804】【日】我的英雄学院3</p>
<p>【201804】【日】食戟之灵ova</p>
<p>【201804】【日】赛马娘</p>
<p>【201804】【日】奴隶区</p>
<p>【201804】【日】魔性之线</p>
<p>【201804】【日】魔法少女网站</p>
<p>【201804】【日】魔法少女俺</p>
<p>【201804】【日】黑社会的超能力女儿</p>
<p>【201804】【日】苍天之拳1</p>
<p>【201804】【日】MegaloBOX1</p>
<p>【201801】【日】紫罗兰永恒花园</p>
<p>【201801】【日】游戏人生剧场版</p>
<p>【201801】【日】摇曳露营</p>
<p>【201801】【日】牙斗兽娘</p>
<p>【201801】【日】齐木楠雄的灾难2</p>
<p>【201801】【日】七大罪2</p>
<p>【201801】【日】龙王的工作</p>
<p>【201801】【日】刻刻-时间暂停</p>
<p>【201801】【日】博多豚骨拉面</p>
<p>【201801】【日】比宇宙更遥远的地方</p>
<p>【201801】【日】OVERLORD</p>
<p>【201801】【日】darling</p>
<p>【201801】【日】Citrus～柑橘味香气～</p>
<p>【201801】【日】B：彼之初</p>
<p>【201801】【日】A.I.C.O. Incarnation</p>
<h2 id="2017"><a class="header" href="#2017">2017</a></h2>
<p>【201710】【日】悠久持有者! 魔法老师2</p>
<p>【201710】【日】血界战线2</p>
<p>【201710】【日】食戟之灵3餐之皿</p>
<p>【201710】【日】少女终末旅行</p>
<p>【201710】【日】奇诺之旅2</p>
<p>【201710】【日】魔法使的新娘</p>
<p>【201710】【日】国王游戏</p>
<p>【201710】【日】关于我女友是一个正经的碧池这件事</p>
<p>【201710】【日】干物妹小埋2</p>
<p>【201710】【日】调教咖啡厅</p>
<p>【201710】【日】*宝石之国</p>
<p>【201710】【日】fate stay night heaven's feel 剧场版</p>
<p>【201707】【日】NewGame2</p>
<p>【201707】【日】笨女孩</p>
<p>【201707】【日】带着智慧型手机闯荡异世界</p>
<p>【201707】【日】欢迎来到实力至上主义教室1</p>
<p>【201707】【日】狂赌之渊1</p>
<p>【201707】【日】<a href="https://www.agemys.cc/detail/20170051"><strong>来自深渊1</strong></a></p>
<p>【201707】【日】恋爱禁止的世界</p>
<p>【201707】【日】骑士与魔法</p>
<p>【201704】【日】樱花任务</p>
<p>【201704】【日】武装少女</p>
<p>【201704】【日】我的英雄学院2</p>
<p>【201704】【日】我的妹妹是黄漫老师</p>
<p>【201704】【日】末日时在做什么？有没有空？可以来拯救吗？</p>
<p>【201704】【日】路人女主的养成方式2</p>
<p>【201704】【日】零之魔法书</p>
<p>【201704】【日】进击的巨人2</p>
<p>【201704】【日】Re:Creators</p>
<p>【201701】【日】ACCA13区监察课</p>
<p>【201701】【日】Hand Shakers</p>
<p>【201701】【日】热诚传说2</p>
<p>【201701】【日】飙速宅男3</p>
<p>【201701】【日】珈百璃的堕落</p>
<p>【201701】【日】兽娘动物园</p>
<p>【201701】【日】兽娘动物园</p>
<p>【201701】【日】为美好的世界献上祝福2</p>
<p>【201701】【日】小林家的龙女仆</p>
<p>【201701】【日】<strong>小魔女学园</strong></p>
<p>【201701】【日】亚人酱有话要说</p>
<p>【201701】【日】<strong>幼女战记</strong></p>
<p>【201701】【日】政宗君的复仇</p>
<h2 id="2016"><a class="header" href="#2016">2016</a></h2>
<p>【201610】【日】我太受欢迎了该怎么办</p>
<p>【201610】【日】我的老婆是学生会长2</p>
<p>【201610】【日】文豪野犬2</p>
<p>【201610】【日】少女编号</p>
<p>【201610】【日】漂流武士</p>
<p>【201610】【日】魔法少女育成计划</p>
<p>【201610】【日】超自然9人组</p>
<p>【201610】【日】冰上的尤里</p>
<p>【201610】【国】亚人2</p>
<p>【201610】【国】凸变英雄</p>
<p>【201607】【日】这个美术社大有问题！</p>
<p>【201607】【日】食戟之灵2贰之皿</p>
<p>【201607】【日】热诚传说1</p>
<p>【201607】【日】齐木楠雄的灾难1</p>
<p>【201607】【日】灵能百分百1</p>
<p>【201607】【日】弹丸论破3</p>
<p>【201607】【日】NEW GAME1</p>
<p>【201607】【国】一人之下</p>
<p>【201604】【日】在下坂本，有何贵干？</p>
<p>【201604】【日】线上游戏的老婆不可能是女生？</p>
<p>【201604】【日】我的英雄学院1</p>
<p>【201604】【日】文豪野犬1</p>
<p>【201604】【日】甲铁城的卡巴内瑞</p>
<p>【201604】【日】Re：从零开始的异界生活</p>
<p>【201604】【日】jojo的奇妙冒险4 不灭钻石</p>
<p>【201601】【日】只有我不在的街道</p>
<p>【201601】【日】无头骑士异闻录 x2 结</p>
<p>【201601】【日】为美好的世界献上祝福1</p>
<p>【201601】【日】灰与幻想的格林姆迦尔</p>
<p>【201601】【国】亚人1</p>
<h2 id="2015"><a class="header" href="#2015">2015</a></h2>
<p>【201510】【日】樱子小姐的脚下埋着尸体</p>
<p>【201510】【日】野良神 ARAGOTO</p>
<p>【201510】【日】我被绑架到贵族女校当庶民样本</p>
<p>【201507】【日】学园孤岛</p>
<p>【201507】【日】无头骑士异闻录 x2 转</p>
<p>【201507】【日】我老婆是学生会长</p>
<p>【201507】【日】噬神者</p>
<p>【201507】【日】绅士学园</p>
<p>【201507】【日】黑街GANGSTA</p>
<p>【201507】【日】干物妹！小埋</p>
<p>【201507】【日】OVERLORD1</p>
<p>【201504】【日】血界战线1</p>
<p>【201504】【日】食戟之灵1</p>
<p>【201504】【日】吹响吧！上低音号</p>
<h2 id="2014"><a class="header" href="#2014">2014</a></h2>
<p>【201310】【日】寄生兽</p>
<p>【201310】【日】记录的地平线2</p>
<p>【201410】【日】境界触发者1</p>
<p>【201404】【日】进击的巨人1</p>
<p>【201401】【日】野良神1</p>
<h2 id="2013"><a class="header" href="#2013">2013</a></h2>
<p>【201310】【日】记录的地平线1</p>
<p>【201310】【日】斩服少女</p>
<p>【201307】【日】恋爱研究所</p>
<p>【201304】【日】某科学的超电磁炮S</p>
<h2 id="2012"><a class="header" href="#2012">2012</a></h2>
<p>【201209】【日】来自新世界</p>
<p>【201201】【日】Another</p>
<h2 id="2011"><a class="header" href="#2011">2011</a></h2>
<h2 id="2010"><a class="header" href="#2010">2010</a></h2>
<p>【201010】【日】魔法禁书目录2</p>
<h2 id="2009"><a class="header" href="#2009">2009</a></h2>
<p>【200910】【日】某科学的超电磁炮</p>
<h2 id="2008"><a class="header" href="#2008">2008</a></h2>
<p>【200810】【日】魔法禁书目录1</p>
<h2 id="2007"><a class="header" href="#2007">2007</a></h2>
<p>【200704】【日】大剑</p>
<h2 id="2006"><a class="header" href="#2006">2006</a></h2>
<p>【200610】【日】死亡笔记</p>
<h2 id="1995"><a class="header" href="#1995">1995</a></h2>
<p>【199510】【日】新世纪福音战士</p>
<div style="break-before: page; page-break-before: always;"></div><p>+++</p>
<p>title = &quot;go.0开始&quot;
description = &quot;go.0开始&quot;
tags = [&quot;it&quot;,&quot;lang&quot;,&quot;go&quot;]</p>
<p>+++</p>
<h1 id="go开始"><a class="header" href="#go开始">go.开始</a></h1>
<blockquote>
<p><a href="https://go.dev/">官网</a>。</p>
</blockquote>
<h2 id="go"><a class="header" href="#go">go</a></h2>
<p><a href="https://go.dev/dl/">下载</a>并解压：linux 选择 .linux-amd64.tar.gz，win 选择 .windows-amd64.zip</p>
<p>环境变量：配置 GOROOT &amp; GOPATH，并将其 bin 目录添加到 PATH 后，go install 安装的程序将保存到 <code>$GOPATH/bin</code> 下</p>
<pre><code class="language-shell"># 向 ~/.bashrc (或 /etc/profile) 添加环境变量
sed -i '$a\
\
\
# go\
export PATH=$PATH:~/langs/go1.19.3/bin:~/langs/gopath/bin\
export GOROOT=~/langs/go1.19.3\
export GOPATH=~/langs/gopath\
export GOPROXY=https://goproxy.cn,direct\
alias goland=&quot;nohup ~/langs/goland-2021.2.3//bin/goland.sh &gt;/dev/null &amp; 2&gt;&amp;1&quot;' ~/.bashrc
# 刷新
source ~/.bashrc
</code></pre>
<p>配置</p>
<pre><code class="language-shell"># 必要配置
go env -w GOROOT=~/it/go/go
go env -w GOPATH=~/it/go/gopath

# 七牛云代理。&quot;goproxy.io&quot;、&quot;goproxy.cn&quot;、&quot;mirrors.aliyun.com/goproxy/&quot; 等任选其一
go env -w GOPROXY=https://goproxy.cn,direct
# gomod，1.14后默认开启
go env -w GO111MODULE=on

# 可选配置
# 设置GOPRIVATE来跳过私有库，比如常用的Gitlab或Gitee，中间使用逗号分隔
go env -w GOPRIVATE=*.gitlab.com,*.gitee.com 
# 如果在运行go mod vendor时，提示Get https://sum.golang.org/lookup/xxxxxx: dial tcp 216.58.200.49:443: i/o timeout，则是因为Go 1.13设置了默认的GOSUMDB=sum.golang.org，这个网站是被墙了的，用于验证包的有效性，可以通过这个命令关闭。私有仓库自动忽略验证
go env -w GOSUMDB=off 
# 可以设置 GOSUMDB=&quot;sum.golang.google.cn&quot;， 这个是专门为国内提供的sum 验证服务
go env -w GOSUMDB=&quot;sum.golang.google.cn&quot; 
</code></pre>
<h2 id="goland"><a class="header" href="#goland">goland</a></h2>
<p>下载并解压：https://www.jetbrains.com/go/download/other.html</p>
<pre><code class="language-sh"># 别名。使 goland nohup，并将其产生的 stdout 重定向到 /dev/null
$ vim /etc/profile
#添加如下内容，goland将不输出任何信息，也不会产生 nohup.out
alias goland='nohup ~/go/goland/bin/goland.sh &gt;/dev/null &amp; 2&gt;&amp;1'
</code></pre>
<h3 id="常用设置"><a class="header" href="#常用设置">常用设置</a></h3>
<ol>
<li>
<p>go</p>
</li>
<li>
<p>go mod：开启即可</p>
</li>
<li>
<p>proto import</p>
<ol>
<li>Goland插件Protocol Buffer Editor：Configure → Setting → Protocol Buffers → 取消勾选Configure automatically → 添加所需目录
<ol>
<li>一般是当前project或module的上一级目录，以使生成的go文件依然保持正确的包导入路径，且前缀统一更具可读性；D:/it/go/GoProject/pkg/mod</li>
<li>如果用到go mod导入的内容，还需要添加go mod包所在目录。D:/it/go/GoProject/pkg/mod</li>
</ol>
</li>
<li>如果是<code>protoc</code>命令工具：则添加 <code>-I</code> 参数指定目录</li>
</ol>
</li>
<li>
<p>编码：Configure → Setting → Editor → File Encodings</p>
</li>
<li>
<p>全选为UTF-8，with NO BOM</p>
<ol start="2">
<li>Transparent native-to-ascii conversion自动转换ASCII编码：建议勾选。可能意思是，在文件中输入文字时他会自动的转换为Unicode编码，然后在idea中发开文件时他会自动转回文字来显示</li>
</ol>
</li>
<li>
<p>注解生效激活：Configure → Setting → Compiler → Annotation Processors</p>
<ol>
<li>Enable annotation processing</li>
</ol>
</li>
<li>
<p>文件过滤：Configure → Setting → Editor → File Types</p>
<ol>
<li>ActionScript → Ignore files and folders：添加 *.idea;*.iml; 进去</li>
</ol>
</li>
<li>
<p>字体：Configure → Setting → Editor → Font</p>
</li>
<li>
<p>主题：Configure → Setting → Editor → Color Scheme</p>
</li>
<li>
<p>背景图：Ctrl+Shift+A，搜索set background Image</p>
</li>
<li>
<p>参数名提示：Ctrl+Shift+A，搜索show parameter name hints</p>
</li>
<li>
<p>文档模板注释：</p>
<pre><code class="language-java">   /* 类文档注释模板配置
   1.file - settings - editor - file and data templates
   2.includs - file header - 右空白框内复制下面类文档注释模板
   3.新建类时自动生成文档注释
   */
   /** 类文档模板
   @title: ${NAME}
   @projectName ${PROJECT_NAME}
   @description: TODO
   @author ${USER}
   @date ${DATE}${TIME}
    */
   public class DocumentAnnotationTemplate {
       /* 方法文档注释模板配置
       1.file - settings - editor - live templates
       2.右+号 - template group - 名aaa(在最前比较方便)
       3.选中aaa - live template - 名ann - 描述ann - 空白框内复制下面方法注释模板 - define - everywhere
       3.新建方法后在方法上面输入ann - 按tab补全
       */
       /** 方法模板
       @description: TODO
       @param ${tags}
       @return ${return_type}
       @throws
       @author ${USER}
       @date ${DATE}${TIME}
        */
       public void function() { }
}
</code></pre>
</li>
<li>
<p>evaluate expression：https://www.cnblogs.com/mrmoo/p/9942605.html</p>
</li>
</ol>
<h3 id="重置试用"><a class="header" href="#重置试用">重置试用</a></h3>
<p>方式1：删除家目录下的试用配置文件夹</p>
<pre><code class="language-shell">rm -rf ~/.config/JetBrains/GoLand20xx.x/eval/
# win下为~\AppData\Local\JetBrains\GoLand2021.2
</code></pre>
<p>方式2：安装插件 Eval Reset，点击 help-&gt;Eval Reset-&gt;reset 即可无限<a href="https://zhile.io/2020/11/18/jetbrains-eval-reset-deprecated.html">重置试用</a>。适用于 2021.2.3 及以前，2021.2.4 开始必须联网登录账号才能使用。可以勾选 Auto reset before per restart</p>
<p>方式3：破解。破解前打开 goland，选择试用；下载破解文件 jetbrains-agent.jar 2020版本，将 jetbrains-agent.jar 拖入goland窗口，会提示restart，点击restart即可完成破解。适用于2021.1.2及其以前（现在好像2021.1.2已经不行了）</p>
<h2 id="hello"><a class="header" href="#hello">hello</a></h2>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	fmt.Println(&quot;Hello world!&quot;)
}
</code></pre>
<pre><code class="language-shell">$ go run main.go
Hello world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>+++</p>
<p>title = &quot;kubernetes&quot;
description = &quot;it.cloud.kubernetes&quot;
tags = [&quot;it&quot;, &quot;cloud&quot;, &quot;kubernetes&quot;]</p>
<p>+++</p>
<h1 id="kubernetes开始"><a class="header" href="#kubernetes开始">kubernetes.开始</a></h1>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<p>遵照<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#%E5%87%86%E5%A4%87%E5%BC%80%E5%A7%8B">kubeadm安装准备</a>，禁用交换分区，启用<a href="https://kubernetes.io/zh/docs/reference/ports-and-protocols/">必需端口</a>并进行<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#check-required-ports">检查</a>，<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#%E5%85%81%E8%AE%B8-iptables-%E6%A3%80%E6%9F%A5%E6%A1%A5%E6%8E%A5%E6%B5%81%E9%87%8F">允许iptables检查桥接流量</a>。</p>
<pre><code class="language-shell"># 关闭swap分区(永久)：把加载swap分区的那行记录注释掉，重启生效
sed -ri 's/.*swap.*/#&amp;/' /etc/fstab

# 配置br_netfilter模块
cat &lt;&lt;EOF | tee /etc/modules-load.d/k8s.conf
br_netfilter
EOF
# 加载。也可以reboot以加载
modprobe  br_netfilter &amp;&amp; lsmod | grep br_netfilter

# 允许iptables检查桥接流量
cat &lt;&lt;EOF | tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
# 使生效
sysctl --system
</code></pre>
<h3 id="ubuntu"><a class="header" href="#ubuntu">ubuntu</a></h3>
<pre><code class="language-shell"># 关闭swap分区(临时)
swapoff -a

# 防火墙：关闭防火墙或者开放官方指南中指定的端口。ubuntu默认为关闭状态，这里仅查看
ufw status

# 必要工具
apt install -y apt-transport-https ca-certificates curl gnupg lsb-release
</code></pre>
<h4 id="docker"><a class="header" href="#docker">docker</a></h4>
<blockquote>
<p><a href="https://yeasy.gitbook.io/docker_practice/install/ubuntu">ubuntu安装docker</a>；</p>
</blockquote>
<pre><code class="language-shell"># 勿在没有配置Docker APT源的情况下直接使用apt命令安装Docker
# 先卸载
apt remove -y docker.io
apt remove -y docker
apt remove -y docker-engine
</code></pre>
<p>ubuntu20.04后台运行的openvpn会<a href="https://askubuntu.com/questions/1302371/docker-ce-post-installation-configuration-failure-on-ubuntu-20-04">影响docker-ce安装</a>，产生<code>Errors were encountered while processing</code></p>
<pre><code class="language-shell"># 停止openvpn
service openvpn stop
</code></pre>
<pre><code class="language-shell"># GPG密钥
curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
# apt源
echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot; | tee /etc/apt/sources.list.d/docker.list &gt; /dev/null

# 安装
apt update &amp;&amp; apt install -y docker-ce docker-ce-cli containerd.io
# 开机启动并立即启动
systemctl enable --now docker &amp;&amp; systemctl status docker
</code></pre>
<h4 id="kubernetes"><a class="header" href="#kubernetes">kubernetes</a></h4>
<pre><code class="language-shell"># GPG密钥
curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg
# apt源
echo &quot;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main&quot; | sudo tee /etc/apt/sources.list.d/kubernetes.list

# 查看版本。尝试了kubeadm1.25+docker-ce20版本出错，因此降低kubeadm版本
apt-cache madison kubeadm | grep 1.23
# 安装
apt update &amp;&amp; apt install -y kubeadm=1.23.14-00 kubelet=1.23.14-00 kubectl=1.23.14-00

# 开机启动并立即启动
# 但kubelet现在每隔几秒就会重启，因为它陷入了一个等待kubeadm指令的死循环
systemctl enable --now kubelet &amp;&amp; systemctl status kubelet
</code></pre>
<h3 id="centos"><a class="header" href="#centos">centos</a></h3>
<pre><code class="language-shell"># 关闭swap分区(临时)
setenforce 0

# 防火墙：关闭防火墙或者开放官方指南中指定的端口
systemctl disable --now firewalld &amp;&amp; firewall-cmd --state
</code></pre>
<h4 id="docker-1"><a class="header" href="#docker-1">docker</a></h4>
<p>安装容器运行时，这里选择docker，设置 <a href="https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">docker 阿里源</a>存储库，然后<a href="https://docs.docker.com/engine/install/rhel/#install-docker-engine">安装 Docker Engine 和 containerd</a> 。</p>
<pre><code class="language-shell"># yum源
cat &lt;&lt;EOF | tee /etc/yum.repos.d/docker.repo
[docker-ce-stable]
name=Docker CE Stable - $basearch
baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/\$releasever/\$basearch/stable
enabled=1
gpgcheck=1
gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg
EOF

# 安装Docker Engine和 containerd
# centos8默认使用podman代替 docker，会提示冲突，根据提示使用--allowerasing参数，表示替换冲突的软件包
yum install -y --allowerasing docker-ce docker-ce-cli containerd.io

# 设置开机启动并立即启动
systemctl enable --now docker &amp;&amp; systemctl status docker
</code></pre>
<h4 id="kubernetes-1"><a class="header" href="#kubernetes-1">kubernetes</a></h4>
<p>使用 centos8 原生包管理工具<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#%E5%AE%89%E8%A3%85-kubeadm-kubelet-%E5%92%8C-kubectl">安装 kubeadm、kubelet 和 kubectl</a>，使用 <a href="https://mirrors.aliyun.com/kubernetes/yum/repos/">kubernetes 阿里源</a>。</p>
<pre><code class="language-shell">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-\$basearch
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
exclude=kubelet kubeadm kubectl
EOF

# 将 SELinux 设置为 permissive 模式（相当于将其禁用）。临时设置立即生效，并永久禁用
setenforce 0
sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config

# 安装。kubelet-x.x.x kubeadm-x.x.x kubectl-x.x.x 可以指定版本
yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes
# 设置为开机启动并立即启动，但 kubelet 现在每隔几秒就会重启，因为它陷入了一个等待 kubeadm 指令的死循环
systemctl enable --now kubelet
# 查看 kubelet
systemctl status kubelet
</code></pre>
<h3 id="二进制"><a class="header" href="#二进制">二进制</a></h3>
<h4 id="kubectl"><a class="header" href="#kubectl">kubectl</a></h4>
<blockquote>
<p><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/">安装kubectl</a>。</p>
</blockquote>
<pre><code class="language-shell"># kubectl
curl -LO &quot;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl&quot;
# 校验和
curl -LO &quot;https://dl.k8s.io/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256&quot;
# 校验
echo &quot;$(cat kubectl.sha256)  kubectl&quot; | sha256sum --check
# 移动
mv kubectl /usr/local/bin
</code></pre>
<h2 id="准备"><a class="header" href="#准备">准备</a></h2>
<h3 id="配置容器-cgroup-驱动"><a class="header" href="#配置容器-cgroup-驱动">配置容器 cgroup 驱动</a></h3>
<blockquote>
<p><a href="https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/#docker">dokcer配置systemd作cgroup驱动</a>；</p>
<p><a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/configure-cgroup-driver/#%E9%85%8D%E7%BD%AE-kubelet-%E7%9A%84-cgroup-%E9%A9%B1%E5%8A%A8">kubelet配置systemd作cgroup驱动</a>；</p>
</blockquote>
<p>1.22及之后<code>kubeadm init</code>默认使用 <code>systemd</code> 作为 kubelet 的 cgroup 驱动，而不是 <code>cgroupfs</code>。这里顺手加上<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云 docker 镜像源</a>。</p>
<pre><code class="language-shell"># docker配置systemd作cgroup驱动。
# 否则kubeadm init报错dial tcp 127.0.0.1:10248: connect: connection refused
# 另外配置了日志、镜像源、免证书验证仓库
cat &lt;&lt;EOF | tee /etc/docker/daemon.json
{
  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],
  &quot;log-driver&quot;: &quot;json-file&quot;,
  &quot;log-opts&quot;: {
    &quot;max-size&quot;: &quot;100m&quot;
  },
  &quot;storage-driver&quot;: &quot;overlay2&quot;,
  &quot;registry-mirrors&quot;: [&quot;https://ohm5orzk.mirror.aliyuncs.com&quot;],
  &quot;insecure-registries&quot;: [&quot;registry.aliyuncs.com&quot;] # [&quot;192.168.xxx.xxx:5000&quot;,&quot;registry.aliyuncs.com&quot;]
}
EOF
# 启用配置并重启docker
systemctl daemon-reload &amp;&amp; systemctl restart docker

# kubelet配置systemd作cgroup驱动。1.23版本默认为systemd，无需配置
</code></pre>
<h3 id="控制平面准备"><a class="header" href="#控制平面准备">控制平面准备</a></h3>
<pre><code class="language-shell"># 设置 hostname
hostnamectl set-hostname 192.168.31.11

# 主节点添加本机 DNS 映射
sed -i '$a192.168.31.11 kubecpe' /etc/hosts
</code></pre>
<h3 id="数据平面准备"><a class="header" href="#数据平面准备">数据平面准备</a></h3>
<pre><code class="language-shell"># 设置 hostname
hostnamectl set-hostname 192.168.31.15
</code></pre>
<h2 id="集群创建"><a class="header" href="#集群创建">集群创建</a></h2>
<p>准备3台完成安装的机器</p>
<h3 id="kubeadm"><a class="header" href="#kubeadm">kubeadm</a></h3>
<p><a href="https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/">kubeadm 参考指南</a>。</p>
<h4 id="控制平面"><a class="header" href="#控制平面">控制平面</a></h4>
<p><a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E8%8A%82%E7%82%B9">初始化控制平面节点</a>。注意要再次运行 <code>kubeadm init</code>，必须首先<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#tear-down">卸载集群</a>。如果是非root用户</p>
<pre><code class="language-shell"># --apiserver-advertise-address 设置 master ip
# --image-repository 指定阿里云镜像仓库地址，因为默认拉取镜像地址 k8s.gcr.io 国内无法访问；
$ kubeadm init \
--node-name 192.168.31.11 \
--control-plane-endpoint=kubecpe \
--apiserver-advertise-address=192.168.31.11 \
--pod-network-cidr=10.244.0.0/16 \
--image-repository registry.aliyuncs.com/google_containers

# 创建成功后得到如下操作提示
......
Your Kubernetes control-plane has initialized successfully!

# 如何开始使用集群（kubectl）
To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

Alternatively, if you are the root user, you can run:

  export KUBECONFIG=/etc/kubernetes/admin.conf

# 如何安装 pod 网络
You should now deploy a pod network to the cluster.
Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

# 如何添加控制平面节点
You can now join any number of control-plane nodes by copying certificate authorities
and service account keys on each node and then running the following as root:

  kubeadm join kubecpe:6443 --token nhn70c.ck1r8ceu4j4pq3ep \
        --discovery-token-ca-cert-hash sha256:55b9644fc941d4928f40baa30a700973cf375b826fdb8e00012797cdbe0c90c1 \
        --control-plane

# 如何添加工作节点
Then you can join any number of worker nodes by running the following on each as root:

kubeadm join kubecpe:6443 --token nhn70c.ck1r8ceu4j4pq3ep \
        --discovery-token-ca-cert-hash sha256:55b9644fc941d4928f40baa30a700973cf375b826fdb8e00012797cdbe0c90c1
</code></pre>
<h4 id="使用集群"><a class="header" href="#使用集群">使用集群</a></h4>
<p>复制 /etc/kubernetes/admin.conf 到 $HOME/.kube/config 即可使用 kubectl</p>
<pre><code class="language-shell">mkdir ~/.kube
cp -i /etc/kubernetes/admin.conf ~/.kube/config
chown $(id -u):$(id -g) ~/.kube/config
</code></pre>
<h4 id="pod-网络"><a class="header" href="#pod-网络">pod 网络</a></h4>
<p><a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#pod-network">安装 pod 网络</a>。从 <a href="https://github.com/flannel-io/flannel/blob/v0.15.1/Documentation/kube-flannel.yml">flannel github</a> 上复制下来使用，使用 -f 直接指定或者使用 wget 下载后 -f 指定，都会出现 yaml 解析错误</p>
<p>如有需要请<a href="https://huangzhongde.cn/istio/Chapter6/Chapter6-8.html">配置网卡</a>。</p>
<pre><code class="language-shell"># 部署 kube-flannel
kubectl apply -f /mnt/share/kube-flannel.yaml
</code></pre>
<h4 id="工作节点"><a class="header" href="#工作节点">工作节点</a></h4>
<p>集群<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#join-nodes">加入节点</a>。如果前面提示的 token 和 hash 已经找不到了，可以在控制平面节点上查看 token 和 hash</p>
<pre><code class="language-shell"># 查看 token 列表
kubeadm token list
# 或者创建新的 token
kubeadm token create
# 查看 CA 公钥的哈希值
openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //'
</code></pre>
<p>然后在工作节点上通过 <code>kubeadm join --token &lt;token&gt; &lt;control-plane-host&gt;:&lt;control-plane-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</code> 加入集群。</p>
<pre><code class="language-shell"># 工作节点添加控制平面节点的 DNS 映射
sed -i '$a192.168.31.11 kubecpe' /etc/hosts
# 加入集群
kubeadm join kubecpe:6443 \
--node-name 192.168.31.11 \
--token st4khy.2j4qmbuge5mh1d76 \
--discovery-token-ca-cert-hash sha256:55b9644fc941d4928f40baa30a700973cf375b826fdb8e00012797cdbe0c90c1
</code></pre>
<h4 id="节点删除"><a class="header" href="#节点删除">节点删除</a></h4>
<blockquote>
<p>节点清理</p>
</blockquote>
<p>先在节点上重置 kubeadm 安装的状态，然后通过 kubectl 删除节点即可。主节点只需调用 <code>kubeadm reset</code> 会进行尽力而为的清理</p>
<pre><code class="language-shell"># 使节点不调度
kubectl drain &lt;node name&gt; --delete-emptydir-data --force --ignore-daemonsets
kubeadm reset
kubectl delete node &lt;node_name&gt;
</code></pre>
<h4 id="网络卸载"><a class="header" href="#网络卸载">网络卸载</a></h4>
<p>重置过程 <code>kubeadm reset</code> 不会重置或清除 iptables 规则或 IPVS 表</p>
<pre><code class="language-shell"># iptables清理
iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X
</code></pre>
<pre><code class="language-shell"># IPVS 清理
ipvsadm -C
</code></pre>
<p>网卡清理</p>
<pre><code class="language-shell"># flannel，清理完需重启 kubelet
kubectl delete -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
ifconfig cni0 down
ip link delete cni0
ifconfig flannel.1 down
ip link delete flannel.1
rm -rf /var/lib/cni/
rm -f /etc/cni/net.d/*
systemctl restart kubelet
</code></pre>
<h3 id="最佳实践"><a class="header" href="#最佳实践">最佳实践</a></h3>
<h4 id="tls-证书和秘钥"><a class="header" href="#tls-证书和秘钥">TLS 证书和秘钥</a></h4>
<p>安装 CFSSL</p>
<pre><code class="language-shell">$ go get -u github.com/cloudflare/cfssl/cmd/...
$ ls $GOPATH/bin/cfssl*
/root/go/path/bin/cfssl         /root/go/path/bin/cfssl-certinfo  /root/go/path/bin/cfssl-newkey
/root/go/path/bin/cfssl-bundle  /root/go/path/bin/cfssljson       /root/go/path/bin/cfssl-scan
</code></pre>
<h5 id="ca-证书"><a class="header" href="#ca-证书">CA 证书</a></h5>
<p>创建 CA 配置文件。</p>
<pre><code class="language-shell">$ cfssl print-defaults config &gt; config.json
$ cfssl print-defaults csr &gt; csr.json

# 根据 config.json 文件的格式创建如下的 ca-config.json 文件，过期时间设置成了 87600h
$ cat &gt; ca-config.json &lt;&lt;EOF
{
  &quot;signing&quot;: {
    &quot;default&quot;: {
      &quot;expiry&quot;: &quot;87600h&quot;
    },
    &quot;profiles&quot;: {
      &quot;kubernetes&quot;: {
        &quot;usages&quot;: [
            &quot;signing&quot;,
            &quot;key encipherment&quot;,
            &quot;server auth&quot;,
            &quot;client auth&quot;
        ],
        &quot;expiry&quot;: &quot;87600h&quot;
      }
    }
  }
}
EOF
</code></pre>
<p>字段说明：</p>
<ul>
<li><code>ca-config.json</code>：可以定义多个 profiles，分别指定不同的过期时间、使用场景等参数；后续在签名证书时使用某个 profile；</li>
<li><code>signing</code>：表示该证书可用于签名其它证书；生成的 ca.pem 证书中 <code>CA=TRUE</code>；</li>
<li><code>server auth</code>：表示client可以用该 CA 对server提供的证书进行验证；</li>
<li><code>client auth</code>：表示server可以用该CA对client提供的证书进行验证；</li>
</ul>
<p>创建 CA 证书签名请求文件</p>
<pre><code class="language-shell">cat &gt; ca-csr.json &lt;&lt; EOF
&gt; {
&gt;   &quot;CN&quot;: &quot;kubernetes&quot;,
&gt;   &quot;key&quot;: {
&gt;     &quot;algo&quot;: &quot;rsa&quot;,
&gt;     &quot;size&quot;: 2048
&gt;   },
&gt;   &quot;names&quot;: [
&gt;     {
&gt;       &quot;C&quot;: &quot;CN&quot;,
&gt;       &quot;ST&quot;: &quot;BeiJing&quot;,
&gt;       &quot;L&quot;: &quot;BeiJing&quot;,
&gt;       &quot;O&quot;: &quot;k8s&quot;,
&gt;       &quot;OU&quot;: &quot;System&quot;
&gt;     }
&gt;   ],
&gt;     &quot;ca&quot;: {
&gt;        &quot;expiry&quot;: &quot;87600h&quot;
&gt;     }
&gt; }
&gt; EOF
</code></pre>
<p>字段说明：</p>
<ul>
<li>&quot;CN&quot;：<code>Common Name</code>，kube-apiserver 从证书中提取该字段作为请求的用户名 (User Name)；浏览器使用该字段验证网站是否合法；</li>
<li>&quot;O&quot;：<code>Organization</code>，kube-apiserver 从证书中提取该字段作为请求用户所属的组 (Group)；</li>
</ul>
<p><strong>生成 CA 证书和私钥</strong>。</p>
<pre><code class="language-shell">$ cfssl gencert -initca ca-csr.json | cfssljson -bare ca
$ ls ca*
ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem
</code></pre>
<h5 id="kubernetes-证书"><a class="header" href="#kubernetes-证书">kubernetes 证书</a></h5>
<p>创建 kubernetes 证书签名请求文件</p>
<pre><code class="language-shell">$ cat &gt; kubernetes-csr.json &lt;&lt; EOF
&gt; {
&gt;     &quot;CN&quot;: &quot;kubernetes&quot;,
&gt;     &quot;hosts&quot;: [
&gt;       &quot;127.0.0.1&quot;,
&gt;       &quot;172.20.0.112&quot;,
&gt;       &quot;172.20.0.113&quot;,
&gt;       &quot;172.20.0.114&quot;,
&gt;       &quot;172.20.0.115&quot;,
&gt;       &quot;10.254.0.1&quot;,
&gt;       &quot;kubernetes&quot;,
&gt;       &quot;kubernetes.default&quot;,
&gt;       &quot;kubernetes.default.svc&quot;,
&gt;       &quot;kubernetes.default.svc.cluster&quot;,
        &quot;algo&quot;: &quot;rsa&quot;,
&gt;       &quot;kubernetes.default.svc.cluster.local&quot;
&gt;     ],
&gt;     &quot;key&quot;: {
&gt;         &quot;algo&quot;: &quot;rsa&quot;,
&gt;         &quot;size&quot;: 2048
&gt;     },
&gt;     &quot;names&quot;: [
&gt;         {
&gt;             &quot;C&quot;: &quot;CN&quot;,
&gt;             &quot;ST&quot;: &quot;BeiJing&quot;,
&gt;             &quot;L&quot;: &quot;BeiJing&quot;,
&gt;             &quot;O&quot;: &quot;k8s&quot;,
&gt;             &quot;OU&quot;: &quot;System&quot;
&gt;         }
&gt;     ]
&gt; }
&gt; EOF
</code></pre>
<ul>
<li>如果 hosts 字段不为空则需要指定授权使用该证书的 <strong>IP 或域名列表</strong>，由于该证书后续被 <code>etcd</code> 集群和 <code>kubernetes master</code> 集群使用，所以上面分别指定了 <code>etcd</code> 集群、<code>kubernetes master</code> 集群的主机 IP 和 <strong><code>kubernetes</code> 服务的服务 IP</strong>（一般是 <code>kube-apiserver</code> 指定的 <code>service-cluster-ip-range</code> 网段的第一个IP，如 10.254.0.1）。</li>
<li>这是最小化安装的kubernetes集群，包括一个私有镜像仓库，三个节点的kubernetes集群，以上物理节点的IP也可以更换为主机名。</li>
</ul>
<p><strong>生成 kubernetes 证书和私钥</strong></p>
<pre><code class="language-shell">$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kubernetes-csr.json | cfssljson -bare kubernetes
$ ls kubernetes*
kubernetes.csr  kubernetes-csr.json  kubernetes-key.pem  kubernetes.pem
</code></pre>
<h5 id="admin-证书"><a class="header" href="#admin-证书">admin 证书</a></h5>
<p>创建 admin 证书签名请求文件</p>
<pre><code class="language-shell">$ cat &gt; admin-csr.json &lt;&lt; EOF
&gt; {
&gt;   &quot;CN&quot;: &quot;admin&quot;,
&gt;   &quot;hosts&quot;: [],
&gt;   &quot;key&quot;: {
&gt;     &quot;algo&quot;: &quot;rsa&quot;,
&gt;     &quot;size&quot;: 2048
&gt;   },
&gt;   &quot;names&quot;: [
&gt;     {
&gt;       &quot;C&quot;: &quot;CN&quot;,
&gt;       &quot;ST&quot;: &quot;BeiJing&quot;,
&gt;       &quot;L&quot;: &quot;BeiJing&quot;,
&gt;       &quot;O&quot;: &quot;system:masters&quot;,
&gt;       &quot;OU&quot;: &quot;System&quot;
&gt;     }
&gt;   ]
&gt; }
&gt; EOF
</code></pre>
<ul>
<li>后续 <code>kube-apiserver</code> 使用 <code>RBAC</code> 对客户端(如 <code>kubelet</code>、<code>kube-proxy</code>、<code>Pod</code>)请求进行授权；</li>
<li><code>kube-apiserver</code> 预定义了一些 <code>RBAC</code> 使用的 <code>RoleBindings</code>，如 <code>cluster-admin</code> 将 Group <code>system:masters</code> 与 Role <code>cluster-admin</code> 绑定，该 Role 授予了调用<code>kube-apiserver</code> 的<strong>所有 API</strong>的权限；</li>
<li>O 指定该证书的 Group 为 <code>system:masters</code>，<code>kubelet</code> 使用该证书访问 <code>kube-apiserver</code> 时 ，由于证书被 CA 签名，所以认证通过，同时由于证书用户组为经过预授权的 <code>system:masters</code>，所以被授予访问所有 API 的权限；</li>
</ul>
<p><strong>生成 admin 证书和私钥</strong></p>
<pre><code class="language-shell">$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin
$ ls admin*
admin.csr  admin-csr.json  admin-key.pem  admin.pem
</code></pre>
<p><strong>注意</strong>：这个admin 证书，是将来生成管理员用的kube config 配置文件用的，现在我们一般建议使用RBAC 来对kubernetes 进行角色权限控制， kubernetes 将证书中的CN 字段 作为User， O 字段作为 Group（具体参考<a href="https://jimmysong.io/kubernetes-handbook/guide/authentication.html"> Kubernetes中的用户与身份认证授权</a>中 X509 Client Certs 一段）。</p>
<p>在搭建完 kubernetes 集群后，我们可以通过命令: <code>kubectl get clusterrolebinding cluster-admin -o yaml</code> ,查看到 <code>clusterrolebinding cluster-admin</code> 的 subjects 的 kind 是 Group，name 是 <code>system:masters</code>。 <code>roleRef</code> 对象是 <code>ClusterRole cluster-admin</code>。 意思是凡是 <code>system:masters Group</code> 的 user 或者 <code>serviceAccount</code> 都拥有 <code>cluster-admin</code> 的角色。 因此我们在使用 kubectl 命令时候，才拥有整个集群的管理权限。</p>
<pre><code class="language-yaml">$ kubectl get clusterrolebinding cluster-admin -o yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;
  creationTimestamp: 2017-04-11T11:20:42Z
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  name: cluster-admin
  resourceVersion: &quot;52&quot;
  selfLink: /apis/rbac.authorization.k8s.io/v1/clusterrolebindings/cluster-admin
  uid: e61b97b2-1ea8-11e7-8cd7-f4e9d49f8ed0
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: system:masters
</code></pre>
<h5 id="kube-proxy-证书"><a class="header" href="#kube-proxy-证书">kube-proxy 证书</a></h5>
<p>创建 kube-proxy 证书签名请求文件</p>
<pre><code class="language-shell">$ cat &gt; kube-proxy-csr.json &lt;&lt; EOF
&gt; {
&gt;   &quot;CN&quot;: &quot;system:kube-proxy&quot;,
&gt;   &quot;hosts&quot;: [],
&gt;   &quot;key&quot;: {
&gt;     &quot;algo&quot;: &quot;rsa&quot;,
&gt;     &quot;size&quot;: 2048
&gt;   },
&gt;   &quot;names&quot;: [
&gt;     {
&gt;       &quot;C&quot;: &quot;CN&quot;,
&gt;       &quot;ST&quot;: &quot;BeiJing&quot;,
&gt;       &quot;L&quot;: &quot;BeiJing&quot;,
&gt;       &quot;O&quot;: &quot;k8s&quot;,
&gt;       &quot;OU&quot;: &quot;System&quot;
&gt;     }
&gt;   ]
&gt; }
&gt; EOF
</code></pre>
<ul>
<li>CN 指定该证书的 User 为 <code>system:kube-proxy</code>；</li>
<li><code>kube-apiserver</code> 预定义的 RoleBinding <code>system:node-proxier</code> 将User <code>system:kube-proxy</code> 与 Role <code>system:node-proxier</code> 绑定，该 Role 授予了调用 <code>kube-apiserver</code> Proxy 相关 API 的权限；</li>
</ul>
<p>生成 kube-proxy 客户端证书和私钥</p>
<pre><code class="language-shell">$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes  kube-proxy-csr.json | cfssljson -bare kube-proxy
$ ls kube-proxy*
</code></pre>
<h5 id="校验证书"><a class="header" href="#校验证书">校验证书</a></h5>
<h6 id="使用-openssl"><a class="header" href="#使用-openssl">使用 openssl</a></h6>
<p>以 Kubernetes 证书为例，使用 openssl 命令读取证书信息</p>
<ul>
<li>确认 <code>Issuer</code> 字段的内容和 <code>ca-csr.json</code> 一致；</li>
<li>确认 <code>Subject</code> 字段的内容和 <code>kubernetes-csr.json</code> 一致；</li>
<li>确认 <code>X509v3 Subject Alternative Name</code> 字段的内容和 <code>kubernetes-csr.json</code> 一致；</li>
<li>确认 <code>X509v3 Key Usage、Extended Key Usage</code> 字段的内容和 <code>ca-config.json</code> 中 <code>kubernetes</code> profile 一致；</li>
</ul>
<pre><code class="language-shell">$ openssl x509  -noout -text -in  kubernetes.pem
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            03:0e:b4:83:5e:6d:02:fa:bf:62:21:aa:37:47:f1:c4:88:f4:8a:0c
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C = CN, ST = BeiJing, L = BeiJing, O = k8s, OU = System, CN = kubernetes
        Validity
            Not Before: Mar 12 12:04:00 2022 GMT
            Not After : Mar  9 12:04:00 2032 GMT
        Subject: C = CN, ST = BeiJing, L = BeiJing, O = k8s, OU = System, CN = kubernetes
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: (2048 bit)
                Modulus:
                    ......
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Key Usage: critical
                Digital Signature, Key Encipherment
            X509v3 Extended Key Usage:
                TLS Web Server Authentication, TLS Web Client Authentication
            X509v3 Basic Constraints: critical
                CA:FALSE
            X509v3 Subject Key Identifier:
                B7:15:10:43:1B:E1:53:B0:6A:12:56:5B:A5:CD:EF:77:E4:A0:79:F4
            X509v3 Subject Alternative Name:
                DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster, DNS:kubernetes.default.svc.cluster.local, IP Address:127.0.0.1, IP Address:172.20.0.112, IP Address:172.20.0.113, IP Address:172.20.0.114, IP Address:172.20.0.115, IP Address:10.254.0.1
    Signature Algorithm: sha256WithRSAEncryption
         ......
</code></pre>
<h6 id="使用cfssl-certinfo"><a class="header" href="#使用cfssl-certinfo">使用cfssl-certinfo</a></h6>
<pre><code class="language-shell">cfssl-certinfo -cert kubernetes.pem
{
  &quot;subject&quot;: {
    &quot;common_name&quot;: &quot;kubernetes&quot;,
    &quot;country&quot;: &quot;CN&quot;,
    &quot;organization&quot;: &quot;k8s&quot;,
    &quot;organizational_unit&quot;: &quot;System&quot;,
    &quot;locality&quot;: &quot;BeiJing&quot;,
    &quot;province&quot;: &quot;BeiJing&quot;,
    &quot;names&quot;: [
      &quot;CN&quot;,
      &quot;BeiJing&quot;,
      &quot;BeiJing&quot;,
      &quot;k8s&quot;,
      &quot;System&quot;,
      &quot;kubernetes&quot;
    ]
  },
  &quot;issuer&quot;: {
    &quot;common_name&quot;: &quot;kubernetes&quot;,
    &quot;country&quot;: &quot;CN&quot;,
    &quot;organization&quot;: &quot;k8s&quot;,
    &quot;organizational_unit&quot;: &quot;System&quot;,
    &quot;locality&quot;: &quot;BeiJing&quot;,
    &quot;province&quot;: &quot;BeiJing&quot;,
    &quot;names&quot;: [
      &quot;CN&quot;,
      &quot;BeiJing&quot;,
      &quot;BeiJing&quot;,
      &quot;k8s&quot;,
      &quot;System&quot;,
      &quot;kubernetes&quot;
    ]
  },
  &quot;serial_number&quot;: &quot;17454907659222183176468532411310969421540133388&quot;,
  &quot;sans&quot;: [
    &quot;kubernetes&quot;,
    &quot;kubernetes.default&quot;,
    &quot;kubernetes.default.svc&quot;,
    &quot;kubernetes.default.svc.cluster&quot;,
    &quot;kubernetes.default.svc.cluster.local&quot;,
    &quot;127.0.0.1&quot;,
    &quot;172.20.0.112&quot;,
    &quot;172.20.0.113&quot;,
    &quot;172.20.0.114&quot;,
    &quot;172.20.0.115&quot;,
    &quot;10.254.0.1&quot;
  ],
  &quot;not_before&quot;: &quot;2022-03-12T12:04:00Z&quot;,
  &quot;not_after&quot;: &quot;2032-03-09T12:04:00Z&quot;,
  &quot;sigalg&quot;: &quot;SHA256WithRSA&quot;,
  &quot;authority_key_id&quot;: &quot;&quot;,
  &quot;subject_key_id&quot;: &quot;B7:15:10:43:1B:E1:53:B0:6A:12:56:5B:A5:CD:EF:77:E4:A0:79:F4&quot;,
  &quot;pem&quot;: &quot;-----BEGIN CERTIFICATE-----\nMIIEajCCA1KgAwIBAgIUAw60g15tAvq/YiGqN0fxxIj0igwwDQYJKoZIhvcNAQEL\nBQAwZTELMAkGA1UEBhMCQ04xEDAOBgNVBAgTB0JlaUppbmcxEDAOBgNVBAcTB0Jl\naUppbmcxDDAKBgNVBAoTA2s4czEPMA0GA1UECxMGU3lzdGVtMRMwEQYDVQQDEwpr\ndWJlcm5ldGVzMB4XDTIyMDMxMjEyMDQwMFoXDTMyMDMwOTEyMDQwMFowZTELMAkG\nA1UEBhMCQ04xEDAOBgNVBAgTB0JlaUppbmcxEDAOBgNVBAcTB0JlaUppbmcxDDAK\nBgNVBAoTA2s4czEPMA0GA1UECxMGU3lzdGVtMRMwEQYDVQQDEwprdWJlcm5ldGVz\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA3QrEXpJnjVNsYnFGnu4f\nJG99y/P49uL0VTEZP4+6X/NRN1Fq9clX8acDHQcYBPud6OSI2Lvah9hxKQTpmIIQ\nky2lEnA64c9BDU5x0CUP5UOzwryjddFshHfvNOg7dySR3hzOKiKac31RKCtOo3OB\nlVctX+ksm1dAsTuGoAvYXKTl2fbR6p+Ew7tkMjbtaghXS9MXVy3RN1t7G3X9Xj9U\ndHnfdTCtTVxJF6kRrOBuP3ad+YDj6QAk8jXKefkFzfezj+w1g1zPJXcTtSko/YiH\n9A0lfiKxiv+6RGoXWQRnMT1J2Or8sKP0yWb0qLkk/+jINCiNulLL+mDQrEVlSSn3\ncwIDAQABo4IBEDCCAQwwDgYDVR0PAQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUF\nBwMBBggrBgEFBQcDAjAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBS3FRBDG+FTsGoS\nVlulze935KB59DCBrQYDVR0RBIGlMIGiggprdWJlcm5ldGVzghJrdWJlcm5ldGVz\nLmRlZmF1bHSCFmt1YmVybmV0ZXMuZGVmYXVsdC5zdmOCHmt1YmVybmV0ZXMuZGVm\nYXVsdC5zdmMuY2x1c3RlcoIka3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVy\nLmxvY2FshwR/AAABhwSsFABwhwSsFABxhwSsFAByhwSsFABzhwQK/gABMA0GCSqG\nSIb3DQEBCwUAA4IBAQAJTaKt98jCvsRo2vq9RvK732UO4tgYdhyAcQTREvsEyjdT\nYlA85xix0I9j5MlBgyfplQLCIobGjjdmkIdVcJsciPaqRdCjurHkDF5pBs4m/qlr\nfhxjEjZr36aT3/taq5xUA//TkCTb9p8Ijm+3AMdPGxovXE/TokEYcXDNasaVYsLY\naBxKDv3Bymwv9RIzPDrcNnn7llsCba6IX+L8u3TB4GIOxv7yH6XwVhqAFKh1yXUZ\n6H8Wky5z8l91virnRBfi3y4jJsl/odIznp16We8VnWCA36eTzBwOOEZiU3MvlPYc\nei7FKCGN5U3ZwwLsTMH2WzWX+Zw+dZGA97FmDYnX\n-----END CERTIFICATE-----\n&quot;
}
</code></pre>
<h5 id="颁发证书"><a class="header" href="#颁发证书">颁发证书</a></h5>
<p>将生成的证书和秘钥文件（后缀名为<code>.pem</code>）拷贝到所有（需要的）机器（包括当前）的 <code>/etc/kubernetes/ssl</code> 目录下备用</p>
<pre><code class="language-shell">mkdir -p /etc/kubernetes/ssl &amp;&amp; cp *.pem /etc/kubernetes/ssl
</code></pre>
<h4 id="kubelet"><a class="header" href="#kubelet">kubelet</a></h4>
<pre><code class="language-shell">export KUBE_APISERVER=&quot;https://kubecpe:6443&quot;

# 设置集群参数
kubectl config set-cluster kubernetes \
  --certificate-authority=/etc/kubernetes/ssl/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER}
# 设置客户端认证参数
kubectl config set-credentials admin \
  --client-certificate=/etc/kubernetes/ssl/admin.pem \
  --embed-certs=true \
  --client-key=/etc/kubernetes/ssl/admin-key.pem
# 设置上下文参数
kubectl config set-context kubernetes \
  --cluster=kubernetes \
  --user=admin
# 设置默认上下文
kubectl config use-context kubernetes
</code></pre>
<ul>
<li><code>admin.pem</code> 证书 OU 字段值为 <code>system:masters</code>，<code>kube-apiserver</code> 预定义的 RoleBinding <code>cluster-admin</code> 将 Group <code>system:masters</code> 与 Role <code>cluster-admin</code> 绑定，该 Role 授予了调用<code>kube-apiserver</code> 相关 API 的权限；</li>
<li>生成的 kubeconfig 被保存到 <code>~/.kube/config</code> 文件；</li>
</ul>
<p><strong>注意：</strong><code>~/.kube/config</code>文件拥有对该集群的最高权限，请妥善保管。</p>
<h4 id="kubeconfig"><a class="header" href="#kubeconfig">kubeconfig</a></h4>
<h5 id="tls-bootstrapping-token"><a class="header" href="#tls-bootstrapping-token">TLS Bootstrapping Token</a></h5>
<p>Token可以是任意的包含128 bit的字符串，可以使用安全的随机数发生器生成。</p>
<pre><code class="language-shell">export BOOTSTRAP_TOKEN=$(head -c 16 /dev/urandom | od -An -t x | tr -d ' ')

cat &gt; token.csv &lt;&lt;EOF
${BOOTSTRAP_TOKEN},kubelet-bootstrap,10001,&quot;system:kubelet-bootstrap&quot;
EOF

# 检查 token.csv 文件，确认其中的 ${BOOTSTRAP_TOKEN} 环境变量已经被真实的值替换
cat token.csv
c16e2aa67b2d10569d68ee176af17017,kubelet-bootstrap,10001,&quot;system:kubelet-bootstrap&quot;
</code></pre>
<p><strong>BOOTSTRAP_TOKEN</strong> 将被写入到 kube-apiserver 使用的 token.csv 文件和 kubelet 使用的 <code>bootstrap.kubeconfig</code> 文件，如果后续重新生成了 BOOTSTRAP_TOKEN，则需要：</p>
<ol>
<li>更新 token.csv 文件，分发到所有机器 (master 和 node）的 /etc/kubernetes/ 目录下，分发到node节点上非必需；</li>
<li>重新生成 bootstrap.kubeconfig 文件，分发到所有 node 机器的 /etc/kubernetes/ 目录下；</li>
<li>重启 kube-apiserver 和 kubelet 进程；</li>
<li>重新 approve kubelet 的 csr 请求；</li>
</ol>
<pre><code class="language-shell">cp token.csv /etc/kubernetes/
</code></pre>
<h5 id="kubelet-bootstrapping-kubeconfig"><a class="header" href="#kubelet-bootstrapping-kubeconfig">kubelet bootstrapping kubeconfig</a></h5>
<pre><code class="language-shell">cd /etc/kubernetes
export KUBE_APISERVER=&quot;https://kubecpe:6443&quot;

# 设置集群参数
kubectl config set-cluster kubernetes \
  --certificate-authority=/etc/kubernetes/ssl/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=bootstrap.kubeconfig

# 设置客户端认证参数
kubectl config set-credentials kubelet-bootstrap \
  --token=${BOOTSTRAP_TOKEN} \
  --kubeconfig=bootstrap.kubeconfig

# 设置上下文参数
kubectl config set-context default \
  --cluster=kubernetes \
  --user=kubelet-bootstrap \
  --kubeconfig=bootstrap.kubeconfig

# 设置默认上下文
kubectl config use-context default --kubeconfig=bootstrap.kubeconfig
</code></pre>
<ul>
<li><code>--embed-certs</code> 为 <code>true</code> 时表示将 <code>certificate-authority</code> 证书写入到生成的 <code>bootstrap.kubeconfig</code> 文件中；</li>
<li>设置客户端认证参数时<strong>没有</strong>指定秘钥和证书，后续由 <code>kube-apiserver</code> 自动生成；</li>
</ul>
<h5 id="kube-proxy-kubeconfig"><a class="header" href="#kube-proxy-kubeconfig">kube-proxy kubeconfig</a></h5>
<pre><code class="language-shell">export KUBE_APISERVER=&quot;https://172.20.0.113:6443&quot;
# 设置集群参数
kubectl config set-cluster kubernetes \
  --certificate-authority=/etc/kubernetes/ssl/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=kube-proxy.kubeconfig
# 设置客户端认证参数
kubectl config set-credentials kube-proxy \
  --client-certificate=/etc/kubernetes/ssl/kube-proxy.pem \
  --client-key=/etc/kubernetes/ssl/kube-proxy-key.pem \
  --embed-certs=true \
  --kubeconfig=kube-proxy.kubeconfig
# 设置上下文参数
kubectl config set-context default \
  --cluster=kubernetes \
  --user=kube-proxy \
  --kubeconfig=kube-proxy.kubeconfig
# 设置默认上下文
kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig
</code></pre>
<h5 id="分发-kubeconfig"><a class="header" href="#分发-kubeconfig">分发 kubeconfig</a></h5>
<p>将两个 kubeconfig 文件分发到所有 Node 机器的 <code>/etc/kubernetes/</code> 目录</p>
<pre><code class="language-shell">cp bootstrap.kubeconfig kube-proxy.kubeconfig /etc/kubernetes/
</code></pre>
<h4 id="etcd"><a class="header" href="#etcd">etcd</a></h4>
<h5 id="准备-1"><a class="header" href="#准备-1">准备</a></h5>
<p>添加 hosts</p>
<pre><code class="language-shell">sed -i '$a192.168.43.201 kubecpe' /etc/hosts
</code></pre>
<h5 id="安装-1"><a class="header" href="#安装-1">安装</a></h5>
<pre><code class="language-shell">wget https://github.com/etcd-io/etcd/releases/download/v3.4.18/etcd-v3.4.18-linux-amd64.tar.gz
tar -xvf etcd-v3.4.18-linux-amd64.tar.gz
mv etcd-v3.1.5-linux-amd64/etcd* /usr/local/bin
</code></pre>
<h5 id="创建-etcd-的-systemd-unit-文件"><a class="header" href="#创建-etcd-的-systemd-unit-文件">创建 etcd 的 systemd unit 文件</a></h5>
<p>在/usr/lib/systemd/system/目录下创建文件etcd.service，内容如下。注意替换IP地址为你自己的etcd集群的主机IP。</p>
<pre><code class="language-toml">[Unit]
Description=Etcd Server
After=network.target
After=network-online.target
Wants=network-online.target
Documentation=https://github.com/coreos

[Service]
Type=notify
WorkingDirectory=/var/lib/etcd/
EnvironmentFile=-/etc/etcd/etcd.conf
ExecStart=/usr/local/bin/etcd \
  --name ${ETCD_NAME} \
  --cert-file=/etc/kubernetes/ssl/kubernetes.pem \
  --key-file=/etc/kubernetes/ssl/kubernetes-key.pem \
  --peer-cert-file=/etc/kubernetes/ssl/kubernetes.pem \
  --peer-key-file=/etc/kubernetes/ssl/kubernetes-key.pem \
  --trusted-ca-file=/etc/kubernetes/ssl/ca.pem \
  --peer-trusted-ca-file=/etc/kubernetes/ssl/ca.pem \
  --initial-advertise-peer-urls ${ETCD_INITIAL_ADVERTISE_PEER_URLS} \
  --listen-peer-urls ${ETCD_LISTEN_PEER_URLS} \
  --listen-client-urls ${ETCD_LISTEN_CLIENT_URLS},http://127.0.0.1:2379 \
  --advertise-client-urls ${ETCD_ADVERTISE_CLIENT_URLS} \
  --initial-cluster-token ${ETCD_INITIAL_CLUSTER_TOKEN} \
  --initial-cluster infra1=https://etce01:2380,infra2=https://etce02:2380,infra3=https://etce03:2380 \
  --initial-cluster-state new \
  --data-dir=${ETCD_DATA_DIR}
Restart=on-failure
RestartSec=5
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
</code></pre>
<ul>
<li>指定 <code>etcd</code> 的工作目录为 <code>/var/lib/etcd</code>，数据目录为 <code>/var/lib/etcd</code>，需在启动服务前创建这个目录，否则启动服务的时候会报错“Failed at step CHDIR spawning /usr/bin/etcd: No such file or directory”；</li>
<li>为了保证通信安全，需要指定 etcd 的公私钥(cert-file和key-file)、Peers 通信的公私钥和 CA 证书(peer-cert-file、peer-key-file、peer-trusted-ca-file)、客户端的CA证书（trusted-ca-file）；</li>
<li>创建 <code>kubernetes.pem</code> 证书时使用的 <code>kubernetes-csr.json</code> 文件的 <code>hosts</code> 字段<strong>包含所有 etcd 节点的IP</strong>，否则证书校验会出错；</li>
<li><code>--initial-cluster-state</code> 值为 <code>new</code> 时，<code>--name</code> 的参数值必须位于 <code>--initial-cluster</code> 列表中；</li>
</ul>
<p>完整 unit 文件见：<a href="https://jimmysong.io/kubernetes-handbook/systemd/etcd.service">etcd.service</a></p>
<p>环境变量配置文件<code>/etc/etcd/etcd.conf</code>。</p>
<pre><code class="language-ini"># [member]
ETCD_NAME=infra1
ETCD_DATA_DIR=&quot;/var/lib/etcd&quot;
ETCD_LISTEN_PEER_URLS=&quot;https://172.20.0.113:2380&quot;
ETCD_LISTEN_CLIENT_URLS=&quot;https://172.20.0.113:2379&quot;

#[cluster]
ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;https://172.20.0.113:2380&quot;
ETCD_INITIAL_CLUSTER_TOKEN=&quot;etcd-cluster&quot;
ETCD_ADVERTISE_CLIENT_URLS=&quot;https://172.20.0.113:2379&quot;
</code></pre>
<h2 id="时间同步"><a class="header" href="#时间同步">时间同步</a></h2>
<pre><code class="language-shell"># 在各节点上执行如下命令
yum install ntpdate -y
ntpdate time.windows.com
</code></pre>
<h2 id="命令补全--别名"><a class="header" href="#命令补全--别名">命令补全 &amp; 别名</a></h2>
<blockquote>
<p>详见 <a href="https://kubernetes.io/zh-cn/docs/tasks/tools/included/optional-kubectl-configs-bash-linux/">Linux 系统中的 bash 自动补全功能</a>。</p>
</blockquote>
<p>向 <code>~/.bashrc</code> 中添加内容，如果没有bash-completion需要先</p>
<pre><code class="language-shell"># 安装bash-completion
apt install -y bash-completion

# 加载
cat &gt;&gt; ~/.bashrc &lt;&lt; EOF


# bash-completion
source /usr/share/bash-completion/bash_completion
# kubectl
source &lt;(kubectl completion bash)
alias kc=kubectl
complete -o default -F __start_kubectl kc
EOF

# 更新
source .bashrc
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>+++</p>
<p>title = &quot;eBPF&quot;
description = &quot;it.os.linux.eBPF&quot;
tags = [&quot;it&quot;,&quot;os&quot;,&quot;linux&quot;]</p>
<p>+++</p>
<h1 id="ebpf"><a class="header" href="#ebpf">eBPF</a></h1>
<blockquote>
<p><a href="https://ebpf.io/">官网</a>；</p>
<p><a href="https://cilium.readthedocs.io/en/stable/bpf/">eBPF 和 XDP 参考指南</a> &amp; <a href="https://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/">翻译</a>；</p>
<p><a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">bpf-helpers</a>；</p>
<p><a href="https://arthurchiao.art/blog/bpf-advanced-notes-1-zh/">BPF 程序类型详解</a>；</p>
<p><a href="https://arthurchiao.art/blog/bpf-advanced-notes-2-zh/">BPF Map 类型详解</a>；</p>
<p><a href="%E8%AE%A1/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/iovisor/bcc">iovisor/bcc</a>；</p>
<p>使用 python 开发 eBPF 程序；</p>
<p><a href="%E8%AE%A1/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/cilium/ebpf">cilium/ebpf</a>；</p>
<p><a href="https://github.com/iovisor/gobpf">iovisor/gobpf</a>；</p>
<p><a href="https://www.sobyte.net/post/2022-04/go-ebfp/">使用 Go 语言开发 eBPF 程序</a>；</p>
</blockquote>
<h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<blockquote>
<p><a href="https://ebpf.io/what-is-ebpf#introduction-to-ebpf">eBPF简介</a>；</p>
</blockquote>
<p><img src="https://ebpf.io/static/go-1a1bb6f1e64b1ad5597f57dc17cf1350.png" alt="" /></p>
<h2 id="过程"><a class="header" href="#过程">过程</a></h2>
<p><img src="%E8%AE%A1/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/./img/Linux.eBPF.%E8%BF%87%E7%A8%8B.svg" alt="" /></p>
<h2 id="技术栈"><a class="header" href="#技术栈">技术栈</a></h2>
<blockquote>
<p><a href="http://arthurchiao.art/blog/bpf-portability-and-co-re-zh/">[译] BPF 可移植性和 CO-RE (compile once - run everywhere)</a>；<a href="https://facebookmicrosites.github.io/bpf/blog/2020/02/19/bpf-portability-and-co-re.html">BPF Portability and CO-RE</a>；</p>
</blockquote>
<p><img src="%E8%AE%A1/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/./img/Linux.eBPF.%E6%8A%80%E6%9C%AF%E6%A0%88.svg" alt="" /></p>
<h2 id="co-re"><a class="header" href="#co-re">CO-RE</a></h2>
<h3 id="btf"><a class="header" href="#btf">BTF</a></h3>
<p>检查BTF开启</p>
<pre><code class="language-shell">$ cat /boot/config-`uname -r` | grep BTF
CONFIG_VIDEO_SONY_BTF_MPX=m
CONFIG_DEBUG_INFO_BTF=y
CONFIG_PAHOLE_HAS_SPLIT_BTF=y
CONFIG_DEBUG_INFO_BTF_MODULES=y
</code></pre>
<h3 id="vmlinuxh"><a class="header" href="#vmlinuxh">vmlinux.h</a></h3>
<pre><code class="language-shell"># 生成vmlinux.h
$ bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h
</code></pre>
<h2 id="bpf-prog"><a class="header" href="#bpf-prog">BPF prog</a></h2>
<pre><code class="language-c">#include &quot;vmlinux.h&quot;

#include &lt;bpf/bpf_helpers.h&gt;
#include &lt;bpf/bpf_tracing.h&gt;

SEC(&quot;&lt;bpf_type&gt;/&lt;trace_name&gt;&quot;)
int kprobe__do_sys_openat2(struct pt_regs *ctx)
{
    char file_name[256];
    bpf_probe_read(file_name, sizeof(file_name), PT_REGS_PARM2(ctx));

    char fmt[] = &quot;open file %s\n&quot;;
    bpf_trace_printk(fmt, sizeof(fmt), &amp;file_name);

    return 0;
}
</code></pre>
<p>vmlinux.h：见CO-RE vmlinux.h</p>
<p>bpf_type：不同的类型有不同的使用方式和限制，详见下面<a href="%E8%AE%A1/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.eBPF.html#eBPF%E7%B1%BB%E5%9E%8B">eBPF类型</a>。</p>
<p>trace_name：对于</p>
<h3 id="编译"><a class="header" href="#编译">编译</a></h3>
<pre><code class="language-makefile"></code></pre>
<h3 id="类型"><a class="header" href="#类型">类型</a></h3>
<h3 id="kprobes"><a class="header" href="#kprobes">kprobes</a></h3>
<pre><code class="language-c">#include &quot;vmlinux.h&quot;

#include &lt;bpf/bpf_helpers.h&gt;
#include &lt;bpf/bpf_tracing.h&gt;

SEC(&quot;kprobe/do_sys_openat2&quot;)
int kprobe__do_sys_openat2(struct pt_regs *ctx)
{
    char file_name[256];
    bpf_probe_read(file_name, sizeof(file_name), PT_REGS_PARM2(ctx));

    char fmt[] = &quot;open file %s\n&quot;;
    bpf_trace_printk(fmt, sizeof(fmt), &amp;file_name);

    return 0;
}
</code></pre>
<h3 id="tracepoint"><a class="header" href="#tracepoint">tracepoint</a></h3>
<h3 id="raw_tracepoint"><a class="header" href="#raw_tracepoint">raw_tracepoint</a></h3>
<h2 id="bpf-map"><a class="header" href="#bpf-map">BPF map</a></h2>
<h2 id="vmlinux"><a class="header" href="#vmlinux">vmlinux</a></h2>
<h2 id="libbpfgo"><a class="header" href="#libbpfgo">libbpfgo</a></h2>
<blockquote>
<p><a href="https://github.com/aquasecurity/libbpfgo">aquasecurity/libbpfgo</a>：一个通过cgo调用libbpf库的go语言封装。</p>
<p><a href="https://mozillazg.com/2022/05/ebpf-libbpfgo-develop-env-and-hello-world.html">libbpfgo 使用示例：搭建开发环境以及编写第一个 ebpf 程序</a>；</p>
<p><a href="https://libbpf.readthedocs.io/en/latest/program_types.html">文档</a>；</p>
</blockquote>
<h3 id="依赖"><a class="header" href="#依赖">依赖</a></h3>
<pre><code class="language-shell"># 安装：clang llvm elf bpftool
$ apt install -y clang llvm libelf-dev linux-tools-common
# 执行：仍收到以下提示
$ bpftool 
WARNING: bpftool not found for kernel 5.15.0-52

  You may need to install the following packages for this specific kernel:
    linux-tools-5.15.0-52-generic
    linux-cloud-tools-5.15.0-52-generic

  You may also want to install one of the following packages to keep up to date:
    linux-tools-generic
    linux-cloud-tools-generic
# 安装
$ apt install -y linux-tools-5.15.0-52-generic
</code></pre>
<h3 id="makefile"><a class="header" href="#makefile">Makefile</a></h3>
<pre><code class="language-makefile">ROOT = ./
OUTPUT = ./build

$(OUTPUT):
	mkdir -p $(OUTPUT)

# ---------------- vmlinuxh
# vmlinuxh: vmlinux header file, generated by
# `bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; OUTPUT/vmlinux.h`
.PHONY: vmlinuxh
VMLINUXH = $(OUTPUT)/vmlinux.h
BPFTOOL = $(shell which bpftool || /bin/false)
BTFFILE = /sys/kernel/btf/vmlinux
DBGVMLINUX = /usr/lib/debug/boot/vmlinux-$(shell uname -r)

vmlinuxh: $(VMLINUXH)
$(VMLINUXH): $(OUTPUT)
ifeq ($(wildcard $(BPFTOOL)),)
	@echo &quot;ERROR: could not find bpftool&quot;
	@exit 1
endif
	@if [ -f $(DBGVMLINUX) ]; then \
		echo &quot;INFO: found dbg kernel, generating $(VMLINUXH) from $(DBGVMLINUX)&quot;; \
		$(BPFTOOL) btf dump file $(DBGVMLINUX) format c &gt; $(VMLINUXH); \
	fi
	@if [ ! -f $(BTFFILE) ] &amp;&amp; [ ! -f $(DBGVMLINUX) ]; then \
		echo &quot;ERROR: kernel does not seem to support BTF&quot;; \
		exit 1; \
	fi
	@if [ ! -f $(VMLINUXH) ]; then \
		echo &quot;INFO: generating $(VMLINUXH) from $(BTFFILE)&quot;; \
		$(BPFTOOL) btf dump file $(BTFFILE) format c &gt; $(VMLINUXH); \
	fi

# ---------------- c
# C
CC = gcc
CFLAGS = -ggdb -gdwarf -O2 -Wall -fpie -Wno-unused-variable -Wno-unused-function

# ---------------- libbpf
# libbpf: default static libbpf
LIBBPF_SRC = $(abspath ./3rdparty/libbpf/src)
LIBBPF_DST = $(abspath $(OUTPUT)/libbpf)
GIT = $(shell which git || /bin/false)

$(LIBBPF_SRC):
ifeq ($(wildcard $@), )
	echo &quot;INFO: updating submodule 'libbpf'&quot;
	$(GIT) submodule update --init --recursive
endif
$(LIBBPF_DST):
	mkdir -p $(LIBBPF_DST)

.PHONY: libbpf
libbpf: libbpf-static

# ---------------- ---------------- libbpf static
# libbpf static: static libbpf generation for the git submodule
LIBBPF_DESTDIR = $(abspath $(OUTPUT))
LIBBPF_OBJDIR = $(abspath $(OUTPUT)/libbpf)
LIBBPF_OBJ = $(abspath $(LIBBPF_OBJDIR)/libbpf.a)
LDFLAGS =

.PHONY: libbpf-static
libbpf-static: $(LIBBPF_OBJ)
$(LIBBPF_OBJ): $(LIBBPF_SRC) $(wildcard $(LIBBPF_SRC)/*.[ch]) | $(LIBBPF_DST)
	CC=&quot;$(CC)&quot; CFLAGS=&quot;$(CFLAGS)&quot; LD_FLAGS=&quot;$(LDFLAGS)&quot; \
	$(MAKE) -C $(LIBBPF_SRC) \
		BUILD_STATIC_ONLY=1 \
		DESTDIR=$(LIBBPF_DESTDIR) \
		OBJDIR=$(LIBBPF_OBJDIR) \
		INCLUDEDIR= LIBDIR= UAPIDIR= prefix= libdir= \
		install

# ---------------- ---------------- libbpf dynamic
# libbpf dynamic:
CGO_CFGLAGS_DYN = &quot;-I. -I/usr/include/&quot;
CGO_LDFLAGS_DYN = &quot;-lelf -lz -lbpf&quot;
CGO_EXTLDFLAGS_DYN = '-w'

.PHONY: libbpf-dynamic
libbpf-dynamic:
	echo nothing

# ---------------- program
PROGRAM = ytrace

# ---------------- bpf program
# bpf prog: clang -O2 -Wall -target bpf
CLANG = clang
BPF_SRC = $(abspath $(ROOT)/pkg/bpf)
BPF_CFLAGS_STATIC = &quot;-I$(abspath $(OUTPUT))&quot;
BPF_LDFLAGS_STATIC = &quot;-lelf -lz $(LIBBPF_OBJ)&quot;

.PHONY: $(PROGRAM).bpf.c
$(PROGRAM).bpf.o: $(PROGRAM).bpf.c | vmlinuxh
	$(CLANG) -D__TARGET_ARCH_x86 \
		$(CFLAGS) -target bpf -I. -I$(OUTPUT) \
		-c $&lt; -o $@

# ---------------- go program
# go prog
OS := $(shell uname -s)
ARCH := $(shell uname -m)
ARCH := $(subst x86_64,amd64,$(ARCH))
GOARCH := $(ARCH)
CGO_CFLAGS_STATIC = &quot;-I$(abspath $(OUTPUT))&quot;
CGO_LDFLAGS_STATIC = &quot;-lelf -lz $(LIBBPF_OBJ)&quot;
CGO_EXTLDFLAGS_STATIC = '-w -extldflags &quot;-static&quot;'

.PHONY: $(PROGRAM)
$(PROGRAM): libbpf | $(PROGRAM).bpf.o
	CC=$(CLANG) GOOS=linux GOARCH=$(GOARCH) \
	CGO_CFLAGS=$(CGO_CFLAGS_STATIC) CGO_LDFLAGS=$(CGO_LDFLAGS_STATIC) \
	go build -tags netgo -ldflags $(CGO_EXTLDFLAGS_STATIC) \
		-o $(PROGRAM) ./$(PROGRAM).go

# ---------------- all
all:
	$(MAKE) -C . $(PROGRAM)

# ---------------- clean
clean:
	$(MAKE) -C $(LIBBPF_SRC) clean
	rm -rf $(OUTPUT)
	rm -rf $(VMLINUXH)
	rm -rf $(PROGRAM) $(PROGRAM)-*static $(PROGRAM)-*dynamic
	rm -rf $(PROGRAM).bpf.o $(PROGRAM).o

</code></pre>
<p>ebpf/c/</p>
<pre><code class="language-c">#include &quot;vmlinux.h&quot;

#include &lt;bpf/bpf_helpers.h&gt;
#include &lt;bpf/bpf_tracing.h&gt;

SEC(&quot;kprobe/do_sys_openat2&quot;)
int kprobe__do_sys_openat2(struct pt_regs *ctx)
{
    char file_name[256];
    bpf_probe_read(file_name, sizeof(file_name), PT_REGS_PARM2(ctx));

    char fmt[] = &quot;open file %s\n&quot;;
    bpf_trace_printk(fmt, sizeof(fmt), &amp;file_name);

    return 0;
}
</code></pre>
<pre><code class="language-shell">clang -D__TARGET_ARCH_x86 -I. -I../c/  -target bpf -c bpf.o.c -o bpf.o
</code></pre>
<h2 id="实验基于-ebpf-的网络观测"><a class="header" href="#实验基于-ebpf-的网络观测">实验：基于 eBPF 的网络观测</a></h2>
<blockquote>
<p><a href="https://blog.csdn.net/flynetcn/article/details/119487894">Linux网络新技术基石：eBPF and XDP</a>；</p>
</blockquote>
<h2 id="tracee二次开发"><a class="header" href="#tracee二次开发">tracee二次开发</a></h2>
<blockquote>
<p><a href="https://github.com/aquasecurity/tracee">aquasecurity/tracee</a>：使用 Linux <strong>eBPF 技术</strong>在运行时<strong>跟踪您的系统和应用程序，并分析收集的事件以检测</strong>可疑的行为模式。</p>
<p>tracee 依赖于 libbpf</p>
</blockquote>
<h3 id="libbpf"><a class="header" href="#libbpf">libbpf</a></h3>
<blockquote>
<p><a href="https://github.com/libbpf/libbpf">libbpf</a>：可以构建支持 <a href="https://github.com/libbpf/libbpf#bpflibbpf-usage-and-questions">BPF CO-RE(Compile Once – Run Everywhere)</a> 的高可移植性 BPF 程序。与 <a href="https://github.com/iovisor/bcc/">BCC</a> 相比，它不需要将 Clang/LLVM 运行时部署到目标服务器，并且不依赖于可用的内核开发头文件。</p>
<p>BTF：libbpf 依赖于内核 BTF，RHEL 8.2+、Ubuntu 20.10 等发行版都已经内置内核 BTF；内核 BTF 需要在<strong>编译</strong>内核时设置<code>CONFIG_DEBUG_INFO_BTF=y</code>构建选项；通过查看是否存在文件<code>/sys/kernel/btf/vmlinux</code>以检查内核是否内置 BTF</p>
</blockquote>
<p>安装</p>
<pre><code class="language-shell"># 

# libbpf 在 tracee 项目 make 中的安装方式
CC=&quot;clang&quot; \
CFLAGS=&quot;&quot;-fPIC&quot;&quot; \
LD_FLAGS=&quot;&quot; \
make \
-C ./3rdparty/libbpf/src \
BUILD_STATIC_ONLY=1 \
DESTDIR=/root/projects/github.com/tracee/dist/libbpf \
OBJDIR=/root/projects/github.com/tracee/dist/libbpf/obj \
INCLUDEDIR= LIBDIR= UAPIDIR= prefix= libdir= \
install install_uapi_headers
</code></pre>
<h3 id="启动流程"><a class="header" href="#启动流程">启动流程</a></h3>
<h3 id="追踪流程"><a class="header" href="#追踪流程">追踪流程</a></h3>
<h3 id="实现新的追踪"><a class="header" href="#实现新的追踪">实现新的追踪</a></h3>
<p>tracee 实现了 vfs_write 追踪但并没有实现 vfs_read 追踪，这里参考 vfs_write 追踪<strong>实现 vfs_read 追踪</strong>。得益于 tracee 的代码可扩展性，只需要如下两步：</p>
<ol>
<li>在 go 代码中添加 vfs_read 事件定义</li>
</ol>
<pre><code class="language-go">// pkg/events/events.go

const (
	VfsRead  // 添加 vfs_read 事件ID
    VfsWrite
)

var Definitions = eventDefinitions{
	events: map[ID]Event{
        // 参考 VfsWrite 定义实现 VfsRead 定义
        VfsRead: {
			ID32Bit: sys32undefined,
			Name:    &quot;vfs_read&quot;,
			Probes: []probeDependency{
				{Handle: probes.VfsRead, Required: true},
				{Handle: probes.VfsReadRet, Required: true},
			},
			Sets: []string{},
			Params: []trace.ArgMeta{
				{Type: &quot;const char*&quot;, Name: &quot;pathname&quot;},
				{Type: &quot;dev_t&quot;, Name: &quot;dev&quot;},
				{Type: &quot;unsigned long&quot;, Name: &quot;inode&quot;},
				{Type: &quot;size_t&quot;, Name: &quot;count&quot;},
				{Type: &quot;off_t&quot;, Name: &quot;pos&quot;},
				{Type: &quot;unsigned int&quot;, Name: &quot;flags&quot;}, // 顺手添加一个 flags
			},
		},
        VfsWrite: { /*...*/ },
    }
}
</code></pre>
<pre><code class="language-go">// pkg/ebpf/probes/probes.go

const (
	VfsRead    // 添加入参处理标识
    VfsReadRet // 添加出参处理标识
	VfsWrite
	VfsWriteRet
)

// Init initializes a Probes interface
func Init(module *bpf.Module, netEnabled bool) (Probes, error) {
	allProbes := map[Handle]Probe{
		VfsRead:                   &amp;traceProbe{eventName: &quot;vfs_read&quot;, probeType: kprobe, programName: &quot;trace_vfs_read&quot;},        // 注册入参探针
		VfsReadRet:                &amp;traceProbe{eventName: &quot;vfs_read&quot;, probeType: kretprobe, programName: &quot;trace_ret_vfs_read&quot;}, // 注册出参探针
		VfsWrite:                   &amp;traceProbe{eventName: &quot;vfs_write&quot;, probeType: kprobe, programName: &quot;trace_vfs_write&quot;},
		VfsWriteRet:                &amp;traceProbe{eventName: &quot;vfs_write&quot;, probeType: kretprobe, programName: &quot;trace_ret_vfs_write&quot;},
    }
}
</code></pre>
<ol start="2">
<li>编写 bpf 代码</li>
</ol>
<pre><code class="language-c">// pkg/ebpf/c/tracee.bpf.c

enum tail_call_id_e // 原有内容
{
    TAIL_VFS_READ,
    TAIL_VFS_WRITE, // 原有内容
}

enum event_id_e // 原有内容
{
    VFS_READ,
    VFS_WRITE, // 原有内容
}

// 参考方法 get_inode_nr_from_file，通过宏 READ_KERN 获取，否则将报错寄存器内存未初始化
static __always_inline unsigned int get_flags_from_file(struct file *file)
{
    return READ_KERN(file-&gt;f_flags);
}

static __always_inline int
do_file_read_operation(struct pt_regs *ctx, u32 event_id, u32 tail_call_id)
{
    args_t saved_args;
    if (load_args(&amp;saved_args, event_id) != 0) {
        // missed entry or not traced
        return 0;
    }

    int zero = 0;
    config_entry_t *config = bpf_map_lookup_elem(&amp;config_map, &amp;zero);
    if (config == NULL)
        return 0;

    if (!should_submit(VFS_READ, config)) {
        bpf_tail_call(ctx, &amp;prog_array, tail_call_id);
        return 0;
    }

    loff_t start_pos;
    void *ptr;
    struct iovec *vec;
    size_t count;

    struct file *file = (struct file *) saved_args.args[0];
    void *file_path = get_path_str(GET_FIELD_ADDR(file-&gt;f_path));
    unsigned int flags = get_flags_from_file(file); // 顺手加个 flags

    ptr = (void *) saved_args.args[1];
    count = (size_t) saved_args.args[2];
    loff_t *pos = (loff_t *) saved_args.args[3];

    // Extract device id, inode number, and pos (offset)
    dev_t s_dev = get_dev_from_file(file);
    unsigned long inode_nr = get_inode_nr_from_file(file);
    bpf_probe_read(&amp;start_pos, sizeof(off_t), pos);

    bool char_dev = (start_pos == 0);
    u32 bytes_read = PT_REGS_RC(ctx);

    // Calculate read start offset
    if (start_pos != 0)
        start_pos -= bytes_read;

    event_data_t data = {};
    if (!init_event_data(&amp;data, ctx))
        return 0;

    if (should_submit(VFS_READ, data.config)) {
        save_str_to_buf(&amp;data, file_path, 0);
        save_to_submit_buf(&amp;data, &amp;s_dev, sizeof(dev_t), 1);
        save_to_submit_buf(&amp;data, &amp;inode_nr, sizeof(unsigned long), 2);
        save_to_submit_buf(&amp;data, &amp;count, sizeof(size_t), 3);
        save_to_submit_buf(&amp;data, &amp;start_pos, sizeof(off_t), 4);
        save_to_submit_buf(&amp;data, &amp;flags, sizeof(int), 5); // flags

        // Submit vfs_read(v) event
        events_perf_submit(&amp;data, event_id, PT_REGS_RC(ctx));
    }

    bpf_tail_call(ctx, &amp;prog_array, tail_call_id);
    return 0;
}

SEC(&quot;kprobe/vfs_read&quot;)
TRACE_ENT_FUNC(vfs_read, VFS_READ);

SEC(&quot;kretprobe/vfs_read&quot;)
int BPF_KPROBE(trace_ret_vfs_read)
{
    return do_file_read_operation(ctx, VFS_READ, TAIL_VFS_READ);
}
</code></pre>
<p>重新编译并执行</p>
<pre><code class="language-shell">$ make
make ./dist/tracee.bpf
clang \
	-D__TARGET_ARCH_x86 \
	-D__BPF_TRACING__ \
	-DCORE \
	-I./pkg/ebpf/c/ \
	-I./dist/tracee.bpf \
	-target bpf \
	-O2 -g \
	-march=bpf -mcpu=v2 \
	-c ./pkg/ebpf/c/tracee.bpf.c \
	-o dist/tracee.bpf.core.o
make ./dist/btfhub
make btfhub
GOOS=linux CC=clang GOARCH=amd64 CGO_CFLAGS=&quot;-I/root/projects/github.com/tracee/dist/libbpf&quot; CGO_LDFLAGS=&quot;-lelf  -lz  /root/projects/github.com/tracee/dist/libbpf/libbpf.a&quot; go build \
	-tags core,ebpf \
	-ldflags=&quot;-w \
		-extldflags \&quot;\&quot; \
		-X main.version=\&quot;v0.8.0\&quot; \
		&quot; \
	-v -o dist/tracee-ebpf \
	./cmd/tracee-ebpf
make[1]: “dist/btfhub”已是最新。
make[1]: 对“btfhub”无需做任何事。
github.com/aquasecurity/tracee
github.com/aquasecurity/tracee/pkg/events
github.com/aquasecurity/tracee/pkg/events/derive
github.com/aquasecurity/tracee/pkg/bufferdecoder
github.com/aquasecurity/tracee/pkg/ebpf
github.com/aquasecurity/tracee/cmd/tracee-ebpf/internal/flags
github.com/aquasecurity/tracee/cmd/tracee-ebpf

$ ./dist/tracee-ebpf --trace event=vfs_read
TIME             UID    COMM             PID     TID     RET              EVENT                ARGS
22:14:26:651850  0      kubelet          17433   17433   549              vfs_read             pathname: /etc/selinux/config, dev: 265289728, inode: 51223044, count: 4096, pos: 0, flags: 32768
...
</code></pre>
<h3 id="容器运行"><a class="header" href="#容器运行">容器运行</a></h3>
<p>builder 目录中提供了一些 Makefile &amp; Dockerfile</p>
<h3 id="自定义容器运行"><a class="header" href="#自定义容器运行">自定义容器运行</a></h3>
<p>tracee 提供的 Makefile &amp; Dockerfile 中做了很多事情，包括在容器中下载一些编译执行依赖。但我更想让 tracee-ebpf 可执行文件拷贝到我自己自定义的容器中直接运行</p>
<ol>
<li>编写 makefile.minimal</li>
</ol>
<pre><code class="language-makefile">.PHONY: build-binary build-container run-container clean

build-binary:
	GOOS=linux CC=clang GOARCH=amd64 CGO_CFLAGS=&quot;-I/root/projects/github.com/tracee/dist/libbpf&quot; CGO_LDFLAGS=&quot;-lelf  -lz  /root/projects/github.com/tracee/dist/libbpf/libbpf.a&quot; go build \
    	-tags core,ebpf \
    	-ldflags=&quot;-w \
    		-extldflags \&quot;\&quot; \
    		-X main.version=\&quot;v0.8.0\&quot; \
    		&quot; \
    	-v -o bin/tracee-ebpf \
    	./cmd/tracee-ebpf

build-container: build-binary
	docker build -f Dockerfile.minimal -t tracee-minimal:0.1 .

run-container: build-container
	docker run -it --name tracee-minimal tracee-minimal:0.1

clean:
	docker rm tracee-minimal
	docker rmi tracee-minimal:0.1
</code></pre>
<ol start="2">
<li>编写 dockerfile.minimal</li>
</ol>
<pre><code class="language-dockerfile">FROM alpine:3.15

# 因为 bpf 程序依赖于一些 so 库，所以也需要一一拷贝
COPY /usr/lib64/libelf.so.1 /lib64/libelf.so.1

COPY bin/tracee-ebpf /tracee/tracee-ebpf

ENTRYPOINT [&quot;sh&quot;,&quot;-c&quot;,&quot;/tracee/tracee-ebpf --trace container --trace event=vfs_write --trace event=vfs_read&quot;]
</code></pre>
<p>测试运行</p>
<pre><code class="language-shell">$ make -f Makefile.minimal run-container
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
