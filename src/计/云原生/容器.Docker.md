# Docker

> [官网](https://www.docker.com/)；
>
> [文档](https://docs.docker.com/reference/)；
>
> [命令](https://docs.docker.com/engine/reference/commandline/docker/)；
>
> [镜像仓库 DockerHub](https://hub.docker.com/)；

# --- 快开 ---

## 安装

> [Install Docker Engine](https://docs.docker.com/engine/install/)；

### wsl

> [Install Docker Desktop on Linux | Docker Docs](https://docs.docker.com/desktop/install/linux-install/)；

### ubuntu

> [Install Docker Engine on Ubuntu](https://docs.docker.com/engine/install/ubuntu/)；

```shell
# 勿在没有配置Docker APT源的情况下直接使用apt命令安装Docker

# 卸载所有冲突的包
for pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; \
do \
  sudo apt-get remove $pkg; \
done
```

ubuntu 后台运行的 openvpn 会[影响 docker-ce 安装](https://askubuntu.com/questions/1302371/docker-ce-post-installation-configuration-failure-on-ubuntu-20-04)，产生 `Errors were encountered while processing`

```shell
# 停止openvpn
service openvpn stop
```

安装

```shell
# GPG 密钥
curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
# apt 源
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/nul

sudo apt update && apt-cache madison docker-ce && apt-cache madison containerd.io
sudo apt install -y docker-ce docker-ce-cli containerd.io
```

### centos

> [Install Docker Engine on RHEL](https://docs.docker.com/engine/install/rhel/)；

```sh
# 设置存储库
cat >/etc/yum.repos.d/docker.repo<<EOF
[docker-ce-stable]
name=Docker CE Stable - $basearch
baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/$basearch/stable
enabled=1
gpgcheck=1
gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg
EOF

# 安装 Docker Engine 和 containerd。
# centos8 默认使用 podman 代替 docker，会提示冲突，根据提示使用 --allowerasing 替换冲突的软件包
yum install -y --allowerasing docker-ce docker-ce-cli containerd.io
```

## 开机启动

```shell
# 开机启动并立即启动
systemctl enable --now docker
```

## 配置

> cgroup 驱动：[systemd](https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/#docker)；
>
> 存储驱动：；
>
> 容器镜像仓库：[阿里云](https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors)；
>
> dockerd 代理；

```shell
# 配置 cgroup 驱动、存储驱动、 通用
cat > /etc/docker/daemon.json << EOF
{
  "exec-opts": ["native.cgroupdriver=systemd"],
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "100m"
  },
  
  "storage-driver": "overlay2",
  
  "registry-mirrors": ["https://ohm5orzk.mirror.aliyuncs.com"],
  "insecure-registries": ["192.168.xxx.xxx:5000","registry.aliyuncs.com"],
  
  "runtimes": {
    "nvidia": {
      "args": [],
      "path": "nvidia-container-runtime"
    }
  }
}
EOF

# 配置 dockerd 代理
cat > /etc/systemd/system/docker.service.d/proxy.conf << EOF
[Service]
Environment="HTTP_PROXY=http://proxy.example.com:8080/"
Environment="HTTPS_PROXY=https://proxy.example.com:8080/"
Environment="NO_PROXY=127.0.0.1,私有仓库ip,example.com"
EOF

# 重启
systemctl daemon-reload && systemctl restart docker
# 检查
docker info
```

# --- 基操 ---

## Dockerfile/Containerfile

```dockerfile
ARG BASE_IMAGE
FROM ${BASE_IMAGE}
MAINTAINER yuanya<yuanyatianchi@google.com>

ENV WORK_DIR /tmp
WORKDIR $WORK_DIR

EXPOSE 80

# ARG OUTPUT
# RUN mkdir ${OUTPUT}
# COPY ${OUTPUT}/main ${OUTPUT}/main

RUN 

ENTRYPOINT ["bash"]
```

## Makefile

```makefile
NAME = aquickstart

# image
IMAGE_REPOSITORY=
IMAGE_VERSION = "v0.0.1"
IMAGE_NAME = $(IMAGE_REPOSITORY)$(NAME):$(IMAGE_VERSION)
ARG_BASE_IMAGE = "ubuntu:2204"

.PHONY: image
image: $(IMAGE_NAME)
$(IMAGE_NAME): Dockerfile
	docker build -t $(IMAGE_NAME) \
		--network host \
		--build-arg BASE_IMAGE=$(ARG_BASE_IMAGE) \
		.

.PHONY: image_tar
image_tar: | $(IMAGE_NAME)
	docker save -o $(NAME)-$(IMAGE_VERSION).tar $(IMAGE_NAME)

.PHONY: image_clean
image_clean:
$(IMAGE_NAME)_clean: | $(IMAGE_NAME)
	docker rmi $(IMAGE_NAME)

.PHONY: image_clean_none
image_clean_none:
	docker images | grep none | awk '{print $3}' | xargs docker rmi

# container
CONTAINER_NAME = $(NAME)
.PHONY: container_run
container_run: $(CONTAINER_NAME)_run
$(CONTAINER_NAME)_run: | $(IMAGE_NAME)
	docker run -d \
		--network=host \
		--restart=always \
		--name $(CONTAINER_NAME) \
		$(IMAGE_NAME)

CONTAINER_NAME = $(NAME)
.PHONY: container_update
container_update: $(CONTAINER_NAME)_update
$(CONTAINER_NAME)_update: | $(IMAGE_NAME)
	docker update \
		--network=host \
		--restart=always \
		--name $(CONTAINER_NAME)

# clean
.PHONY: clean
clean: | image_clean 
	docker images | grep none | awk '{print $3}' | xargs docker rmi
```

## 批量删除

```shell
docker images | grep none | awk '{print $3}' | xargs docker rmi
```
