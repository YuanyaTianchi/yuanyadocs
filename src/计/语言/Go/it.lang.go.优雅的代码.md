

+++

title = "go.优雅的代码"
description = "go.优雅的代码"
tags = ["it","go"]

+++



# go.优雅的代码



> 优雅与否，仅代表当前理解，仅供参考

## 原则

- 面向接口，可测试
- 简单设计，所谓复杂设计可能包括调用过深、碎片功能过多、强行套用设计模式（毕竟设计模式是为面向对象语言设计的）等
- 可以减少冗余代码，但不要强行去除冗余代码，这很容易使代码设计变得复杂

## 实践

- **流程控制使用接口，数据存储使用结构体**。这样的设计可以使流程控制和数据控制区分开
  - 实现接口的结构体，则首字母小写使其私有，即只被调用方法实现流程控制。而不要首字母大写使其公有，然后在其它地方断言并使用它的成员数据
  - 不实现接口的结构体及其成员，首字母大写即可，为了使其只用于数据存储，务必不要写流程控制的方法，但一些**数据处理方法**是可以的
- 手动依赖注入：为每个结构体设置New函数，并为根（最初始要使用的）结构体设置Init函数，在Init函数中逐个new其依赖。可以参考[wire](https://github.com/google/wire)生成的代码。
- 结构体成员顺序
  - 被继承结构体
  - 数据依赖。引用依赖在前，值依赖在后
  - 接口依赖
- 返回数据的方式
  - 方法确定返回值类型，则正常直接返回即可
  - 方法可能不确定返回值类型，比如接口方法，因为接口可能有很多实现，每种方法实现的返回值类型可能不同，则为方法设置一个`interface{}`参数，调用方法时通过传入引用类型参数，并对其断言判断类型，然后赋值来获得数据返回的效果。如果是返回一个`interface{}`的方式，则每个调用该方法的调用者都需要进行断言，显然不是一个好的方式
  - 方法需要返回数据，但方法中又使用了goroutine去异步获取数据，则通过返回一个`<-chan`来传递要返回的数据
- 错误日志：方法A调用了方法B，方法B调用方法C，C中new了一个错误并返回，则在B中打印日志即可，日志内容记录是B调用C时出现了错误，B将错误再次返回，A不需要再次打印日志



## 其它

规范工具、最佳实践、单元测试等：https://draveness.me/golang-101/