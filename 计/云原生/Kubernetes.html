<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kuberntes - YuanyaDocs</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../index.html">Root</a></li><li class="chapter-item expanded "><a href="../../模板.html"><strong aria-hidden="true">1.</strong> 模板</a></li><li class="chapter-item expanded "><a href="../../番.html"><strong aria-hidden="true">2.</strong> 番</a></li><li class="chapter-item expanded affix "><li class="part-title">计</li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> 语言</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../计/语言/Go.html"><strong aria-hidden="true">3.1.</strong> Go</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 云原生</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../计/云原生/Kubernetes.html" class="active"><strong aria-hidden="true">4.1.</strong> Kuberntes</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 操作系统</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Linux</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../计/操作系统/Linux.eBPF.html"><strong aria-hidden="true">5.1.1.</strong> Linux.eBPF</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">YuanyaDocs</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>+++</p>
<p>title = &quot;kubernetes&quot;
description = &quot;it.cloud.kubernetes&quot;
tags = [&quot;it&quot;, &quot;cloud&quot;, &quot;kubernetes&quot;]</p>
<p>+++</p>
<h1 id="kubernetes开始"><a class="header" href="#kubernetes开始">kubernetes.开始</a></h1>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<p>遵照<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#%E5%87%86%E5%A4%87%E5%BC%80%E5%A7%8B">kubeadm安装准备</a>，禁用交换分区，启用<a href="https://kubernetes.io/zh/docs/reference/ports-and-protocols/">必需端口</a>并进行<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#check-required-ports">检查</a>，<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#%E5%85%81%E8%AE%B8-iptables-%E6%A3%80%E6%9F%A5%E6%A1%A5%E6%8E%A5%E6%B5%81%E9%87%8F">允许iptables检查桥接流量</a>。</p>
<pre><code class="language-shell"># 关闭swap分区(永久)：把加载swap分区的那行记录注释掉，重启生效
sed -ri 's/.*swap.*/#&amp;/' /etc/fstab

# 配置br_netfilter模块
cat &lt;&lt;EOF | tee /etc/modules-load.d/k8s.conf
br_netfilter
EOF
# 加载。也可以reboot以加载
modprobe  br_netfilter &amp;&amp; lsmod | grep br_netfilter

# 允许iptables检查桥接流量
cat &lt;&lt;EOF | tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
# 使生效
sysctl --system
</code></pre>
<h3 id="ubuntu"><a class="header" href="#ubuntu">ubuntu</a></h3>
<pre><code class="language-shell"># 关闭swap分区(临时)
swapoff -a

# 防火墙：关闭防火墙或者开放官方指南中指定的端口。ubuntu默认为关闭状态，这里仅查看
ufw status

# 必要工具
apt install -y apt-transport-https ca-certificates curl gnupg lsb-release
</code></pre>
<h4 id="docker"><a class="header" href="#docker">docker</a></h4>
<blockquote>
<p><a href="https://yeasy.gitbook.io/docker_practice/install/ubuntu">ubuntu安装docker</a>；</p>
</blockquote>
<pre><code class="language-shell"># 勿在没有配置Docker APT源的情况下直接使用apt命令安装Docker
# 先卸载
apt remove -y docker.io
apt remove -y docker
apt remove -y docker-engine
</code></pre>
<p>ubuntu20.04后台运行的openvpn会<a href="https://askubuntu.com/questions/1302371/docker-ce-post-installation-configuration-failure-on-ubuntu-20-04">影响docker-ce安装</a>，产生<code>Errors were encountered while processing</code></p>
<pre><code class="language-shell"># 停止openvpn
service openvpn stop
</code></pre>
<pre><code class="language-shell"># GPG密钥
curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
# apt源
echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot; | tee /etc/apt/sources.list.d/docker.list &gt; /dev/null

# 安装
apt update &amp;&amp; apt install -y docker-ce docker-ce-cli containerd.io
# 开机启动并立即启动
systemctl enable --now docker &amp;&amp; systemctl status docker
</code></pre>
<h4 id="kubernetes"><a class="header" href="#kubernetes">kubernetes</a></h4>
<pre><code class="language-shell"># GPG密钥
curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg
# apt源
echo &quot;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main&quot; | sudo tee /etc/apt/sources.list.d/kubernetes.list

# 查看版本。尝试了kubeadm1.25+docker-ce20版本出错，因此降低kubeadm版本
apt-cache madison kubeadm | grep 1.23
# 安装
apt update &amp;&amp; apt install -y kubeadm=1.23.14-00 kubelet=1.23.14-00 kubectl=1.23.14-00

# 开机启动并立即启动
# 但kubelet现在每隔几秒就会重启，因为它陷入了一个等待kubeadm指令的死循环
systemctl enable --now kubelet &amp;&amp; systemctl status kubelet
</code></pre>
<h3 id="centos"><a class="header" href="#centos">centos</a></h3>
<pre><code class="language-shell"># 关闭swap分区(临时)
setenforce 0

# 防火墙：关闭防火墙或者开放官方指南中指定的端口
systemctl disable --now firewalld &amp;&amp; firewall-cmd --state
</code></pre>
<h4 id="docker-1"><a class="header" href="#docker-1">docker</a></h4>
<p>安装容器运行时，这里选择docker，设置 <a href="https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">docker 阿里源</a>存储库，然后<a href="https://docs.docker.com/engine/install/rhel/#install-docker-engine">安装 Docker Engine 和 containerd</a> 。</p>
<pre><code class="language-shell"># yum源
cat &lt;&lt;EOF | tee /etc/yum.repos.d/docker.repo
[docker-ce-stable]
name=Docker CE Stable - $basearch
baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/\$releasever/\$basearch/stable
enabled=1
gpgcheck=1
gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg
EOF

# 安装Docker Engine和 containerd
# centos8默认使用podman代替 docker，会提示冲突，根据提示使用--allowerasing参数，表示替换冲突的软件包
yum install -y --allowerasing docker-ce docker-ce-cli containerd.io

# 设置开机启动并立即启动
systemctl enable --now docker &amp;&amp; systemctl status docker
</code></pre>
<h4 id="kubernetes-1"><a class="header" href="#kubernetes-1">kubernetes</a></h4>
<p>使用 centos8 原生包管理工具<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#%E5%AE%89%E8%A3%85-kubeadm-kubelet-%E5%92%8C-kubectl">安装 kubeadm、kubelet 和 kubectl</a>，使用 <a href="https://mirrors.aliyun.com/kubernetes/yum/repos/">kubernetes 阿里源</a>。</p>
<pre><code class="language-shell">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-\$basearch
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
exclude=kubelet kubeadm kubectl
EOF

# 将 SELinux 设置为 permissive 模式（相当于将其禁用）。临时设置立即生效，并永久禁用
setenforce 0
sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config

# 安装。kubelet-x.x.x kubeadm-x.x.x kubectl-x.x.x 可以指定版本
yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes
# 设置为开机启动并立即启动，但 kubelet 现在每隔几秒就会重启，因为它陷入了一个等待 kubeadm 指令的死循环
systemctl enable --now kubelet
# 查看 kubelet
systemctl status kubelet
</code></pre>
<h3 id="二进制"><a class="header" href="#二进制">二进制</a></h3>
<h4 id="kubectl"><a class="header" href="#kubectl">kubectl</a></h4>
<blockquote>
<p><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/">安装kubectl</a>。</p>
</blockquote>
<pre><code class="language-shell"># kubectl
curl -LO &quot;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl&quot;
# 校验和
curl -LO &quot;https://dl.k8s.io/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256&quot;
# 校验
echo &quot;$(cat kubectl.sha256)  kubectl&quot; | sha256sum --check
# 移动
mv kubectl /usr/local/bin
</code></pre>
<h2 id="准备"><a class="header" href="#准备">准备</a></h2>
<h3 id="配置容器-cgroup-驱动"><a class="header" href="#配置容器-cgroup-驱动">配置容器 cgroup 驱动</a></h3>
<blockquote>
<p><a href="https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/#docker">dokcer配置systemd作cgroup驱动</a>；</p>
<p><a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/configure-cgroup-driver/#%E9%85%8D%E7%BD%AE-kubelet-%E7%9A%84-cgroup-%E9%A9%B1%E5%8A%A8">kubelet配置systemd作cgroup驱动</a>；</p>
</blockquote>
<p>1.22及之后<code>kubeadm init</code>默认使用 <code>systemd</code> 作为 kubelet 的 cgroup 驱动，而不是 <code>cgroupfs</code>。这里顺手加上<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云 docker 镜像源</a>。</p>
<pre><code class="language-shell"># docker配置systemd作cgroup驱动。
# 否则kubeadm init报错dial tcp 127.0.0.1:10248: connect: connection refused
# 另外配置了日志、镜像源、免证书验证仓库
cat &lt;&lt;EOF | tee /etc/docker/daemon.json
{
  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],
  &quot;log-driver&quot;: &quot;json-file&quot;,
  &quot;log-opts&quot;: {
    &quot;max-size&quot;: &quot;100m&quot;
  },
  &quot;storage-driver&quot;: &quot;overlay2&quot;,
  &quot;registry-mirrors&quot;: [&quot;https://ohm5orzk.mirror.aliyuncs.com&quot;],
  &quot;insecure-registries&quot;: [&quot;registry.aliyuncs.com&quot;] # [&quot;192.168.xxx.xxx:5000&quot;,&quot;registry.aliyuncs.com&quot;]
}
EOF
# 启用配置并重启docker
systemctl daemon-reload &amp;&amp; systemctl restart docker

# kubelet配置systemd作cgroup驱动。1.23版本默认为systemd，无需配置
</code></pre>
<h3 id="控制平面准备"><a class="header" href="#控制平面准备">控制平面准备</a></h3>
<pre><code class="language-shell"># 设置 hostname
hostnamectl set-hostname 192.168.31.11

# 主节点添加本机 DNS 映射
sed -i '$a192.168.31.11 kubecpe' /etc/hosts
</code></pre>
<h3 id="数据平面准备"><a class="header" href="#数据平面准备">数据平面准备</a></h3>
<pre><code class="language-shell"># 设置 hostname
hostnamectl set-hostname 192.168.31.15
</code></pre>
<h2 id="集群创建"><a class="header" href="#集群创建">集群创建</a></h2>
<p>准备3台完成安装的机器</p>
<h3 id="kubeadm"><a class="header" href="#kubeadm">kubeadm</a></h3>
<p><a href="https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/">kubeadm 参考指南</a>。</p>
<h4 id="控制平面"><a class="header" href="#控制平面">控制平面</a></h4>
<p><a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E8%8A%82%E7%82%B9">初始化控制平面节点</a>。注意要再次运行 <code>kubeadm init</code>，必须首先<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#tear-down">卸载集群</a>。如果是非root用户</p>
<pre><code class="language-shell"># --apiserver-advertise-address 设置 master ip
# --image-repository 指定阿里云镜像仓库地址，因为默认拉取镜像地址 k8s.gcr.io 国内无法访问；
$ kubeadm init \
--node-name 192.168.31.11 \
--control-plane-endpoint=kubecpe \
--apiserver-advertise-address=192.168.31.11 \
--pod-network-cidr=10.244.0.0/16 \
--image-repository registry.aliyuncs.com/google_containers

# 创建成功后得到如下操作提示
......
Your Kubernetes control-plane has initialized successfully!

# 如何开始使用集群（kubectl）
To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

Alternatively, if you are the root user, you can run:

  export KUBECONFIG=/etc/kubernetes/admin.conf

# 如何安装 pod 网络
You should now deploy a pod network to the cluster.
Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

# 如何添加控制平面节点
You can now join any number of control-plane nodes by copying certificate authorities
and service account keys on each node and then running the following as root:

  kubeadm join kubecpe:6443 --token nhn70c.ck1r8ceu4j4pq3ep \
        --discovery-token-ca-cert-hash sha256:55b9644fc941d4928f40baa30a700973cf375b826fdb8e00012797cdbe0c90c1 \
        --control-plane

# 如何添加工作节点
Then you can join any number of worker nodes by running the following on each as root:

kubeadm join kubecpe:6443 --token nhn70c.ck1r8ceu4j4pq3ep \
        --discovery-token-ca-cert-hash sha256:55b9644fc941d4928f40baa30a700973cf375b826fdb8e00012797cdbe0c90c1
</code></pre>
<h4 id="使用集群"><a class="header" href="#使用集群">使用集群</a></h4>
<p>复制 /etc/kubernetes/admin.conf 到 $HOME/.kube/config 即可使用 kubectl</p>
<pre><code class="language-shell">mkdir ~/.kube
cp -i /etc/kubernetes/admin.conf ~/.kube/config
chown $(id -u):$(id -g) ~/.kube/config
</code></pre>
<h4 id="pod-网络"><a class="header" href="#pod-网络">pod 网络</a></h4>
<p><a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#pod-network">安装 pod 网络</a>。从 <a href="https://github.com/flannel-io/flannel/blob/v0.15.1/Documentation/kube-flannel.yml">flannel github</a> 上复制下来使用，使用 -f 直接指定或者使用 wget 下载后 -f 指定，都会出现 yaml 解析错误</p>
<p>如有需要请<a href="https://huangzhongde.cn/istio/Chapter6/Chapter6-8.html">配置网卡</a>。</p>
<pre><code class="language-shell"># 部署 kube-flannel
kubectl apply -f /mnt/share/kube-flannel.yaml
</code></pre>
<h4 id="工作节点"><a class="header" href="#工作节点">工作节点</a></h4>
<p>集群<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#join-nodes">加入节点</a>。如果前面提示的 token 和 hash 已经找不到了，可以在控制平面节点上查看 token 和 hash</p>
<pre><code class="language-shell"># 查看 token 列表
kubeadm token list
# 或者创建新的 token
kubeadm token create
# 查看 CA 公钥的哈希值
openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //'
</code></pre>
<p>然后在工作节点上通过 <code>kubeadm join --token &lt;token&gt; &lt;control-plane-host&gt;:&lt;control-plane-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</code> 加入集群。</p>
<pre><code class="language-shell"># 工作节点添加控制平面节点的 DNS 映射
sed -i '$a192.168.31.11 kubecpe' /etc/hosts
# 加入集群
kubeadm join kubecpe:6443 \
--node-name 192.168.31.11 \
--token st4khy.2j4qmbuge5mh1d76 \
--discovery-token-ca-cert-hash sha256:55b9644fc941d4928f40baa30a700973cf375b826fdb8e00012797cdbe0c90c1
</code></pre>
<h4 id="节点删除"><a class="header" href="#节点删除">节点删除</a></h4>
<blockquote>
<p>节点清理</p>
</blockquote>
<p>先在节点上重置 kubeadm 安装的状态，然后通过 kubectl 删除节点即可。主节点只需调用 <code>kubeadm reset</code> 会进行尽力而为的清理</p>
<pre><code class="language-shell"># 使节点不调度
kubectl drain &lt;node name&gt; --delete-emptydir-data --force --ignore-daemonsets
kubeadm reset
kubectl delete node &lt;node_name&gt;
</code></pre>
<h4 id="网络卸载"><a class="header" href="#网络卸载">网络卸载</a></h4>
<p>重置过程 <code>kubeadm reset</code> 不会重置或清除 iptables 规则或 IPVS 表</p>
<pre><code class="language-shell"># iptables清理
iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X
</code></pre>
<pre><code class="language-shell"># IPVS 清理
ipvsadm -C
</code></pre>
<p>网卡清理</p>
<pre><code class="language-shell"># flannel，清理完需重启 kubelet
kubectl delete -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
ifconfig cni0 down
ip link delete cni0
ifconfig flannel.1 down
ip link delete flannel.1
rm -rf /var/lib/cni/
rm -f /etc/cni/net.d/*
systemctl restart kubelet
</code></pre>
<h3 id="最佳实践"><a class="header" href="#最佳实践">最佳实践</a></h3>
<h4 id="tls-证书和秘钥"><a class="header" href="#tls-证书和秘钥">TLS 证书和秘钥</a></h4>
<p>安装 CFSSL</p>
<pre><code class="language-shell">$ go get -u github.com/cloudflare/cfssl/cmd/...
$ ls $GOPATH/bin/cfssl*
/root/go/path/bin/cfssl         /root/go/path/bin/cfssl-certinfo  /root/go/path/bin/cfssl-newkey
/root/go/path/bin/cfssl-bundle  /root/go/path/bin/cfssljson       /root/go/path/bin/cfssl-scan
</code></pre>
<h5 id="ca-证书"><a class="header" href="#ca-证书">CA 证书</a></h5>
<p>创建 CA 配置文件。</p>
<pre><code class="language-shell">$ cfssl print-defaults config &gt; config.json
$ cfssl print-defaults csr &gt; csr.json

# 根据 config.json 文件的格式创建如下的 ca-config.json 文件，过期时间设置成了 87600h
$ cat &gt; ca-config.json &lt;&lt;EOF
{
  &quot;signing&quot;: {
    &quot;default&quot;: {
      &quot;expiry&quot;: &quot;87600h&quot;
    },
    &quot;profiles&quot;: {
      &quot;kubernetes&quot;: {
        &quot;usages&quot;: [
            &quot;signing&quot;,
            &quot;key encipherment&quot;,
            &quot;server auth&quot;,
            &quot;client auth&quot;
        ],
        &quot;expiry&quot;: &quot;87600h&quot;
      }
    }
  }
}
EOF
</code></pre>
<p>字段说明：</p>
<ul>
<li><code>ca-config.json</code>：可以定义多个 profiles，分别指定不同的过期时间、使用场景等参数；后续在签名证书时使用某个 profile；</li>
<li><code>signing</code>：表示该证书可用于签名其它证书；生成的 ca.pem 证书中 <code>CA=TRUE</code>；</li>
<li><code>server auth</code>：表示client可以用该 CA 对server提供的证书进行验证；</li>
<li><code>client auth</code>：表示server可以用该CA对client提供的证书进行验证；</li>
</ul>
<p>创建 CA 证书签名请求文件</p>
<pre><code class="language-shell">cat &gt; ca-csr.json &lt;&lt; EOF
&gt; {
&gt;   &quot;CN&quot;: &quot;kubernetes&quot;,
&gt;   &quot;key&quot;: {
&gt;     &quot;algo&quot;: &quot;rsa&quot;,
&gt;     &quot;size&quot;: 2048
&gt;   },
&gt;   &quot;names&quot;: [
&gt;     {
&gt;       &quot;C&quot;: &quot;CN&quot;,
&gt;       &quot;ST&quot;: &quot;BeiJing&quot;,
&gt;       &quot;L&quot;: &quot;BeiJing&quot;,
&gt;       &quot;O&quot;: &quot;k8s&quot;,
&gt;       &quot;OU&quot;: &quot;System&quot;
&gt;     }
&gt;   ],
&gt;     &quot;ca&quot;: {
&gt;        &quot;expiry&quot;: &quot;87600h&quot;
&gt;     }
&gt; }
&gt; EOF
</code></pre>
<p>字段说明：</p>
<ul>
<li>&quot;CN&quot;：<code>Common Name</code>，kube-apiserver 从证书中提取该字段作为请求的用户名 (User Name)；浏览器使用该字段验证网站是否合法；</li>
<li>&quot;O&quot;：<code>Organization</code>，kube-apiserver 从证书中提取该字段作为请求用户所属的组 (Group)；</li>
</ul>
<p><strong>生成 CA 证书和私钥</strong>。</p>
<pre><code class="language-shell">$ cfssl gencert -initca ca-csr.json | cfssljson -bare ca
$ ls ca*
ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem
</code></pre>
<h5 id="kubernetes-证书"><a class="header" href="#kubernetes-证书">kubernetes 证书</a></h5>
<p>创建 kubernetes 证书签名请求文件</p>
<pre><code class="language-shell">$ cat &gt; kubernetes-csr.json &lt;&lt; EOF
&gt; {
&gt;     &quot;CN&quot;: &quot;kubernetes&quot;,
&gt;     &quot;hosts&quot;: [
&gt;       &quot;127.0.0.1&quot;,
&gt;       &quot;172.20.0.112&quot;,
&gt;       &quot;172.20.0.113&quot;,
&gt;       &quot;172.20.0.114&quot;,
&gt;       &quot;172.20.0.115&quot;,
&gt;       &quot;10.254.0.1&quot;,
&gt;       &quot;kubernetes&quot;,
&gt;       &quot;kubernetes.default&quot;,
&gt;       &quot;kubernetes.default.svc&quot;,
&gt;       &quot;kubernetes.default.svc.cluster&quot;,
        &quot;algo&quot;: &quot;rsa&quot;,
&gt;       &quot;kubernetes.default.svc.cluster.local&quot;
&gt;     ],
&gt;     &quot;key&quot;: {
&gt;         &quot;algo&quot;: &quot;rsa&quot;,
&gt;         &quot;size&quot;: 2048
&gt;     },
&gt;     &quot;names&quot;: [
&gt;         {
&gt;             &quot;C&quot;: &quot;CN&quot;,
&gt;             &quot;ST&quot;: &quot;BeiJing&quot;,
&gt;             &quot;L&quot;: &quot;BeiJing&quot;,
&gt;             &quot;O&quot;: &quot;k8s&quot;,
&gt;             &quot;OU&quot;: &quot;System&quot;
&gt;         }
&gt;     ]
&gt; }
&gt; EOF
</code></pre>
<ul>
<li>如果 hosts 字段不为空则需要指定授权使用该证书的 <strong>IP 或域名列表</strong>，由于该证书后续被 <code>etcd</code> 集群和 <code>kubernetes master</code> 集群使用，所以上面分别指定了 <code>etcd</code> 集群、<code>kubernetes master</code> 集群的主机 IP 和 <strong><code>kubernetes</code> 服务的服务 IP</strong>（一般是 <code>kube-apiserver</code> 指定的 <code>service-cluster-ip-range</code> 网段的第一个IP，如 10.254.0.1）。</li>
<li>这是最小化安装的kubernetes集群，包括一个私有镜像仓库，三个节点的kubernetes集群，以上物理节点的IP也可以更换为主机名。</li>
</ul>
<p><strong>生成 kubernetes 证书和私钥</strong></p>
<pre><code class="language-shell">$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kubernetes-csr.json | cfssljson -bare kubernetes
$ ls kubernetes*
kubernetes.csr  kubernetes-csr.json  kubernetes-key.pem  kubernetes.pem
</code></pre>
<h5 id="admin-证书"><a class="header" href="#admin-证书">admin 证书</a></h5>
<p>创建 admin 证书签名请求文件</p>
<pre><code class="language-shell">$ cat &gt; admin-csr.json &lt;&lt; EOF
&gt; {
&gt;   &quot;CN&quot;: &quot;admin&quot;,
&gt;   &quot;hosts&quot;: [],
&gt;   &quot;key&quot;: {
&gt;     &quot;algo&quot;: &quot;rsa&quot;,
&gt;     &quot;size&quot;: 2048
&gt;   },
&gt;   &quot;names&quot;: [
&gt;     {
&gt;       &quot;C&quot;: &quot;CN&quot;,
&gt;       &quot;ST&quot;: &quot;BeiJing&quot;,
&gt;       &quot;L&quot;: &quot;BeiJing&quot;,
&gt;       &quot;O&quot;: &quot;system:masters&quot;,
&gt;       &quot;OU&quot;: &quot;System&quot;
&gt;     }
&gt;   ]
&gt; }
&gt; EOF
</code></pre>
<ul>
<li>后续 <code>kube-apiserver</code> 使用 <code>RBAC</code> 对客户端(如 <code>kubelet</code>、<code>kube-proxy</code>、<code>Pod</code>)请求进行授权；</li>
<li><code>kube-apiserver</code> 预定义了一些 <code>RBAC</code> 使用的 <code>RoleBindings</code>，如 <code>cluster-admin</code> 将 Group <code>system:masters</code> 与 Role <code>cluster-admin</code> 绑定，该 Role 授予了调用<code>kube-apiserver</code> 的<strong>所有 API</strong>的权限；</li>
<li>O 指定该证书的 Group 为 <code>system:masters</code>，<code>kubelet</code> 使用该证书访问 <code>kube-apiserver</code> 时 ，由于证书被 CA 签名，所以认证通过，同时由于证书用户组为经过预授权的 <code>system:masters</code>，所以被授予访问所有 API 的权限；</li>
</ul>
<p><strong>生成 admin 证书和私钥</strong></p>
<pre><code class="language-shell">$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin
$ ls admin*
admin.csr  admin-csr.json  admin-key.pem  admin.pem
</code></pre>
<p><strong>注意</strong>：这个admin 证书，是将来生成管理员用的kube config 配置文件用的，现在我们一般建议使用RBAC 来对kubernetes 进行角色权限控制， kubernetes 将证书中的CN 字段 作为User， O 字段作为 Group（具体参考<a href="https://jimmysong.io/kubernetes-handbook/guide/authentication.html"> Kubernetes中的用户与身份认证授权</a>中 X509 Client Certs 一段）。</p>
<p>在搭建完 kubernetes 集群后，我们可以通过命令: <code>kubectl get clusterrolebinding cluster-admin -o yaml</code> ,查看到 <code>clusterrolebinding cluster-admin</code> 的 subjects 的 kind 是 Group，name 是 <code>system:masters</code>。 <code>roleRef</code> 对象是 <code>ClusterRole cluster-admin</code>。 意思是凡是 <code>system:masters Group</code> 的 user 或者 <code>serviceAccount</code> 都拥有 <code>cluster-admin</code> 的角色。 因此我们在使用 kubectl 命令时候，才拥有整个集群的管理权限。</p>
<pre><code class="language-yaml">$ kubectl get clusterrolebinding cluster-admin -o yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;
  creationTimestamp: 2017-04-11T11:20:42Z
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  name: cluster-admin
  resourceVersion: &quot;52&quot;
  selfLink: /apis/rbac.authorization.k8s.io/v1/clusterrolebindings/cluster-admin
  uid: e61b97b2-1ea8-11e7-8cd7-f4e9d49f8ed0
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: system:masters
</code></pre>
<h5 id="kube-proxy-证书"><a class="header" href="#kube-proxy-证书">kube-proxy 证书</a></h5>
<p>创建 kube-proxy 证书签名请求文件</p>
<pre><code class="language-shell">$ cat &gt; kube-proxy-csr.json &lt;&lt; EOF
&gt; {
&gt;   &quot;CN&quot;: &quot;system:kube-proxy&quot;,
&gt;   &quot;hosts&quot;: [],
&gt;   &quot;key&quot;: {
&gt;     &quot;algo&quot;: &quot;rsa&quot;,
&gt;     &quot;size&quot;: 2048
&gt;   },
&gt;   &quot;names&quot;: [
&gt;     {
&gt;       &quot;C&quot;: &quot;CN&quot;,
&gt;       &quot;ST&quot;: &quot;BeiJing&quot;,
&gt;       &quot;L&quot;: &quot;BeiJing&quot;,
&gt;       &quot;O&quot;: &quot;k8s&quot;,
&gt;       &quot;OU&quot;: &quot;System&quot;
&gt;     }
&gt;   ]
&gt; }
&gt; EOF
</code></pre>
<ul>
<li>CN 指定该证书的 User 为 <code>system:kube-proxy</code>；</li>
<li><code>kube-apiserver</code> 预定义的 RoleBinding <code>system:node-proxier</code> 将User <code>system:kube-proxy</code> 与 Role <code>system:node-proxier</code> 绑定，该 Role 授予了调用 <code>kube-apiserver</code> Proxy 相关 API 的权限；</li>
</ul>
<p>生成 kube-proxy 客户端证书和私钥</p>
<pre><code class="language-shell">$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes  kube-proxy-csr.json | cfssljson -bare kube-proxy
$ ls kube-proxy*
</code></pre>
<h5 id="校验证书"><a class="header" href="#校验证书">校验证书</a></h5>
<h6 id="使用-openssl"><a class="header" href="#使用-openssl">使用 openssl</a></h6>
<p>以 Kubernetes 证书为例，使用 openssl 命令读取证书信息</p>
<ul>
<li>确认 <code>Issuer</code> 字段的内容和 <code>ca-csr.json</code> 一致；</li>
<li>确认 <code>Subject</code> 字段的内容和 <code>kubernetes-csr.json</code> 一致；</li>
<li>确认 <code>X509v3 Subject Alternative Name</code> 字段的内容和 <code>kubernetes-csr.json</code> 一致；</li>
<li>确认 <code>X509v3 Key Usage、Extended Key Usage</code> 字段的内容和 <code>ca-config.json</code> 中 <code>kubernetes</code> profile 一致；</li>
</ul>
<pre><code class="language-shell">$ openssl x509  -noout -text -in  kubernetes.pem
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            03:0e:b4:83:5e:6d:02:fa:bf:62:21:aa:37:47:f1:c4:88:f4:8a:0c
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C = CN, ST = BeiJing, L = BeiJing, O = k8s, OU = System, CN = kubernetes
        Validity
            Not Before: Mar 12 12:04:00 2022 GMT
            Not After : Mar  9 12:04:00 2032 GMT
        Subject: C = CN, ST = BeiJing, L = BeiJing, O = k8s, OU = System, CN = kubernetes
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: (2048 bit)
                Modulus:
                    ......
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Key Usage: critical
                Digital Signature, Key Encipherment
            X509v3 Extended Key Usage:
                TLS Web Server Authentication, TLS Web Client Authentication
            X509v3 Basic Constraints: critical
                CA:FALSE
            X509v3 Subject Key Identifier:
                B7:15:10:43:1B:E1:53:B0:6A:12:56:5B:A5:CD:EF:77:E4:A0:79:F4
            X509v3 Subject Alternative Name:
                DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster, DNS:kubernetes.default.svc.cluster.local, IP Address:127.0.0.1, IP Address:172.20.0.112, IP Address:172.20.0.113, IP Address:172.20.0.114, IP Address:172.20.0.115, IP Address:10.254.0.1
    Signature Algorithm: sha256WithRSAEncryption
         ......
</code></pre>
<h6 id="使用cfssl-certinfo"><a class="header" href="#使用cfssl-certinfo">使用cfssl-certinfo</a></h6>
<pre><code class="language-shell">cfssl-certinfo -cert kubernetes.pem
{
  &quot;subject&quot;: {
    &quot;common_name&quot;: &quot;kubernetes&quot;,
    &quot;country&quot;: &quot;CN&quot;,
    &quot;organization&quot;: &quot;k8s&quot;,
    &quot;organizational_unit&quot;: &quot;System&quot;,
    &quot;locality&quot;: &quot;BeiJing&quot;,
    &quot;province&quot;: &quot;BeiJing&quot;,
    &quot;names&quot;: [
      &quot;CN&quot;,
      &quot;BeiJing&quot;,
      &quot;BeiJing&quot;,
      &quot;k8s&quot;,
      &quot;System&quot;,
      &quot;kubernetes&quot;
    ]
  },
  &quot;issuer&quot;: {
    &quot;common_name&quot;: &quot;kubernetes&quot;,
    &quot;country&quot;: &quot;CN&quot;,
    &quot;organization&quot;: &quot;k8s&quot;,
    &quot;organizational_unit&quot;: &quot;System&quot;,
    &quot;locality&quot;: &quot;BeiJing&quot;,
    &quot;province&quot;: &quot;BeiJing&quot;,
    &quot;names&quot;: [
      &quot;CN&quot;,
      &quot;BeiJing&quot;,
      &quot;BeiJing&quot;,
      &quot;k8s&quot;,
      &quot;System&quot;,
      &quot;kubernetes&quot;
    ]
  },
  &quot;serial_number&quot;: &quot;17454907659222183176468532411310969421540133388&quot;,
  &quot;sans&quot;: [
    &quot;kubernetes&quot;,
    &quot;kubernetes.default&quot;,
    &quot;kubernetes.default.svc&quot;,
    &quot;kubernetes.default.svc.cluster&quot;,
    &quot;kubernetes.default.svc.cluster.local&quot;,
    &quot;127.0.0.1&quot;,
    &quot;172.20.0.112&quot;,
    &quot;172.20.0.113&quot;,
    &quot;172.20.0.114&quot;,
    &quot;172.20.0.115&quot;,
    &quot;10.254.0.1&quot;
  ],
  &quot;not_before&quot;: &quot;2022-03-12T12:04:00Z&quot;,
  &quot;not_after&quot;: &quot;2032-03-09T12:04:00Z&quot;,
  &quot;sigalg&quot;: &quot;SHA256WithRSA&quot;,
  &quot;authority_key_id&quot;: &quot;&quot;,
  &quot;subject_key_id&quot;: &quot;B7:15:10:43:1B:E1:53:B0:6A:12:56:5B:A5:CD:EF:77:E4:A0:79:F4&quot;,
  &quot;pem&quot;: &quot;-----BEGIN CERTIFICATE-----\nMIIEajCCA1KgAwIBAgIUAw60g15tAvq/YiGqN0fxxIj0igwwDQYJKoZIhvcNAQEL\nBQAwZTELMAkGA1UEBhMCQ04xEDAOBgNVBAgTB0JlaUppbmcxEDAOBgNVBAcTB0Jl\naUppbmcxDDAKBgNVBAoTA2s4czEPMA0GA1UECxMGU3lzdGVtMRMwEQYDVQQDEwpr\ndWJlcm5ldGVzMB4XDTIyMDMxMjEyMDQwMFoXDTMyMDMwOTEyMDQwMFowZTELMAkG\nA1UEBhMCQ04xEDAOBgNVBAgTB0JlaUppbmcxEDAOBgNVBAcTB0JlaUppbmcxDDAK\nBgNVBAoTA2s4czEPMA0GA1UECxMGU3lzdGVtMRMwEQYDVQQDEwprdWJlcm5ldGVz\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA3QrEXpJnjVNsYnFGnu4f\nJG99y/P49uL0VTEZP4+6X/NRN1Fq9clX8acDHQcYBPud6OSI2Lvah9hxKQTpmIIQ\nky2lEnA64c9BDU5x0CUP5UOzwryjddFshHfvNOg7dySR3hzOKiKac31RKCtOo3OB\nlVctX+ksm1dAsTuGoAvYXKTl2fbR6p+Ew7tkMjbtaghXS9MXVy3RN1t7G3X9Xj9U\ndHnfdTCtTVxJF6kRrOBuP3ad+YDj6QAk8jXKefkFzfezj+w1g1zPJXcTtSko/YiH\n9A0lfiKxiv+6RGoXWQRnMT1J2Or8sKP0yWb0qLkk/+jINCiNulLL+mDQrEVlSSn3\ncwIDAQABo4IBEDCCAQwwDgYDVR0PAQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUF\nBwMBBggrBgEFBQcDAjAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBS3FRBDG+FTsGoS\nVlulze935KB59DCBrQYDVR0RBIGlMIGiggprdWJlcm5ldGVzghJrdWJlcm5ldGVz\nLmRlZmF1bHSCFmt1YmVybmV0ZXMuZGVmYXVsdC5zdmOCHmt1YmVybmV0ZXMuZGVm\nYXVsdC5zdmMuY2x1c3RlcoIka3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVy\nLmxvY2FshwR/AAABhwSsFABwhwSsFABxhwSsFAByhwSsFABzhwQK/gABMA0GCSqG\nSIb3DQEBCwUAA4IBAQAJTaKt98jCvsRo2vq9RvK732UO4tgYdhyAcQTREvsEyjdT\nYlA85xix0I9j5MlBgyfplQLCIobGjjdmkIdVcJsciPaqRdCjurHkDF5pBs4m/qlr\nfhxjEjZr36aT3/taq5xUA//TkCTb9p8Ijm+3AMdPGxovXE/TokEYcXDNasaVYsLY\naBxKDv3Bymwv9RIzPDrcNnn7llsCba6IX+L8u3TB4GIOxv7yH6XwVhqAFKh1yXUZ\n6H8Wky5z8l91virnRBfi3y4jJsl/odIznp16We8VnWCA36eTzBwOOEZiU3MvlPYc\nei7FKCGN5U3ZwwLsTMH2WzWX+Zw+dZGA97FmDYnX\n-----END CERTIFICATE-----\n&quot;
}
</code></pre>
<h5 id="颁发证书"><a class="header" href="#颁发证书">颁发证书</a></h5>
<p>将生成的证书和秘钥文件（后缀名为<code>.pem</code>）拷贝到所有（需要的）机器（包括当前）的 <code>/etc/kubernetes/ssl</code> 目录下备用</p>
<pre><code class="language-shell">mkdir -p /etc/kubernetes/ssl &amp;&amp; cp *.pem /etc/kubernetes/ssl
</code></pre>
<h4 id="kubelet"><a class="header" href="#kubelet">kubelet</a></h4>
<pre><code class="language-shell">export KUBE_APISERVER=&quot;https://kubecpe:6443&quot;

# 设置集群参数
kubectl config set-cluster kubernetes \
  --certificate-authority=/etc/kubernetes/ssl/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER}
# 设置客户端认证参数
kubectl config set-credentials admin \
  --client-certificate=/etc/kubernetes/ssl/admin.pem \
  --embed-certs=true \
  --client-key=/etc/kubernetes/ssl/admin-key.pem
# 设置上下文参数
kubectl config set-context kubernetes \
  --cluster=kubernetes \
  --user=admin
# 设置默认上下文
kubectl config use-context kubernetes
</code></pre>
<ul>
<li><code>admin.pem</code> 证书 OU 字段值为 <code>system:masters</code>，<code>kube-apiserver</code> 预定义的 RoleBinding <code>cluster-admin</code> 将 Group <code>system:masters</code> 与 Role <code>cluster-admin</code> 绑定，该 Role 授予了调用<code>kube-apiserver</code> 相关 API 的权限；</li>
<li>生成的 kubeconfig 被保存到 <code>~/.kube/config</code> 文件；</li>
</ul>
<p><strong>注意：</strong><code>~/.kube/config</code>文件拥有对该集群的最高权限，请妥善保管。</p>
<h4 id="kubeconfig"><a class="header" href="#kubeconfig">kubeconfig</a></h4>
<h5 id="tls-bootstrapping-token"><a class="header" href="#tls-bootstrapping-token">TLS Bootstrapping Token</a></h5>
<p>Token可以是任意的包含128 bit的字符串，可以使用安全的随机数发生器生成。</p>
<pre><code class="language-shell">export BOOTSTRAP_TOKEN=$(head -c 16 /dev/urandom | od -An -t x | tr -d ' ')

cat &gt; token.csv &lt;&lt;EOF
${BOOTSTRAP_TOKEN},kubelet-bootstrap,10001,&quot;system:kubelet-bootstrap&quot;
EOF

# 检查 token.csv 文件，确认其中的 ${BOOTSTRAP_TOKEN} 环境变量已经被真实的值替换
cat token.csv
c16e2aa67b2d10569d68ee176af17017,kubelet-bootstrap,10001,&quot;system:kubelet-bootstrap&quot;
</code></pre>
<p><strong>BOOTSTRAP_TOKEN</strong> 将被写入到 kube-apiserver 使用的 token.csv 文件和 kubelet 使用的 <code>bootstrap.kubeconfig</code> 文件，如果后续重新生成了 BOOTSTRAP_TOKEN，则需要：</p>
<ol>
<li>更新 token.csv 文件，分发到所有机器 (master 和 node）的 /etc/kubernetes/ 目录下，分发到node节点上非必需；</li>
<li>重新生成 bootstrap.kubeconfig 文件，分发到所有 node 机器的 /etc/kubernetes/ 目录下；</li>
<li>重启 kube-apiserver 和 kubelet 进程；</li>
<li>重新 approve kubelet 的 csr 请求；</li>
</ol>
<pre><code class="language-shell">cp token.csv /etc/kubernetes/
</code></pre>
<h5 id="kubelet-bootstrapping-kubeconfig"><a class="header" href="#kubelet-bootstrapping-kubeconfig">kubelet bootstrapping kubeconfig</a></h5>
<pre><code class="language-shell">cd /etc/kubernetes
export KUBE_APISERVER=&quot;https://kubecpe:6443&quot;

# 设置集群参数
kubectl config set-cluster kubernetes \
  --certificate-authority=/etc/kubernetes/ssl/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=bootstrap.kubeconfig

# 设置客户端认证参数
kubectl config set-credentials kubelet-bootstrap \
  --token=${BOOTSTRAP_TOKEN} \
  --kubeconfig=bootstrap.kubeconfig

# 设置上下文参数
kubectl config set-context default \
  --cluster=kubernetes \
  --user=kubelet-bootstrap \
  --kubeconfig=bootstrap.kubeconfig

# 设置默认上下文
kubectl config use-context default --kubeconfig=bootstrap.kubeconfig
</code></pre>
<ul>
<li><code>--embed-certs</code> 为 <code>true</code> 时表示将 <code>certificate-authority</code> 证书写入到生成的 <code>bootstrap.kubeconfig</code> 文件中；</li>
<li>设置客户端认证参数时<strong>没有</strong>指定秘钥和证书，后续由 <code>kube-apiserver</code> 自动生成；</li>
</ul>
<h5 id="kube-proxy-kubeconfig"><a class="header" href="#kube-proxy-kubeconfig">kube-proxy kubeconfig</a></h5>
<pre><code class="language-shell">export KUBE_APISERVER=&quot;https://172.20.0.113:6443&quot;
# 设置集群参数
kubectl config set-cluster kubernetes \
  --certificate-authority=/etc/kubernetes/ssl/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=kube-proxy.kubeconfig
# 设置客户端认证参数
kubectl config set-credentials kube-proxy \
  --client-certificate=/etc/kubernetes/ssl/kube-proxy.pem \
  --client-key=/etc/kubernetes/ssl/kube-proxy-key.pem \
  --embed-certs=true \
  --kubeconfig=kube-proxy.kubeconfig
# 设置上下文参数
kubectl config set-context default \
  --cluster=kubernetes \
  --user=kube-proxy \
  --kubeconfig=kube-proxy.kubeconfig
# 设置默认上下文
kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig
</code></pre>
<h5 id="分发-kubeconfig"><a class="header" href="#分发-kubeconfig">分发 kubeconfig</a></h5>
<p>将两个 kubeconfig 文件分发到所有 Node 机器的 <code>/etc/kubernetes/</code> 目录</p>
<pre><code class="language-shell">cp bootstrap.kubeconfig kube-proxy.kubeconfig /etc/kubernetes/
</code></pre>
<h4 id="etcd"><a class="header" href="#etcd">etcd</a></h4>
<h5 id="准备-1"><a class="header" href="#准备-1">准备</a></h5>
<p>添加 hosts</p>
<pre><code class="language-shell">sed -i '$a192.168.43.201 kubecpe' /etc/hosts
</code></pre>
<h5 id="安装-1"><a class="header" href="#安装-1">安装</a></h5>
<pre><code class="language-shell">wget https://github.com/etcd-io/etcd/releases/download/v3.4.18/etcd-v3.4.18-linux-amd64.tar.gz
tar -xvf etcd-v3.4.18-linux-amd64.tar.gz
mv etcd-v3.1.5-linux-amd64/etcd* /usr/local/bin
</code></pre>
<h5 id="创建-etcd-的-systemd-unit-文件"><a class="header" href="#创建-etcd-的-systemd-unit-文件">创建 etcd 的 systemd unit 文件</a></h5>
<p>在/usr/lib/systemd/system/目录下创建文件etcd.service，内容如下。注意替换IP地址为你自己的etcd集群的主机IP。</p>
<pre><code class="language-toml">[Unit]
Description=Etcd Server
After=network.target
After=network-online.target
Wants=network-online.target
Documentation=https://github.com/coreos

[Service]
Type=notify
WorkingDirectory=/var/lib/etcd/
EnvironmentFile=-/etc/etcd/etcd.conf
ExecStart=/usr/local/bin/etcd \
  --name ${ETCD_NAME} \
  --cert-file=/etc/kubernetes/ssl/kubernetes.pem \
  --key-file=/etc/kubernetes/ssl/kubernetes-key.pem \
  --peer-cert-file=/etc/kubernetes/ssl/kubernetes.pem \
  --peer-key-file=/etc/kubernetes/ssl/kubernetes-key.pem \
  --trusted-ca-file=/etc/kubernetes/ssl/ca.pem \
  --peer-trusted-ca-file=/etc/kubernetes/ssl/ca.pem \
  --initial-advertise-peer-urls ${ETCD_INITIAL_ADVERTISE_PEER_URLS} \
  --listen-peer-urls ${ETCD_LISTEN_PEER_URLS} \
  --listen-client-urls ${ETCD_LISTEN_CLIENT_URLS},http://127.0.0.1:2379 \
  --advertise-client-urls ${ETCD_ADVERTISE_CLIENT_URLS} \
  --initial-cluster-token ${ETCD_INITIAL_CLUSTER_TOKEN} \
  --initial-cluster infra1=https://etce01:2380,infra2=https://etce02:2380,infra3=https://etce03:2380 \
  --initial-cluster-state new \
  --data-dir=${ETCD_DATA_DIR}
Restart=on-failure
RestartSec=5
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
</code></pre>
<ul>
<li>指定 <code>etcd</code> 的工作目录为 <code>/var/lib/etcd</code>，数据目录为 <code>/var/lib/etcd</code>，需在启动服务前创建这个目录，否则启动服务的时候会报错“Failed at step CHDIR spawning /usr/bin/etcd: No such file or directory”；</li>
<li>为了保证通信安全，需要指定 etcd 的公私钥(cert-file和key-file)、Peers 通信的公私钥和 CA 证书(peer-cert-file、peer-key-file、peer-trusted-ca-file)、客户端的CA证书（trusted-ca-file）；</li>
<li>创建 <code>kubernetes.pem</code> 证书时使用的 <code>kubernetes-csr.json</code> 文件的 <code>hosts</code> 字段<strong>包含所有 etcd 节点的IP</strong>，否则证书校验会出错；</li>
<li><code>--initial-cluster-state</code> 值为 <code>new</code> 时，<code>--name</code> 的参数值必须位于 <code>--initial-cluster</code> 列表中；</li>
</ul>
<p>完整 unit 文件见：<a href="https://jimmysong.io/kubernetes-handbook/systemd/etcd.service">etcd.service</a></p>
<p>环境变量配置文件<code>/etc/etcd/etcd.conf</code>。</p>
<pre><code class="language-ini"># [member]
ETCD_NAME=infra1
ETCD_DATA_DIR=&quot;/var/lib/etcd&quot;
ETCD_LISTEN_PEER_URLS=&quot;https://172.20.0.113:2380&quot;
ETCD_LISTEN_CLIENT_URLS=&quot;https://172.20.0.113:2379&quot;

#[cluster]
ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;https://172.20.0.113:2380&quot;
ETCD_INITIAL_CLUSTER_TOKEN=&quot;etcd-cluster&quot;
ETCD_ADVERTISE_CLIENT_URLS=&quot;https://172.20.0.113:2379&quot;
</code></pre>
<h2 id="时间同步"><a class="header" href="#时间同步">时间同步</a></h2>
<pre><code class="language-shell"># 在各节点上执行如下命令
yum install ntpdate -y
ntpdate time.windows.com
</code></pre>
<h2 id="命令补全--别名"><a class="header" href="#命令补全--别名">命令补全 &amp; 别名</a></h2>
<blockquote>
<p>详见 <a href="https://kubernetes.io/zh-cn/docs/tasks/tools/included/optional-kubectl-configs-bash-linux/">Linux 系统中的 bash 自动补全功能</a>。</p>
</blockquote>
<p>向 <code>~/.bashrc</code> 中添加内容，如果没有bash-completion需要先</p>
<pre><code class="language-shell"># 安装bash-completion
apt install -y bash-completion

# 加载
cat &gt;&gt; ~/.bashrc &lt;&lt; EOF


# bash-completion
source /usr/share/bash-completion/bash_completion
# kubectl
source &lt;(kubectl completion bash)
alias kc=kubectl
complete -o default -F __start_kubectl kc
EOF

# 更新
source .bashrc
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../计/语言/Go.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../计/操作系统/Linux.eBPF.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../计/语言/Go.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../计/操作系统/Linux.eBPF.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
