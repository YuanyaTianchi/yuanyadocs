<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Docker - YuanyaDocs</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../index.html">Root</a></li><li class="chapter-item expanded "><a href="../../模板.html"><strong aria-hidden="true">1.</strong> 模板</a></li><li class="chapter-item expanded "><a href="../../番.html"><strong aria-hidden="true">2.</strong> 番</a></li><li class="chapter-item expanded affix "><li class="part-title">技</li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> 操作系统</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../计/操作系统/Linux.html"><strong aria-hidden="true">3.1.</strong> Linux</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../计/操作系统/Linux.eBPF.html"><strong aria-hidden="true">3.1.1.</strong> Linux.eBPF</a></li></ol></li><li class="chapter-item expanded "><a href="../../计/操作系统/WSL.html"><strong aria-hidden="true">3.2.</strong> WSL</a></li><li class="chapter-item expanded "><a href="../../计/操作系统/Windows.html"><strong aria-hidden="true">3.3.</strong> Windows</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 虚拟化</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../计/虚拟化/OVS.html"><strong aria-hidden="true">4.1.</strong> OVS</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> OVN</div></li><li class="chapter-item expanded "><a href="../../计/虚拟化/虚拟网络.html"><strong aria-hidden="true">4.3.</strong> 虚拟网络技术</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 云原生</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> container</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.1.</strong> engine</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../计/云原生/容器.Docker.html" class="active"><strong aria-hidden="true">5.1.1.1.</strong> Docker</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.2.</strong> cri</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.2.1.</strong> Containerd</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.2.2.</strong> CRI-o</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.2.3.</strong> CRI-dockerd</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.3.</strong> oci</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.3.1.</strong> Runc</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.3.2.</strong> Kata</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.3.3.</strong> Gvisor</div></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../计/云原生/Kubernetes.html"><strong aria-hidden="true">5.2.</strong> Kuberntes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../计/云原生/Kubernetes.operator.html"><strong aria-hidden="true">5.2.1.</strong> operator</a></li></ol></li><li class="chapter-item expanded "><a href="../../计/云原生/Prometheus.html"><strong aria-hidden="true">5.3.</strong> Prometheus</a></li><li class="chapter-item expanded "><a href="../../计/云原生/Sealos.html"><strong aria-hidden="true">5.4.</strong> Sealos</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Kube-OVN</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.</strong> dfx</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.1.</strong> checkpoint-restore</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../计/云原生/CRIU.html"><strong aria-hidden="true">5.6.1.1.</strong> CRIU</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> AI</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../计/AI/深度学习.html"><strong aria-hidden="true">6.1.</strong> 深度学习</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../计/AI/机器学习.概念.html"><strong aria-hidden="true">6.1.1.</strong> 概念</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> 语言</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../计/语言/Go.html"><strong aria-hidden="true">7.1.</strong> Go</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> 工具</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../计/工具/VSCode.html"><strong aria-hidden="true">8.1.</strong> VSCode</a></li><li class="chapter-item expanded "><a href="../../计/工具/Git.html"><strong aria-hidden="true">8.2.</strong> Git</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">数</li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> 高等代数</div></li><li class="chapter-item expanded affix "><li class="part-title">戏</li><li class="chapter-item expanded "><a href="../../戏/崩坏星穹铁道.html"><strong aria-hidden="true">10.</strong> 崩坏星穹铁道</a></li><li class="chapter-item expanded "><a href="../../戏/noita.html"><strong aria-hidden="true">11.</strong> noita</a></li><li class="chapter-item expanded "><a href="../../戏/命运方舟.html"><strong aria-hidden="true">12.</strong> 命运方舟</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">YuanyaDocs</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>+++</p>
<p>title = &quot;Docker&quot;
description = &quot;Docker&quot;
tags = [&quot;it&quot;, &quot;container&quot;, &quot;docker&quot;]</p>
<p>+++</p>
<h1 id="docker"><a class="header" href="#docker">Docker</a></h1>
<blockquote>
<p><a href="https://www.docker.com/">官网</a>；<a href="https://docs.docker.com/reference/">文档</a>；<a href="https://docs.docker.com/engine/reference/commandline/docker/">命令</a>；</p>
<p><a href="https://hub.docker.com/">镜像仓库 DockerHub</a>；</p>
</blockquote>
<h2 id="----快开----"><a class="header" href="#----快开----">--- 快开 ---</a></h2>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<blockquote>
<p><a href="https://docs.docker.com/engine/install/">Install Docker Engine</a>；</p>
</blockquote>
<h3 id="ubuntu"><a class="header" href="#ubuntu">ubuntu</a></h3>
<blockquote>
<p><a href="https://docs.docker.com/engine/install/ubuntu/">Install Docker Engine on Ubuntu</a>；</p>
</blockquote>
<pre><code class="language-shell"># 勿在没有配置Docker APT源的情况下直接使用apt命令安装Docker
# 先卸载
apt remove -y docker.io docker docker-engine
</code></pre>
<p>ubuntu 后台运行的 openvpn 会<a href="https://askubuntu.com/questions/1302371/docker-ce-post-installation-configuration-failure-on-ubuntu-20-04">影响 docker-ce 安装</a>，产生<code>Errors were encountered while processing</code></p>
<pre><code class="language-shell"># 停止openvpn
service openvpn stop
</code></pre>
<p>安装</p>
<pre><code class="language-shell"># GPG 密钥
curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
# apt 源
echo &quot;deb [arch=&quot;$(dpkg --print-architecture)&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu &quot;$(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;)&quot; stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null

sudo apt update &amp;&amp; apt-cache madison docker-ce &amp;&amp; apt-cache madison containerd.io
sudo apt install -y docker-ce docker-ce-cli containerd.io
</code></pre>
<h3 id="centos"><a class="header" href="#centos">centos</a></h3>
<blockquote>
<p><a href="https://docs.docker.com/engine/install/rhel/">Install Docker Engine on RHEL</a>；</p>
</blockquote>
<pre><code class="language-sh"># 设置存储库
cat &gt;/etc/yum.repos.d/docker.repo&lt;&lt;EOF
[docker-ce-stable]
name=Docker CE Stable - $basearch
baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/$basearch/stable
enabled=1
gpgcheck=1
gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg
EOF

# 安装 Docker Engine 和 containerd。
# centos8 默认使用 podman 代替 docker，会提示冲突，根据提示使用 --allowerasing 替换冲突的软件包
yum install -y --allowerasing docker-ce docker-ce-cli containerd.io
</code></pre>
<h3 id="开机启动"><a class="header" href="#开机启动">开机启动</a></h3>
<pre><code class="language-shell"># 开机启动并立即启动
systemctl enable --now docker
</code></pre>
<h3 id="配置"><a class="header" href="#配置">配置</a></h3>
<blockquote>
<p>cgroup 驱动：<a href="https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/#docker">systemd</a>；</p>
<p>存储驱动：；</p>
<p>容器镜像仓库：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云</a>；</p>
<p>dockerd 代理；</p>
</blockquote>
<pre><code class="language-shell"># 配置 cgroup 驱动、存储驱动、 通用
cat &gt; /etc/docker/daemon.json &lt;&lt; EOF
{
  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],
  &quot;log-driver&quot;: &quot;json-file&quot;,
  &quot;log-opts&quot;: {
    &quot;max-size&quot;: &quot;100m&quot;
  },
  
  &quot;storage-driver&quot;: &quot;overlay2&quot;,
  
  &quot;registry-mirrors&quot;: [&quot;https://ohm5orzk.mirror.aliyuncs.com&quot;],
  &quot;insecure-registries&quot;: [&quot;192.168.xxx.xxx:5000&quot;,&quot;registry.aliyuncs.com&quot;],
  
  &quot;runtimes&quot;: {
    &quot;nvidia&quot;: {
      &quot;args&quot;: [],
      &quot;path&quot;: &quot;nvidia-container-runtime&quot;
    }
  }
}
EOF

# 配置 dockerd 代理
cat &gt; /etc/systemd/system/docker.service.d/proxy.conf &lt;&lt; EOF
[Service]
Environment=&quot;HTTP_PROXY=http://proxy.example.com:8080/&quot;
Environment=&quot;HTTPS_PROXY=https://proxy.example.com:8080/&quot;
Environment=&quot;NO_PROXY=127.0.0.1,私有仓库ip,example.com&quot;
EOF

# 重启
systemctl daemon-reload &amp;&amp; systemctl restart docker
# 检查
docker info
</code></pre>
<h2 id="----基操----"><a class="header" href="#----基操----">--- 基操 ---</a></h2>
<h3 id="dockerfile"><a class="header" href="#dockerfile">Dockerfile</a></h3>
<pre><code class="language-dockerfile">ARG BASE_IMAGE
FROM ${BASE_IMAGE}
MAINTAINER yuanya&lt;yuanyatianchi@google.com&gt;

ENV WORK_DIR /tmp
WORKDIR $WORK_DIR

EXPOSE 80

# ARG OUTPUT
# RUN mkdir ${OUTPUT}
# COPY ${OUTPUT}/main ${OUTPUT}/main

RUN 

ENTRYPOINT [&quot;bash&quot;]
</code></pre>
<h3 id="makefile"><a class="header" href="#makefile">Makefile</a></h3>
<pre><code class="language-makefile">NAME = aquickstart

# image
IMAGE_REPOSITORY=
IMAGE_VERSION = &quot;v0.0.1&quot;
IMAGE_NAME = $(IMAGE_REPOSITORY)$(NAME):$(IMAGE_VERSION)
ARG_BASE_IMAGE = &quot;ubuntu:2204&quot;

.PHONY: image
image: $(IMAGE_NAME)
$(IMAGE_NAME): Dockerfile
	docker build -t $(IMAGE_NAME) \
		--network host \
		--build-arg BASE_IMAGE=$(ARG_BASE_IMAGE) \
		.

.PHONY: image_tar
image_tar: | $(IMAGE_NAME)
	docker save -o $(NAME)-$(IMAGE_VERSION).tar $(IMAGE_NAME)

.PHONY: image_clean
image_clean:
$(IMAGE_NAME)_clean: | $(IMAGE_NAME)
	docker rmi $(IMAGE_NAME)

.PHONY: image_clean_none
image_clean_none:
	docker images | grep none | awk '{print $3}' | xargs docker rmi

# container
CONTAINER_NAME = $(NAME)
.PHONY: container_run
container_run: $(CONTAINER_NAME)_run
$(CONTAINER_NAME)_run: | $(IMAGE_NAME)
	docker run -d \
		--network=host \
		--restart=always \
		--name $(CONTAINER_NAME) \
		$(IMAGE_NAME)

CONTAINER_NAME = $(NAME)
.PHONY: container_update
container_update: $(CONTAINER_NAME)_update
$(CONTAINER_NAME)_update: | $(IMAGE_NAME)
	docker update \
		--network=host \
		--restart=always \
		--name $(CONTAINER_NAME)

# clean
.PHONY: clean
clean: | image_clean 
	docker images | grep none | awk '{print $3}' | xargs docker rmi
</code></pre>
<h2 id="批删"><a class="header" href="#批删">批删</a></h2>
<pre><code class="language-shell">docker images | grep none | awk '{print $3}' | xargs docker rmi
</code></pre>
<h2 id="镜像"><a class="header" href="#镜像">镜像</a></h2>
<h3 id="镜像仓库"><a class="header" href="#镜像仓库">镜像仓库</a></h3>
<h4 id="http"><a class="header" href="#http">http</a></h4>
<p>docker-registry 安装：使用官方 <code>registry</code> 镜像来安装执行。注意，此时启用的 registry 是一个 http server</p>
<pre><code class="language-shell"># 仓库默认被创建在容器的 /var/lib/registry 目录下，通过 -v 挂载主机目录，以将镜像文件持久存储到主机
docker run -d --restart=always --name registry -p 5000:5000 \
-v /var/lib/docker/registry:/var/lib/registry registry
</code></pre>
<p>在 Docker client 上，默认接收 https 响应，因此还 push 不了镜像，将出现错误 <code>http: server gave HTTP response to HTTPS client</code>，可以通过在 docker <strong>client 所在主机</strong>的 <code>/etc/docker/daemon.json</code> 中配置取消这个限制，<code>192.168.31.11:5000</code> 为 <strong>registry server</strong> 地址</p>
<pre><code class="language-json">{
  &quot;insecure-registries&quot;: [&quot;192.168.xxx.xxx:5000&quot;,&quot;registry.aliyuncs.com&quot;]
}
</code></pre>
<p>但kubelet通过cri调用时默认使用https，因此https更佳</p>
<h4 id="httpsca"><a class="header" href="#httpsca">https(ca)</a></h4>
<p>在 registry server 主机上创建证书，指定 server <a href="../it.crypto.tool.html#%E7%AD%BE%E5%8F%91%E9%85%8D%E7%BD%AE">配置</a>。</p>
<pre><code class="language-shell"># 证书签名请求
$ cat &gt; docker-csr.json &lt;&lt;EOF
{
    &quot;CN&quot;: &quot;docker&quot;,
    &quot;hosts&quot;: [
      &quot;127.0.0.1&quot;,
      &quot;192.168.31.11&quot;
    ],
    &quot;key&quot;: {
        &quot;algo&quot;: &quot;rsa&quot;,
        &quot;size&quot;: 2048
    },
    &quot;names&quot;: [
        {
            &quot;C&quot;: &quot;CN&quot;,
            &quot;ST&quot;: &quot;BeiJing&quot;,
            &quot;L&quot;: &quot;BeiJing&quot;,
            &quot;O&quot;: &quot;docker&quot;,
            &quot;OU&quot;: &quot;docker&quot;
        }
    ]
}
EOF

# 签发证书
$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=server docker-csr.json | cfssljson -bare docker
</code></pre>
<p>启动 https 的 registry server</p>
<pre><code class="language-shell"># -v 挂载证书所在目录，通过环境变量指定证书和key
docker run -d --restart=always --name registry -p 5000:5000 \
-v /var/lib/docker/registry:/var/lib/registry \
-v /etc/docker/ssl:/etc/docker/ssl \
-e REGISTRY_HTTP_ADDR=0.0.0.0:5000 \
-e REGISTRY_HTTP_TLS_CERTIFICATE=/etc/docker/ssl/docker.pem \
-e REGISTRY_HTTP_TLS_KEY=/etc/docker/ssl/docker-key.pem \
registry
</code></pre>
<p>此时 docker client 仍然无法访问私有仓库，将报错<code>Get &quot;https://192.168.31.11:5000/v2/&quot;: x509: certificate signed by unknown authority</code>，是私有仓库使用 server 证书是我们自己生成的 ca 证书签名的自签名证书，client 主机无法对其 CA 进行验证，需要下载 ca 证书到 <code>/etc/docker/certs.d/&lt;地址&gt;:&lt;端口&gt;</code>或<code>/etc/docker/certs.d/&lt;域名&gt;</code>目录下</p>
<pre><code class="language-shell"># client 端下载 ca 证书
scp -r root@192.168.31.11:/root/ssl/ca.pem /etc/docker/certs.d/192.168.31.11:5000/ca.crt
docker push 192.168.31.11:5000/guestbook:1.0
</code></pre>
<h4 id="httpspw"><a class="header" href="#httpspw">https(pw)</a></h4>
<pre><code class="language-shell">mkdir /etc/docker/auth
# 生成密码认证
htpasswd -Bbn admin admin &gt; /etc/docker/auth/htpasswd
# run时指定
docker run -d --restart=always --name registry -p 5000:5000 \
-v /var/lib/docker/registry:/var/lib/registry \
-v /etc/docker/auth:/etc/docker/auth \
-e REGISTRY_AUTH=htpasswd \
-e REGISTRY_AUTH_HTPASSWD_PATH=/etc/docker/auth/htpasswd \
-e REGISTRY_AUTH_HTPASSWD_REALM=&quot;Registry Realm&quot; \
registry

# 登录
docker login 192.168.31.11:5000
</code></pre>
<h3 id="镜像管理"><a class="header" href="#镜像管理">镜像管理</a></h3>
<h6 id="镜像搜索"><a class="header" href="#镜像搜索">镜像搜索</a></h6>
<h6 id="镜像拉取"><a class="header" href="#镜像拉取">镜像拉取</a></h6>
<h6 id="镜像导出"><a class="header" href="#镜像导出">镜像导出</a></h6>
<pre><code class="language-shell"># 一般导出命名后缀为.tar
docker save arm64v8/centos:latest -o ./centos.arm64.tar
</code></pre>
<h6 id="镜像导入"><a class="header" href="#镜像导入">镜像导入</a></h6>
<pre><code class="language-shell">docker load &lt; centos.arm64.tar
</code></pre>
<h6 id="镜像构建"><a class="header" href="#镜像构建">镜像构建</a></h6>
<p>https://www.runoob.com/docker/docker-build-command.html</p>
<pre><code class="language-shell"># 默认使用当前目录下的 Dockerfile 构建镜像
$ docker build -t yuanya:1.0 .
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>option</th><th>description</th></tr></thead><tbody>
<tr><td>-f</td><td>指定要使用的Dockerfile</td></tr>
<tr><td>-t;-tag</td><td>镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</td></tr>
</tbody></table>
</div>
<h6 id="提交容器为镜像"><a class="header" href="#提交容器为镜像">提交容器为镜像</a></h6>
<pre><code class="language-shell">docker commit 261314c94305 imagexxx
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>option</th><th>description</th></tr></thead><tbody>
<tr><td>-a</td><td>提交的镜像作者</td></tr>
<tr><td>-c</td><td>使用Dockerfile指令来创建镜像；</td></tr>
<tr><td>-m</td><td>提交时的说明文字；</td></tr>
<tr><td>-p</td><td>在commit时，将容器暂停。</td></tr>
</tbody></table>
</div>
<h3 id="跨平台构建"><a class="header" href="#跨平台构建">跨平台构建</a></h3>
<p>qemu-user-static：https://github.com/multiarch/qemu-user-static</p>
<p>https://juejin.cn/post/6844903605355577358</p>
<p>https://zhuanlan.zhihu.com/p/106054643</p>
<p>在x86机器上模拟arm架构指令来构建arm架构的镜像，使用 <a href="https://github.com/multiarch/qemu-user-static">multiarch/qemu-user-static</a> 来实现在x86主机上模拟arm环境</p>
<p><strong>multiarch/qemu-user-static</strong> 是通过 QEMU 和 binfmt_misc 启用不同多架构容器的执行。以下是 Docker 的示例。</p>
<p>通过 qemu-user-static （该程序使用内核 binfmt_misc 文件系统功能）可以模拟各种环境</p>
<pre><code class="language-shell"># 我的环境是 centos8
$ uname -mrs
Linux 4.18.0-305.7.1.el8_4.x86_64 x86_64

# 拉取一个 arm 的 centos 镜像
$ docker pull arm64v8/centos

# 在 x86 上执行一个 arm centos 镜像时，会因无法解析 arm 指令而报错
$ docker run --rm -t arm64v8/centos uname -m
standard_init_linux.go:211: exec user process caused &quot;exec format error&quot;

# 此时执行 qemu-user-static 镜像，将为我们设置模拟 arm 环境
$ docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
Setting /usr/bin/qemu-alpha-static as binfmt interpreter for alpha
Setting /usr/bin/qemu-arm-static as binfmt interpreter for arm
Setting /usr/bin/qemu-armeb-static as binfmt interpreter for armeb
Setting /usr/bin/qemu-sparc-static as binfmt interpreter for sparc
Setting /usr/bin/qemu-sparc32plus-static as binfmt interpreter for sparc32plus
Setting /usr/bin/qemu-sparc64-static as binfmt interpreter for sparc64
Setting /usr/bin/qemu-ppc-static as binfmt interpreter for ppc
Setting /usr/bin/qemu-ppc64-static as binfmt interpreter for ppc64
Setting /usr/bin/qemu-ppc64le-static as binfmt interpreter for ppc64le
Setting /usr/bin/qemu-m68k-static as binfmt interpreter for m68k
Setting /usr/bin/qemu-mips-static as binfmt interpreter for mips
Setting /usr/bin/qemu-mipsel-static as binfmt interpreter for mipsel
Setting /usr/bin/qemu-mipsn32-static as binfmt interpreter for mipsn32
Setting /usr/bin/qemu-mipsn32el-static as binfmt interpreter for mipsn32el
Setting /usr/bin/qemu-mips64-static as binfmt interpreter for mips64
Setting /usr/bin/qemu-mips64el-static as binfmt interpreter for mips64el
Setting /usr/bin/qemu-sh4-static as binfmt interpreter for sh4
Setting /usr/bin/qemu-sh4eb-static as binfmt interpreter for sh4eb
Setting /usr/bin/qemu-s390x-static as binfmt interpreter for s390x
Setting /usr/bin/qemu-aarch64-static as binfmt interpreter for aarch64
Setting /usr/bin/qemu-aarch64_be-static as binfmt interpreter for aarch64_be
Setting /usr/bin/qemu-hppa-static as binfmt interpreter for hppa
Setting /usr/bin/qemu-riscv32-static as binfmt interpreter for riscv32
Setting /usr/bin/qemu-riscv64-static as binfmt interpreter for riscv64
Setting /usr/bin/qemu-xtensa-static as binfmt interpreter for xtensa
Setting /usr/bin/qemu-xtensaeb-static as binfmt interpreter for xtensaeb
Setting /usr/bin/qemu-microblaze-static as binfmt interpreter for microblaze
Setting /usr/bin/qemu-microblazeel-static as binfmt interpreter for microblazeel
Setting /usr/bin/qemu-or1k-static as binfmt interpreter for or1k

# centos7会出现报错 sh: write error: Invalid argument，因为使用 -p yes 选项至少需要内核版本 4.10 上的 binfmt_misc，https://github.com/multiarch/qemu-user-static/issues/100。可以去掉 -p yes 选项，之后还有一堆其它问题，直接放弃，换 centos8 了
$ docker run --rm --privileged multiarch/qemu-user-static --reset

# 之后就可以执行这个 arm centos 镜像了，因为 qemu-user-static将arm架构的指令解释成x86架构的指令执行
$ docker run --rm -t arm64v8/centos uname -m
aarch64

# 这里将 hello.arm 所在目录挂载进来执行
docker run --rm -t -v /it/go/gopath/src/yuanyatianchi.io/hello/bin:/usr/bin/qemu-aarch64-static arm64v8/centos ls /go/bin
</code></pre>
<p>现在 arm64v8/centos 已经可以 run 了，将其作为基础镜像编写 Dockerfile ，build 后 run 起来即可，这里用一个 hello 代码</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	fmt.Println(&quot;hello&quot;)
}
</code></pre>
<pre><code class="language-dockerfile">FROM arm64v8/centos

COPY ./bin/hello /usr/bin
</code></pre>
<pre><code class="language-makefile">.PHONY: build-hello build-image export-image clean

# 构建程序
build-hello: ./cmd/hello.go
	CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -o ./bin/hello ./cmd/hello.go

# 构建镜像
build-image: build-hello
	docker build . -t hello:v1.0

# 导出镜像
export-image: build-image
	docker save hello:v1.0 -o ./bin/hello.tar

clean:
	rm -rf ./bin
</code></pre>
<pre><code class="language-shell"># 构建并导出镜像
$ make export-image
CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -o ./bin/hello ./cmd/hello.go
docker build . -t hello:v1.0
Sending build context to Docker daemon  7.443MB
Step 1/2 : FROM arm64v8/centos
 ---&gt; a0477e85b8ae
Step 2/2 : COPY ./bin/hello /usr/bin
 ---&gt; 8a0e7d42e2f7
Successfully built 8a0e7d42e2f7
Successfully tagged hello:v1.0
docker save hello:v1.0 -o ./bin/hello.tar

# 可以看到镜像包
$ ls ./bin/
hello  hello.tar

# 验证一下执行 hello
$ docker run --rm -t hello:v1.0 hello
hello
</code></pre>
<h2 id="容器"><a class="header" href="#容器">容器</a></h2>
<p>加载镜像运行容器</p>
<pre><code class="language-shell">docker run -it --name 容器名称 镜像名称 /bin.bash
</code></pre>
<p>启动</p>
<p>停止</p>
<h2 id="网络"><a class="header" href="#网络">网络</a></h2>
<h3 id="代理"><a class="header" href="#代理">代理</a></h3>
<p>https://note.qidong.name/2020/05/docker-proxy/</p>
<p>有时因为网络原因，比如公司NAT，或其它啥的，需要使用代理。 Docker的代理配置，略显复杂，因为有三种场景。 但基本原理都是一致的，都是利用Linux的<code>http_proxy</code>等环境变量。</p>
<h4 id="dockerd"><a class="header" href="#dockerd">dockerd</a></h4>
<p>https://docs.docker.com/config/daemon/systemd/</p>
<p>执行<code>docker pull</code>时，是由守护进程<code>dockerd</code>来执行。 因此，代理需要配在<code>dockerd</code>的环境中。 而这个环境，则是受<code>systemd</code>所管控，因此实际是<code>systemd</code>的配置。</p>
<pre><code class="language-shell">sudo mkdir -p /etc/systemd/system/docker.service.d
sudo touch /etc/systemd/system/docker.service.d/proxy.conf
</code></pre>
<p><code>proxy.conf</code>文件（可以是任意<code>*.conf</code>的形式）内容如下</p>
<pre><code class="language-ini">[Service]
Environment=&quot;HTTP_PROXY=http://proxy.example.com:8080/&quot;
Environment=&quot;HTTPS_PROXY=https://proxy.example.com:8080/&quot;
Environment=&quot;NO_PROXY=127.0.0.1,私有仓库ip,example.com&quot;
</code></pre>
<p>其中，<code>proxy.example.com:8080</code>要换成可用的免密代理。 通常使用<code>cntlm</code>在本机自建免密代理，去对接公司的代理。 可参考《<a href="https://note.qidong.name/2018/11/cntlm-proxy/">Linux下安装配置Cntlm代理</a>》。</p>
<p>重启。<code>dockerd</code>代理的修改比较特殊，它实际上是改<code>systemd</code>的配置，因此需要重载<code>systemd</code>并重启<code>dockerd</code>才能生效。</p>
<pre><code class="language-shell">sudo systemctl daemon-reload
sudo systemctl restart docker
</code></pre>
<h4 id="container"><a class="header" href="#container">container</a></h4>
<p>https://docs.docker.com/network/proxy/</p>
<p>在容器运行阶段，如果需要代理上网，则需要配置<code>~/.docker/config.json</code>。 以下配置，只在Docker 17.07及以上版本生效。</p>
<pre><code class="language-json">{
  &quot;proxies&quot;:
  {
    &quot;default&quot;:
    {
      &quot;httpProxy&quot;: &quot;http://proxy.example.com:8080&quot;,
      &quot;httpsProxy&quot;: &quot;http://proxy.example.com:8080&quot;,
      &quot;noProxy&quot;: &quot;localhost,127.0.0.1,.example.com&quot;
    }
  }
}
</code></pre>
<p>这个是用户级的配置，除了<code>proxies</code>，<code>docker login</code>等相关信息也会在其中。 而且还可以配置信息展示的格式、插件参数等。</p>
<p>此外，容器的网络代理，也可以直接在其运行时通过<code>-e</code>注入<code>http_proxy</code>等环境变量。 这两种方法分别适合不同场景。 <code>config.json</code>非常方便，默认在所有配置修改后启动的容器生效，适合个人开发环境。 在CI/CD的自动构建环境、或者实际上线运行的环境中，这种方法就不太合适，用<code>-e</code>注入这种显式配置会更好，减轻对构建、部署环境的依赖。 当然，在这些环境中，最好用良好的设计避免配置代理上网。</p>
<h4 id="docker-build"><a class="header" href="#docker-build">docker build</a></h4>
<p>https://docs.docker.com/engine/reference/commandline/cli/#automatic-proxy-configuration-for-containers</p>
<p>虽然<code>docker build</code>的本质，也是启动一个容器，但是环境会略有不同，用户级配置无效。 在构建时，需要注入<code>http_proxy</code>等参数。</p>
<pre><code class="language-sh">docker build . \
    --build-arg &quot;HTTP_PROXY=http://proxy.example.com:8080/&quot; \
    --build-arg &quot;HTTPS_PROXY=http://proxy.example.com:8080/&quot; \
    --build-arg &quot;NO_PROXY=localhost,127.0.0.1,.example.com&quot; \
    -t your/image:tag
</code></pre>
<p><strong>注意</strong>：无论是<code>docker run</code>还是<code>docker build</code>，默认是网络隔绝的。 如果代理使用的是<code>localhost:3128</code>这类，则会无效。 这类仅限本地的代理，必须加上<code>--network host</code>才能正常使用。 而一般则需要配置代理的外部IP，而且代理本身要开启gateway模式。</p>
<h3 id="修改docker0默认网段"><a class="header" href="#修改docker0默认网段">修改Docker0默认网段</a></h3>
<p>https://blog.51cto.com/lisea/1940023</p>
<p>Docker 服务启动后默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信，它还给出了 MTU（接口允许接收的最大传输单元），通常是 1500 Bytes，或宿主主机网络路由上支持的默认值。这些值都可以在服务启动的时候进行配置。</p>
<pre><code class="language-shell"># 查看
$ ifconfig docker0
docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500
        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:61:ff:7b:91  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</code></pre>
<p>修改文件 <code>/etc/docker/daemon.json</code> 添加内容 <code>&quot;bip&quot;: &quot;ip/netmask&quot;</code> 即可。注意切勿与宿主机同网段</p>
<pre><code class="language-json">{
  &quot;bip&quot;: &quot;192.168.100.1/24&quot;
}
</code></pre>
<pre><code class="language-shell"># 重启即可
$ systemctl restart docker
</code></pre>
<h2 id="client"><a class="header" href="#client">client</a></h2>
<p>命令：</p>
<h3 id="镜像-1"><a class="header" href="#镜像-1">镜像</a></h3>
<p>docker中一个centos镜像大小200m不到，docker相当于隔离了进程，</p>
<pre><code class="language-shell">$ docker images #本地镜像列表
$ docker search &lt;关键字&gt; #检索镜像
$ docker pull &lt;镜像名&gt;[:&lt;tag&gt;] #拉取镜像。tag指定版本，缺省则为latest
$ docker inspect &lt;镜像名&gt;#查看镜像详细信息
$ docker rmi &lt;镜像id&gt; #删除指定镜像

docker network ps
docker network rm &lt;网络名&gt; #注意几个默认的不要删除
</code></pre>
<h3 id="容器-1"><a class="header" href="#容器-1">容器</a></h3>
<ul>
<li>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</li>
<li>UnionFS (联合文件系统) : Union文件系统(UnionFS) 是一种分层、 轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种具体的应用镜像。
<ul>
<li>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</li>
</ul>
</li>
<li>Docker镜像加载原理：docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS.
<ul>
<li>bootfs(boot file system)主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权己由bootfs转交给内核，此时系统也会卸载bootfs。</li>
<li>rootfs (root file system)，在bootfs之 上。 包含的就是典型Linux系统中的/dev, /proc, /bin, /etc等标准目录和文件。rootfs 就是各种不同的操作系统发行版，比如Ubuntu，Centos等 等。</li>
<li>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了,因为底层直接用Host的kernel,自己只需要提供rootfs就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别,因此不同的发行版可以公用bootfs。</li>
</ul>
</li>
<li>分层的镜像：以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载很多镜像</li>
<li>最大的一个好处就是：共享资源
<ul>
<li>比如:有多个镜像都从相同的base镜像构建而来，那么宿主机只需在磁盘上保存一-份base镜像，同时内存中也只需加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</li>
</ul>
</li>
<li>Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容 器层”之下的都叫&quot;镜像层</li>
</ul>
<pre><code class="language-shell">$ docker ps #容器列表。-a表示所有包括未运行的容器
$ docker logs &lt;container-name | container-id&gt; #查看指定容器日志
$ docker run [--name &lt;container-name&gt;] [-d|-it] [-p &lt;container-port&gt;:&lt;port&gt;] [-e &lt;key&gt;:&lt;value&gt;] &lt;image-id&gt;  #运行指定容器。--name为容器取名；-d守护式运行（即后台运行），-it交互式运行（即进入容器交互）；-p指定将容器内的端口映射到实体机的端口；-e配置环境参数
$ docker start &lt;container-name | container-id&gt; #启动
$ docker restart &lt;container-name | container-id&gt; #重启
$ docker stop &lt;container-name | container-id&gt; #停止
$ docker stop &lt;container-name | container-id&gt; #强制停止
$ docker rm &lt;container-id&gt; #删除指定容器
$ docker rm -f $(docker ps -a -q) #条件批量删除
$ docker ps-a-q | xargs docker rm #条件批量删除

$ docker top &lt;container-id&gt;
$ docker commit &lt;container-id&gt; &lt;要创建的目标镜像名:[标签名]&gt;  -a=&quot;&lt;作者&gt;&quot; -m=&quot;&lt;提交的描述信息&gt;&quot;
 #提交容器副本使之成为一个新的镜像，可以docker ps -a看到
</code></pre>
<p>停止并删除所有容器</p>
<pre><code class="language-sh">docker stop $(docker ps -q)
docker rm $(docker ps -aq)
</code></pre>
<p>执行容器</p>
<pre><code class="language-shell">$ docker exec -it &lt;container-id&gt; &lt;bashshell&gt; #执行伪终端。-it表示-i -t，将为容器分配伪终端，可以进行交互
$ docker exec -it &lt;container-id&gt; /bin/bash
$ docker exec -it &lt;container-id&gt; bash
$ docker exec -it &lt;container-id&gt; ls /
$ docker attach &lt;container-id&gt; #重新进入
$ exit #退出容器交互并停止容器
ctrl+q+p #退出容器交互但容器不停止

$ docker cp &lt;container-id&gt;:/xxx/xxx.log /app/temp #拷贝容器中的文件到本地宿主主机
</code></pre>
<pre><code class="language-cmd">docker exec -it mysql8 bash #进入容器名为mysql8的容器
mysql -uroot -p123456 #进入mysql8后，可以使用mysql命令行，登录mysql

grant all privileges on *.* to 'root'@'%'; #添加权限，%表示所有ip可以登入，%可以替换为具体ip以给某ip开放root登入权限

#也可以这样到表中修改权限
use mysql; #进到mysql库
select host, user, plugin from user; #查看user表，可以看到root的host是localhost，只允许本地登入
update user set host='%' where user='root' #修改权限，%表示所有ip可以登入，%可以替换为具体ip以给某ip开放root登入权限

flush privileges; #重新加载权限
</code></pre>
<h2 id="容器数据卷"><a class="header" href="#容器数据卷">容器数据卷</a></h2>
<ul>
<li>持久化
<ul>
<li>将运用与运行的环境打包形成容器运行，运行可以伴随着容器，但是我们对数据的要求希望是持久化的</li>
<li>容器之间希望有可能共享数据</li>
<li>Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一 部分保存下来，那么当容器删除后，数据自然也就没有了。</li>
<li>为了能保存数据在docker中我们使用卷。</li>
</ul>
</li>
<li>卷就是目录或文件，存在于-一个或多个容器中，由docker挂 载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性:卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷
<ul>
<li>1:数据卷可在容器之间共享或重用数据</li>
<li>2: 卷中的更改可以直接生效</li>
<li>3:数据卷中的更改不会包含在镜像的更新中</li>
<li>4:数据卷的生命周期一直持续到没有容器使用它为止</li>
</ul>
</li>
</ul>
<h3 id="容器卷添加"><a class="header" href="#容器卷添加">容器卷添加</a></h3>
<h6 id="直接命令添加"><a class="header" href="#直接命令添加">直接命令添加</a></h6>
<pre><code class="language-shell">$ docker run &lt;指定镜像&gt; -it -v &lt;/宿主机绝对路径目录&gt;:&lt;/容器内目录&gt;  #-v指定host与container的数据同步目录，如果目录不存在则将创建目录，数据将实现实时同步，两边都可读写。-v参数可以多使用，形成一一对应的多对同步目录
$ docker run &lt;指定镜像&gt; -it -v &lt;/宿主机绝对路径目录&gt;:&lt;/容器内目录:ro&gt; #限制容器目录只读
</code></pre>
<h6 id="dockerfile添加"><a class="header" href="#dockerfile添加">DockerFile添加</a></h6>
<ul>
<li>新建/mydocker文件夹并进入</li>
<li>在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷
<ul>
<li>VOLUME[&quot;/dataVolumeContainer&quot;,&quot;/dataVolumeContainer2&quot;, &quot;/dataVolumeContainer3&quot;]</li>
<li>出于可移植和分享的考虑，用-v主机目录:容器目录这种方法不能够直接在Dockerfile中实现。由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。但是会有默认的目录，通过<code>docker inspect</code>即可查看到</li>
</ul>
</li>
</ul>
<pre><code class="language-dockerfile">#dockerfile，按序执行的脚本，每个FROM的镜像都会作为一层环境被装载
FROM centos
VOLUME [&quot; /dataVolumeContainerA&quot; ,&quot; /dataVolumeContainerB&quot; ]
CMD echo &quot;finished, -------- success1&quot;
CMD /bin/bash
</code></pre>
<ul>
<li>
<p>docker build生成镜像</p>
<pre><code class="language-shell">$ docker build -f /mydocker/dockerfile -t yuanya/centos . #-f指定要构建的dockerfile；-t为生成的镜像取名
$ docker run yuanya/centos -d #如果后面出现容器数据卷只能读的情况，就加上--privileged=true赋予容器扩展的特权
$ docker inspect yuanya/centos
</code></pre>
</li>
</ul>
<h6 id="数据卷容器"><a class="header" href="#数据卷容器">数据卷容器</a></h6>
<ul>
<li>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器</li>
<li>即容器间传递共享(--volumes-from)</li>
</ul>
<pre><code class="language-shell">$ docker run yuanya/centos -it --name dc01 #启动一个01
$ docker run yuanya/centos -it --name dc02 --volumes-from dc01 #将使dc02与dc01共享VOLUME配置的数据卷
$ docker run yuanya/centos -it --name dc03 --volumes-from dc01 #将使dc03与dc01共享VOLUME配置的数据卷
#即完成dc01、dc02、dc03之间相互共享VOLUME配置的数据卷
</code></pre>
<h2 id="dockerfile-1"><a class="header" href="#dockerfile-1">DockerFile</a></h2>
<ul>
<li>Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本</li>
</ul>
<pre><code class="language-dockerfile">#相当于docker run 时加 bash
CMD /bin/bash
CMD [&quot;/bin/bash&quot;]
</code></pre>
<p>dockerfile解析过程</p>
<ul>
<li>Dockerfile内容基础知识
<ul>
<li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li>
<li>指令按照从上到下，顺序执行</li>
<li>#表示注释</li>
<li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li>
</ul>
</li>
<li>保留字指令（关键字）
<ul>
<li>FROM：基础镜像，当前新镜像是基于哪个镜像的</li>
<li>MAINTAINER：镜像维护者 的姓名和邮箱地址</li>
<li>RUN：容器构建时需要运行的命令</li>
<li>EXPOSE：当前容器对外暴露出的端口</li>
<li>WORKDIR：指定在创建容器后，进入容器伪终端的默认工作目录</li>
<li>ENV：用来在构建镜像过程中设置环境变量
<ul>
<li>如 ENV MY_ PATH /usr/mytest。这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一-样；也可以在其它指令中直接使用这些环境变量，比如: WORKDIR $MY_ PATH</li>
</ul>
</li>
<li>ADD：copy + 解压缩。将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</li>
<li>COPY：类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置
<ul>
<li>shell格式：COPY src des</li>
<li>exec格式：COPY [&quot;src&quot;, &quot;dest&quot;]</li>
</ul>
</li>
<li>VOLUME：容器数据卷， 用于数据保存和持久化工作</li>
<li>CMD
<ul>
<li>指定一个容器启动时要运行的命令。CMD指令的格式和RUN 相似,也是两种格式
<ul>
<li>shell格式：CMD &lt;命令&gt;</li>
<li>exec格式：CMD [&quot;可执行文件&quot;，”参数1&quot;， “参数2...]</li>
<li>参数列表格式：CMD [&quot;参数1&quot;，“参数2&quot;...]。在指定了ENTRYPOINT 指令后，用CMD 指定具体的参
数。</li>
</ul>
</li>
<li>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换.。</li>
</ul>
</li>
<li>ENTRYPOINT
<ul>
<li>指定一个容器启动时要运行的命令</li>
<li>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数，但是命令是追加的，不会覆盖前面的命令，比如在是 ENTRYPOINT [&quot;可执行文件&quot;，”参数1&quot;]，运行时docker run xxx -i，将变为ENTRYPOINT [&quot;可执行文件&quot;，”参数1&quot;，&quot;-i&quot;]，等于可以追加参数的效果</li>
</ul>
</li>
<li>ONBUILD：当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</li>
</ul>
</li>
</ul>
<p>案例</p>
<ul>
<li>
<p>Base镜像(scratch)：DockerHub中99%的镜像都是通过在base镜像中安装和配置需要的软件构建出来的</p>
<ul>
<li>scratch：an explicitly empty image, especially for building images &quot;FROM scratch&quot;</li>
</ul>
</li>
<li>
<p>centos的镜像很精简，我们通过dockerfile自定义一个centos镜像使其拥有vim、ifconfig等命令及其它自定义内容</p>
<p>/mydocker/dockerfile01</p>
<pre><code class="language-dockerfile">from centos
MAINTAINER yuanya&lt;yuanyatianchi@google.com&gt;

ENV MY_PATH /tmp
WORKDIR $MY_PATH

RUN yum -y install vim
RUN yum -y install net-tools

EXPOSE 80

CMD echo $MY_PATH
CMD echo &quot;success-ok&quot;
CMD /bin/bash
</code></pre>
<pre><code class="language-shell">$ docker build -f /mydocker/dockerfile01 -t mycentos:1.0 #构建
$ docker run - it mycentos:1.0 #运行
$ docker history &lt;容器id&gt; #查看历史
</code></pre>
</li>
</ul>
<p>定制tomcat9</p>
<pre><code class="language-dockerfile">FROM centos
MAINTAINER zzyy&lt; zzyybs@126. com&gt;
#把宿主机当前上下文的C. txt拷贝到容器/usr/local/路径下
COPY c.txt /usr/local/cincontainer.txt
#把java与tomcat添加到容器中
ADD jdk 8u171- linux -x64. tar .gz /usr/local/
ADD apache tomcat 9.0.8. tar.gz /usr/local/
#安装vim编辑器
RUN yum -y install vim
#设置工作访问时候的WORKDIR路径，登录落脚点
ENV MYPATH /usr/local
WORKDIR $MYPATH
#配置java与tomcat环境变量
ENV JAVA HOME /usr/local/jdk1.8.0_ 171
ENV CLASSPATH $JAVA HOME/lib/dt . jar :$JAVA_ HOME/1ib/ tools. jan
ENV CATALINA HOME /usr/local/apache-tomcat-9.0.8
ENV CATALINA BASE /usr/ local/ apache-tomcat-9.0.8
ENV PATH $PATH:$JAVA_ HOME/bin: $CATAL INA HOME/lib: $CATAL INA HOME/bin
#容器运行时监听的端口
EXPOSE 8080
#启动时运行tomcat
# ENTRYPOINT [&quot; /usr/local/ apache -tomcat 9.0.8/bin/startup.sh&quot; ]
# CMD [&quot; /usr/local/apache -tomcat- 9.0. 8/bin/catalina. sh&quot; ,&quot;run&quot;]
CMD /usr/1ocal/apache-tomcat-9.0.8/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.8/bin/1ogs/catalina.out

</code></pre>
<pre><code class="language-shell">docker run -d -p 9080:8080 --name myt9
-V /zzyyuse/mydockerfile/tomcat9/tesf:/usr/local/apache-tomcat-9.0.8/webapps/ test
-V /zzyyuse/mydockerfile/tomcat9/tomcat9logs/:/usr/local/apache-tomcat-9.0.8/logs
--pr ivi leged=true
zzyytomcat9
#设置容器卷，可以使我们直接把服务部署到主机tomcat9/test即可同步到容器tomcat-9.0.8/webapps/test上运行了
</code></pre>
<h2 id="软件"><a class="header" href="#软件">软件</a></h2>
<h6 id="mysql"><a class="header" href="#mysql">MySql</a></h6>
<pre><code class="language-shell">$ docker pull mysql:5.7
$ docker run mysql:5.7 --name mysql01 -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=yuanya #设置MYSQL_ROOT_PASSWORD，否则密码随机
</code></pre>
<h6 id="elesticsearch"><a class="header" href="#elesticsearch">ElesticSearch</a></h6>
<pre><code class="language-shell">$ docker pull elasticsearch:7.5.2

$ docker run --name elasticsearch -d -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e &quot;ES_JAVA_OPTS=-Xms256m -Xmx256m&quot; elasticsearch:tag
</code></pre>
<h6 id="kibana"><a class="header" href="#kibana">Kibana</a></h6>
<pre><code class="language-shell">$ ocker pull kibana:7.5.2
$ docker run --name kibana --link elasticsearch_CONTAINER_ID:elasticsearch -d -p 5601:5601 kibana:tag
</code></pre>
<h6 id="rabbitmq"><a class="header" href="#rabbitmq">RabbitMQ</a></h6>
<p>带有management的是带有web控制台的，通过15672端口访问控制台，缺省账号密码guest</p>
<pre><code class="language-shell">$ docker pull rabbitmq:3.7.24-management 
$ docker run -d -p 5672:5672 -p 15672:15672 rabbitmq:3.7.24-management
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../计/虚拟化/虚拟网络.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../计/云原生/Kubernetes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../计/虚拟化/虚拟网络.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../计/云原生/Kubernetes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
